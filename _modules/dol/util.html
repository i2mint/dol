

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.util &mdash; dol 0.2.77 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=c7e8ed0a"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/kv_codecs.html">dol.kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/new_store_wrap.html">dol.scrap.new_store_wrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_appendable.html">dol.tests.test_appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_dol_tools.html">dol.tests.test_dol_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_filesys.html">dol.tests.test_filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_kv_codecs.html">dol.tests.test_kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_paths.html">dol.tests.test_paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_trans.html">dol.tests.test_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/utils_for_tests.html">dol.tests.utils_for_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dol.html">dol</a></li>
      <li class="breadcrumb-item active">dol.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;General util objects&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">T</span><span class="p">,</span>
    <span class="n">NewType</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">update_wrapper</span> <span class="k">as</span> <span class="n">_update_wrapper</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span> <span class="k">as</span> <span class="n">_wraps</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partialmethod</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">WRAPPER_ASSIGNMENTS</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">getsource</span>

<span class="n">Key</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Key&#39;</span><span class="p">)</span>
<span class="n">Key</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;The type of the keys used in the interface (outer keys)&quot;</span>
<span class="n">Id</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Id&#39;</span><span class="p">)</span>
<span class="n">Id</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;The type of the keys used in the backend (inner keys)&quot;</span>
<span class="n">Val</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Val&#39;</span><span class="p">)</span>
<span class="n">Val</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;The type of the values used in the interface (outer values)&quot;</span>
<span class="n">Data</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>
<span class="n">Data</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;The type of the values used in the backend (inner values)&quot;</span>
<span class="n">Item</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Key</span><span class="p">,</span> <span class="n">Val</span><span class="p">]</span>
<span class="n">KeyIter</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Key</span><span class="p">]</span>
<span class="n">ValIter</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Val</span><span class="p">]</span>
<span class="n">ItemIter</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">]</span>

<span class="c1"># monkey patching WRAPPER_ASSIGNMENTS to get &quot;proper&quot; wrapping (adding defaults and kwdefaults</span>
<span class="n">wrapper_assignments</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span> <span class="s2">&quot;__defaults__&quot;</span><span class="p">,</span> <span class="s2">&quot;__kwdefaults__&quot;</span><span class="p">)</span>

<span class="n">update_wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_update_wrapper</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>
<span class="n">wraps</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wraps</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>

<span class="n">exhaust</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">deque</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># TODO: Make identity_func &quot;identifiable&quot;. If we use the following one, we can use == to detect it&#39;s use,</span>
<span class="c1"># TODO: ... but there may be a way to annotate, register, or type any identity function so it can be detected.</span>
<span class="k">def</span> <span class="nf">identity_func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="n">static_identity_method</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">identity_func</span><span class="p">)</span>


<div class="viewcode-block" id="named_partial">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.named_partial">[docs]</a>
<span class="k">def</span> <span class="nf">named_partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;functools.partial, but with a __name__</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;print&#39;</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;, __name__=&#39;now_partial_has_a_name&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;now_partial_has_a_name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">f</span></div>



<div class="viewcode-block" id="staticproperty">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.staticproperty">[docs]</a>
<span class="k">class</span> <span class="nc">staticproperty</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A decorator for defining static properties in classes.</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     @staticproperty</span>
<span class="sd">    ...     def foo():</span>
<span class="sd">    ...         return 2</span>
<span class="sd">    &gt;&gt;&gt; A.foo</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; A().foo</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">owner</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">()</span></div>



<div class="viewcode-block" id="add_as_attribute_of">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.add_as_attribute_of">[docs]</a>
<span class="k">def</span> <span class="nf">add_as_attribute_of</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator that adds a function as an attribute of a container object ``obj``.</span>

<span class="sd">    If no ``name`` is given, the ``__name__`` of the function will be used, with a</span>
<span class="sd">    leading underscore removed. This is useful for adding helper functions to main</span>
<span class="sd">    &quot;container&quot; functions without polluting the namespace of the module, at least</span>
<span class="sd">    from the point of view of imports and tab completion.</span>

<span class="sd">    &gt;&gt;&gt; def foo():</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @add_as_attribute_of(foo)</span>
<span class="sd">    ... def _helper():</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt; hasattr(foo, &#39;helper&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; callable(foo.helper)</span>
<span class="sd">    True</span>

<span class="sd">    In reality, any object that has a ``__name__`` can be added to the attribute of</span>
<span class="sd">    ``obj``, but the intention is to add helper functions to main &quot;container&quot; functions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">attrname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attrname</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove leading underscore</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">return</span> <span class="n">_decorator</span></div>



<div class="viewcode-block" id="chain_get">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.chain_get">[docs]</a>
<span class="k">def</span> <span class="nf">chain_get</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the ``d[key]`` value for the first ``key`` in ``keys`` that is in ``d``, and default if none are found</span>

<span class="sd">    Note: Think of ``collections.ChainMap`` where you can look for a single key in a sequence of maps until we find it.</span>
<span class="sd">    Here we look for a sequence of keys in a single map, stopping as soon as we find a key that the map has.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;here&#39;: &#39;&amp;&#39;, &#39;there&#39;: &#39;and&#39;, &#39;every&#39;: &#39;where&#39;}</span>
<span class="sd">    &gt;&gt;&gt; chain_get(d, [&#39;not there&#39;, &#39;not there either&#39;, &#39;there&#39;, &#39;every&#39;])</span>
<span class="sd">    &#39;and&#39;</span>

<span class="sd">    Notice how ``&#39;not there&#39;`` and ``&#39;not there either&#39;`` are skipped, ``&#39;there&#39;`` is found and used to retrieve</span>
<span class="sd">    the value, and ``&#39;every&#39;`` is not even checked (because ``&#39;there&#39;`` was found).</span>
<span class="sd">    If non of the keys are found, ``None`` is returned by default.</span>

<span class="sd">    &gt;&gt;&gt; assert chain_get(d, (&#39;none&#39;, &#39;of&#39;, &#39;these&#39;)) is None</span>

<span class="sd">    You can change this default though:</span>

<span class="sd">    &gt;&gt;&gt; chain_get(d, (&#39;none&#39;, &#39;of&#39;, &#39;these&#39;), default=&#39;Not Found&#39;)</span>
<span class="sd">    &#39;Not Found&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">default</span></div>



<div class="viewcode-block" id="LiteralVal">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.LiteralVal">[docs]</a>
<span class="k">class</span> <span class="nc">LiteralVal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An object to indicate that the value should be considered literally.</span>

<span class="sd">    &gt;&gt;&gt; t = LiteralVal(42)</span>
<span class="sd">    &gt;&gt;&gt; t.get_val()</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; t()</span>
<span class="sd">    42</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="LiteralVal.get_val">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.LiteralVal.get_val">[docs]</a>
    <span class="k">def</span> <span class="nf">get_val</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the value wrapped by LiteralVal instance.</span>

<span class="sd">        One might want to use ``literal.get_val()`` instead ``literal()`` to get the</span>
<span class="sd">        value a ``LiteralVal`` is wrapping because ``.get_val`` is more explicit.</span>

<span class="sd">        That said, with a bit of hesitation, we allow the ``literal()`` form as well</span>
<span class="sd">        since it is useful in situations where we need to use a callback function to</span>
<span class="sd">        get a value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span></div>


    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">get_val</span></div>


    <span class="c1"># def __get__(self, instance, owner):</span>
    <span class="c1">#     return self.val</span>


<div class="viewcode-block" id="decorate_callables">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.decorate_callables">[docs]</a>
<span class="k">def</span> <span class="nf">decorate_callables</span><span class="p">(</span><span class="n">decorator</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorate all (non-underscored) callables in a class with a decorator.</span>

<span class="sd">    &gt;&gt;&gt; from dol.util import LiteralVal</span>
<span class="sd">    &gt;&gt;&gt; @decorate_callables(property)</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     def wet(self):</span>
<span class="sd">    ...         return &#39;dry&#39;</span>
<span class="sd">    ...     @LiteralVal</span>
<span class="sd">    ...     def big(self):</span>
<span class="sd">    ...         return &#39;small&#39;</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a.wet</span>
<span class="sd">    &#39;dry&#39;</span>
<span class="sd">    &gt;&gt;&gt; a.big()</span>
<span class="sd">    &#39;small&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">decorate_callables</span><span class="p">,</span> <span class="n">decorator</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">LiteralVal</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">get_val</span><span class="p">())</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">decorator</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>
    <span class="k">return</span> <span class="bp">cls</span></div>



<span class="c1"># class LiteralVal:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     An object to indicate that the value should be considered literally.</span>

<span class="c1">#     &gt;&gt;&gt; t = LiteralVal(42)</span>
<span class="c1">#     &gt;&gt;&gt; t.get_val()</span>
<span class="c1">#     42</span>
<span class="c1">#     &gt;&gt;&gt; t()</span>
<span class="c1">#     42</span>

<span class="c1">#     &gt;&gt;&gt; class A:</span>
<span class="c1">#     ...     @LiteralVal</span>
<span class="c1">#     ...     def value(self):</span>
<span class="c1">#     ...         return 42</span>
<span class="c1">#     &gt;&gt;&gt; a = A()</span>
<span class="c1">#     &gt;&gt;&gt; a.value</span>
<span class="c1">#     42</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     def __init__(self, val):</span>
<span class="c1">#         if callable(val):</span>
<span class="c1">#             self.val = val()</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.val = val</span>

<span class="c1">#     def get_val(self):</span>
<span class="c1">#         &quot;&quot;&quot;Get the value wrapped by LiteralVal instance.&quot;&quot;&quot;</span>
<span class="c1">#         return self.val</span>

<span class="c1">#     def __call__(self):</span>
<span class="c1">#         return self.get_val()</span>

<span class="c1">#     def __get__(self, instance, owner):</span>
<span class="c1">#         return self.val</span>

<span class="c1"># def decorate_callables(decorator, cls=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Decorate all (non-underscored) callables in a class with a decorator.</span>

<span class="c1">#     &gt;&gt;&gt; @decorate_callables(property)</span>
<span class="c1">#     ... class A:</span>
<span class="c1">#     ...     def wet(self):</span>
<span class="c1">#     ...         return &#39;dry&#39;</span>
<span class="c1">#     ...     @LiteralVal</span>
<span class="c1">#     ...     def big(self):</span>
<span class="c1">#     ...         return &#39;small&#39;</span>
<span class="c1">#     &gt;&gt;&gt; a = A()</span>
<span class="c1">#     &gt;&gt;&gt; a.wet</span>
<span class="c1">#     &#39;dry&#39;</span>
<span class="c1">#     &gt;&gt;&gt; a.big</span>
<span class="c1">#     &#39;small&#39;</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     if cls is None:</span>
<span class="c1">#         return partial(decorate_callables, decorator)</span>
<span class="c1">#     for name, attr in vars(cls).items():</span>
<span class="c1">#         if isinstance(attr, LiteralVal):</span>
<span class="c1">#             setattr(cls, name, property(attr.get_val))</span>
<span class="c1">#         elif not name.startswith(&#39;_&#39;) and callable(attr):</span>
<span class="c1">#             setattr(cls, name, decorator(attr))</span>
<span class="c1">#     return cls</span>


<span class="k">def</span> <span class="nf">_isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The same as the builtin isinstance, but without the position only restriction,</span>
<span class="sd">    allowing us to use partial to define filter functions for specific types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">)</span>


<div class="viewcode-block" id="instance_checker">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.instance_checker">[docs]</a>
<span class="k">def</span> <span class="nf">instance_checker</span><span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a filter function that checks the type of an object.</span>

<span class="sd">    &gt;&gt;&gt; f = instance_checker(int, float)</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f(1.0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;1.0&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_isinstance</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="o">=</span><span class="n">types</span><span class="p">)</span></div>



<div class="viewcode-block" id="not_a_mac_junk_path">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.not_a_mac_junk_path">[docs]</a>
<span class="k">def</span> <span class="nf">not_a_mac_junk_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function that will tell you if the path is not a mac junk path/</span>
<span class="sd">    More precisely, doesn&#39;t end with &#39;.DS_Store&#39; or have a `__MACOSX` folder somewhere</span>
<span class="sd">    on it&#39;s way.</span>

<span class="sd">    This is usually meant to be used with `filter` or `filt_iter` to &quot;filter in&quot; only</span>
<span class="sd">    those actually wanted files (not the junk that mac writes to your filesystem).</span>

<span class="sd">    These files annoyingly show up often in zip files, and are usually unwanted.</span>

<span class="sd">    See https://apple.stackexchange.com/questions/239578/compress-without-ds-store-and-macosx</span>

<span class="sd">    &gt;&gt;&gt; paths = [&#39;A/normal/path&#39;, &#39;A/__MACOSX/path&#39;, &#39;path/ending/in/.DS_Store&#39;, &#39;foo/b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(not_a_mac_junk_path, paths))</span>
<span class="sd">    [&#39;A/normal/path&#39;, &#39;foo/b&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.DS_Store&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;__MACOSX&quot;</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># This is indeed math junk (so filter out)</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># this is not mac junk (you can keep it)</span></div>



<div class="viewcode-block" id="inject_method">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.inject_method">[docs]</a>
<span class="k">def</span> <span class="nf">inject_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_function</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    method_function could be:</span>
<span class="sd">        * a function</span>
<span class="sd">        * a {method_name: function, ...} dict (for multiple injections)</span>
<span class="sd">        * a list of functions or (function, method_name) pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_function</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span>
        <span class="n">method_function</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;method_function (the second argument) is supposed to be a callable!&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">method_name</span><span class="p">,</span> <span class="nb">str</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;method_name (the third argument) is supposed to be a string!&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">method_function</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">method_function</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method_function</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span></div>



<span class="k">def</span> <span class="nf">_disabled_clear_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The clear method is disabled to make dangerous difficult.</span>
<span class="sd">    You don&#39;t want to delete your whole DB</span>
<span class="sd">    If you really want to delete all your data, you can do so by doing something like this:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        for k in self:</span>
<span class="sd">            del self[k]</span>


<span class="sd">    or (in some cases)</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        for k in self:</span>
<span class="sd">            try:</span>
<span class="sd">                del self[k]</span>
<span class="sd">            except KeyError:</span>
<span class="sd">                pass</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instance of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="o">.</span><span class="vm">__doc__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># to be able to check if clear is disabled (see ensure_clear_method function for example):</span>
<span class="n">_disabled_clear_method</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="has_enabled_clear_method">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.has_enabled_clear_method">[docs]</a>
<span class="k">def</span> <span class="nf">has_enabled_clear_method</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True iff obj has a clear method that is enabled (i.e. not disabled)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;clear&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>  <span class="c1"># has a clear method...</span>
        <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">clear</span><span class="p">,</span> <span class="s2">&quot;disabled&quot;</span><span class="p">)</span>  <span class="c1"># that doesn&#39;t have a disabled attribute</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">store</span><span class="o">.</span><span class="n">clear</span><span class="o">.</span><span class="n">disabled</span>
    <span class="p">)</span>  <span class="c1"># ... or if it does, than it must not be == True</span></div>



<span class="k">def</span> <span class="nf">_delete_keys_one_by_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;clear the entire store (delete all keys)&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_delete_keys_one_by_one_with_keyerror_supressed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;clear the entire store (delete all keys), ignoring KeyErrors&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="n">_delete_keys_one_by_one</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">_delete_keys_one_by_one_with_keyerror_supressed</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># Note: Vendored in i2.multi_objects and lkj.strings</span>
<div class="viewcode-block" id="truncate_string_with_marker">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.truncate_string_with_marker">[docs]</a>
<span class="k">def</span> <span class="nf">truncate_string_with_marker</span><span class="p">(</span>
    <span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">left_limit</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">right_limit</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">middle_marker</span><span class="o">=</span><span class="s2">&quot;...&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string with a limited length.</span>

<span class="sd">    If the string is longer than the sum of the left_limit and right_limit,</span>
<span class="sd">    the string is truncated and the middle_marker is inserted in the middle.</span>

<span class="sd">    If the string is shorter than the sum of the left_limit and right_limit,</span>
<span class="sd">    the string is returned as is.</span>

<span class="sd">    &gt;&gt;&gt; truncate_string_with_marker(&#39;1234567890&#39;)</span>
<span class="sd">    &#39;1234567890&#39;</span>

<span class="sd">    But if the string is longer than the sum of the limits, it is truncated:</span>

<span class="sd">    &gt;&gt;&gt; truncate_string_with_marker(&#39;1234567890&#39;, left_limit=3, right_limit=3)</span>
<span class="sd">    &#39;123...890&#39;</span>
<span class="sd">    &gt;&gt;&gt; truncate_string_with_marker(&#39;1234567890&#39;, left_limit=3, right_limit=0)</span>
<span class="sd">    &#39;123...&#39;</span>
<span class="sd">    &gt;&gt;&gt; truncate_string_with_marker(&#39;1234567890&#39;, left_limit=0, right_limit=3)</span>
<span class="sd">    &#39;...890&#39;</span>

<span class="sd">    If you&#39;re using a specific parametrization of the function often, you can</span>
<span class="sd">    create a partial function with the desired parameters:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; truncate_string = partial(truncate_string_with_marker, left_limit=2, right_limit=2, middle_marker=&#39;---&#39;)</span>
<span class="sd">    &gt;&gt;&gt; truncate_string(&#39;1234567890&#39;)</span>
<span class="sd">    &#39;12---90&#39;</span>
<span class="sd">    &gt;&gt;&gt; truncate_string(&#39;supercalifragilisticexpialidocious&#39;)</span>
<span class="sd">    &#39;su---us&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">middle_marker_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">middle_marker</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">left_limit</span> <span class="o">+</span> <span class="n">right_limit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span>
    <span class="k">elif</span> <span class="n">right_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="n">left_limit</span><span class="p">]</span> <span class="o">+</span> <span class="n">middle_marker</span>
    <span class="k">elif</span> <span class="n">left_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">middle_marker</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">right_limit</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="n">left_limit</span><span class="p">]</span> <span class="o">+</span> <span class="n">middle_marker</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="n">right_limit</span><span class="p">:]</span></div>



<span class="k">def</span> <span class="nf">signature_string_or_default</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;(-no signature-)&quot;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>


<span class="k">def</span> <span class="nf">function_info_string</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">func_name</span> <span class="o">==</span> <span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;a lambda function on </span><span class="si">{</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}{</span><span class="n">signature_string_or_default</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="c1"># Note: Pipe code is completely independent (with inspect imports signature &amp; Signature)</span>
<span class="c1">#  If you only need simple pipelines, use this, or even copy/paste it where needed.</span>
<span class="c1"># TODO: Public interface mis-aligned with i2. funcs list here, in i2 it&#39;s dict. Align?</span>
<span class="c1">#  If we do so, it would be a breaking change since any dependents that expect funcs</span>
<span class="c1">#  to be a list of funcs will iterate over a iterable of names instead.</span>
<div class="viewcode-block" id="Pipe">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.Pipe">[docs]</a>
<span class="k">class</span> <span class="nc">Pipe</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple function composition. That is, gives you a callable that implements input -&gt; f_1 -&gt; ... -&gt; f_n -&gt; output.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b=2):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; f = Pipe(foo, lambda x: print(f&quot;x: {x}&quot;))</span>
<span class="sd">    &gt;&gt;&gt; f(3)</span>
<span class="sd">    x: 5</span>
<span class="sd">    &gt;&gt;&gt; len(f)</span>
<span class="sd">    2</span>

<span class="sd">    You can name functions, but this would just be for documentation purposes.</span>
<span class="sd">    The names are completely ignored.</span>

<span class="sd">    &gt;&gt;&gt; g = Pipe(</span>
<span class="sd">    ...     add_numbers = lambda x, y: x + y,</span>
<span class="sd">    ...     multiply_by_2 = lambda x: x * 2,</span>
<span class="sd">    ...     stringify = str</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; g(2, 3)</span>
<span class="sd">    &#39;10&#39;</span>
<span class="sd">    &gt;&gt;&gt; len(g)</span>
<span class="sd">    3</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Pipe instances don&#39;t have a __name__ etc. So some expectations of normal functions are not met.</span>
<span class="sd">        - Pipe instance are pickalable (as long as the functions that compose them are)</span>

<span class="sd">    You can specify a single functions:</span>

<span class="sd">    &gt;&gt;&gt; Pipe(lambda x: x + 1)(2)</span>
<span class="sd">    3</span>

<span class="sd">    but</span>

<span class="sd">    &gt;&gt;&gt; Pipe()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    ValueError: You need to specify at least one function!</span>

<span class="sd">    You can specify an instance name and/or doc with the special (reserved) argument</span>
<span class="sd">    names ``__name__`` and ``__doc__`` (which therefore can&#39;t be used as function names):</span>

<span class="sd">    &gt;&gt;&gt; f = Pipe(map, add_it=sum, __name__=&#39;map_and_sum&#39;, __doc__=&#39;Apply func and add&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f(lambda x: x * 10, [1, 2, 3])</span>
<span class="sd">    60</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;map_and_sum&#39;</span>
<span class="sd">    &gt;&gt;&gt; f.__doc__</span>
<span class="sd">    &#39;Apply func and add&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">funcs</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_funcs</span><span class="p">):</span>
        <span class="n">named_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_reserved_names</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">)</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">funcs</span>
        <span class="n">n_funcs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You need to specify at least one function!&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">other_funcs</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">first_func</span> <span class="o">=</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="n">funcs</span>
            <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">other_funcs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_signature_from_first_and_last_func</span><span class="p">(</span>
            <span class="n">first_func</span><span class="p">,</span> <span class="n">last_func</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="n">first_func</span><span class="p">,</span> <span class="n">other_funcs</span>

    <span class="n">_reserved_names</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_reserved_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">:=</span> <span class="n">named_funcs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">named_funcs</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># first call has no exeption handling, but subsequent calls do</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other_funcs</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mk_pipe_call_error</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_mk_pipe_call_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_obj</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Error calling function </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_info_str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;on input </span><span class="si">{</span><span class="n">truncate_string_with_marker</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;which was the output of previous function&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_info_str</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">args_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="n">kwargs_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;The error was cause by calling </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> on (</span><span class="si">{</span><span class="n">args_str</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">kwargs_str</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;Error was: </span><span class="si">{</span><span class="n">error_obj</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">new_error_obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">error_obj</span><span class="p">)(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">new_error_obj</span><span class="o">.</span><span class="n">error_context</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Pipe&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span>
            <span class="s2">&quot;args&quot;</span><span class="p">:</span> <span class="n">args</span><span class="p">,</span>
            <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">,</span>
            <span class="s2">&quot;func_index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
            <span class="s2">&quot;func&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="s2">&quot;func_input&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">new_error_obj</span>

    <span class="k">def</span> <span class="nf">_func_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">func_info</span> <span class="o">=</span> <span class="n">function_info_string</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func_info</span><span class="si">}</span><span class="s2"> (index=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>

    <span class="n">_dflt_signature</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_signature_from_first_and_last_func</span><span class="p">(</span><span class="n">first_func</span><span class="p">,</span> <span class="n">last_func</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">input_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">first_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># function doesn&#39;t have a signature, so take default</span>
            <span class="n">input_params</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_dflt_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">last_func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># function doesn&#39;t have a signature, so take default</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_dflt_signature</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">input_params</span><span class="p">),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">pipe</span><span class="o">.</span><span class="n">funcs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">_flatten_pipe</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func</span>


<div class="viewcode-block" id="flatten_pipe">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.flatten_pipe">[docs]</a>
<span class="k">def</span> <span class="nf">flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unravel nested Pipes to get a flat &#39;sequence of functions&#39; version of input.</span>

<span class="sd">    &gt;&gt;&gt; def f(x): return x + 1</span>
<span class="sd">    &gt;&gt;&gt; def g(x): return x * 2</span>
<span class="sd">    &gt;&gt;&gt; def h(x): return x - 3</span>
<span class="sd">    &gt;&gt;&gt; a = Pipe(f, g, h)</span>
<span class="sd">    &gt;&gt;&gt; b = Pipe(f, Pipe(g, h))</span>
<span class="sd">    &gt;&gt;&gt; len(a)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; len(b)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; c = flatten_pipe(b)</span>
<span class="sd">    &gt;&gt;&gt; len(c)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; assert a(10) == b(10) == c(10) == 19</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="o">*</span><span class="n">_flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span></div>



<div class="viewcode-block" id="partialclass">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.partialclass">[docs]</a>
<span class="k">def</span> <span class="nf">partialclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;What partial(cls, *args, **kwargs) does, but returning a class instead of an object.</span>

<span class="sd">    :param cls: Class to get the partial of</span>
<span class="sd">    :param kwargs: The kwargs to fix</span>

<span class="sd">    The raison d&#39;être of partialclass is that it returns a type, so let&#39;s have a look at that with</span>
<span class="sd">    a useless class.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(A, type) == isinstance(partialclass(A), type) == True</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=0, b=1):</span>
<span class="sd">    ...         self.a, self.b = a, b</span>
<span class="sd">    ...     def mysum(self):</span>
<span class="sd">    ...         return self.a + self.b</span>
<span class="sd">    ...     def __repr__(self):</span>
<span class="sd">    ...         return f&quot;{self.__class__.__name__}(a={self.a}, b={self.b})&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(A, type) == isinstance(partialclass(A), type) == True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(A)) == &#39;(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; assert a.mysum() == 1</span>
<span class="sd">    &gt;&gt;&gt; assert str(a) == &#39;A(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert A(a=10).mysum() == 11</span>
<span class="sd">    &gt;&gt;&gt; assert str(A()) == &#39;A(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, b=2)</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(a=0, *, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; aa = AA()</span>
<span class="sd">    &gt;&gt;&gt; assert aa.mysum() == 2</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &#39;A(a=0, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert AA(a=1, b=3).mysum() == 4</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(3)) == &#39;A(a=3, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, a=7)</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(*, a=7, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert AA().mysum() == 8</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(a=3)) == &#39;A(a=3, b=1)&#39;</span>

<span class="sd">    Note in the last partial that since ``a`` was fixed, you need to specify the keyword ``AA(a=3)``.</span>
<span class="sd">    ``AA(3)`` won&#39;t work:</span>

<span class="sd">    &gt;&gt;&gt; AA(3)  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: __init__() got multiple values for argument &#39;a&#39;</span>

<span class="sd">    On the other hand, you can use *args to specify the fixtures:</span>

<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, 22)</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA()) == &#39;A(a=22, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(3)) == &#39;A(a=22, b=3)&#39;</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;cls should be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">class</span> <span class="nc">PartialClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">copy_attrs</span><span class="p">(</span>
        <span class="n">PartialClass</span><span class="p">,</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">PartialClass</span></div>



<div class="viewcode-block" id="copy_attrs">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.copy_attrs">[docs]</a>
<span class="k">def</span> <span class="nf">copy_attrs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">raise_error_if_an_attr_is_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy attributes from one object to another.</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     x = 0</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     x = 1</span>
<span class="sd">    ...     yy = 2</span>
<span class="sd">    ...     zzz = 3</span>
<span class="sd">    &gt;&gt;&gt; dict_of = lambda o: {a: getattr(o, a) for a in dir(A) if not a.startswith(&#39;_&#39;)}</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 0}</span>
<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, &#39;yy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 0, &#39;yy&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, [&#39;x&#39;, &#39;zzz&#39;])</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;yy&#39;: 2, &#39;zzz&#39;: 3}</span>

<span class="sd">    But if you try to copy something that `B` (the source) doesn&#39;t have, copy_attrs will complain:</span>

<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, &#39;this_is_not_an_attr&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    AttributeError: type object &#39;B&#39; has no attribute &#39;this_is_not_an_attr&#39;</span>

<span class="sd">    If you tell it not to complain, it&#39;ll just ignore attributes that are not in source.</span>

<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, [&#39;nothing&#39;, &#39;here&#39;, &#39;exists&#39;], raise_error_if_an_attr_is_missing=False)</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;yy&#39;: 2, &#39;zzz&#39;: 3}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">attrs</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">raise_error_if_an_attr_is_missing</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>



<span class="k">def</span> <span class="nf">copy_attrs_from</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="n">to_obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deprecated. Use copy_attrs instead.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">copy_attrs</span><span class="p">(</span><span class="n">to_obj</span><span class="p">,</span> <span class="n">from_obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">to_obj</span>


<div class="viewcode-block" id="norm_kv_filt">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.norm_kv_filt">[docs]</a>
<span class="k">def</span> <span class="nf">norm_kv_filt</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare a boolean function to be used with `filter` when fed an iterable of (k, v) pairs.</span>

<span class="sd">    So you have a mapping. Say a dict `d`. Now you want to go through d.items(),</span>
<span class="sd">    filtering based on the keys, or the values, or both.</span>

<span class="sd">    It&#39;s not hard to do, really. If you&#39;re using a dict you might use a dict comprehension,</span>
<span class="sd">    or in the general case you might do a `filter(lambda kv: my_filt(kv[0], kv[1]), d.items())`</span>
<span class="sd">    if you have a `my_filt` that works wiith k and v, etc.</span>

<span class="sd">    But thought simple, it can become a bit muddled.</span>
<span class="sd">    `norm_kv_filt` simplifies this by allowing you to bring your own filtering boolean function,</span>
<span class="sd">    whether it&#39;s a key-based, value-based, or key-value-based one, and it will make a</span>
<span class="sd">    ready-to-use with `filter` function for you.</span>

<span class="sd">    Only thing: Your function needs to call a key `k` and a value `v`.</span>
<span class="sd">    But hey, it&#39;s alright, if you have a function that calls things differently, just do</span>
<span class="sd">    something like</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        new_filt_func = lambda k, v: your_filt_func(..., key=k, ..., value=v, ...)</span>

<span class="sd">    and all will be fine.</span>

<span class="sd">    :param kv_filt: callable (starting with signature (k), (v), or (k, v)), and returning  a boolean</span>
<span class="sd">    :return: A normalized callable.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda k: k in {&#39;b&#39;, &#39;d&#39;}), d.items()))</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda v: v &gt; 2), d.items()))</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;d&#39;, 4)]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda k, v: (v &gt; 1) &amp; (k != &#39;c&#39;)), d.items()))</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kv_filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># because `filter` works with a callable, or None, so we align</span>

    <span class="n">raise_msg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;kv_filt should be callable (starting with signature (k), (v), or (k, v)),&quot;</span>
        <span class="s2">&quot;and returning  a boolean. What you gave me was </span><span class="si">{fv_filt}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">),</span> <span class="n">raise_msg</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">raise_msg</span>
    <span class="n">_kv_filt</span> <span class="o">=</span> <span class="n">kv_filt</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_kv_filt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;k&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;v&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">raise_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">raise_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__kv_filt</span><span class="p">(</span><span class="n">kv_item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kv_filt</span><span class="p">(</span><span class="o">*</span><span class="n">kv_item</span><span class="p">)</span>

    <span class="n">__kv_filt</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">kv_filt</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">return</span> <span class="n">__kv_filt</span></div>



<span class="n">var_str_p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W|^(?=\d)&quot;</span><span class="p">)</span>

<span class="n">Item</span> <span class="o">=</span> <span class="n">Any</span>


<div class="viewcode-block" id="add_attrs">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.add_attrs">[docs]</a>
<span class="k">def</span> <span class="nf">add_attrs</span><span class="p">(</span><span class="n">remember_added_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">if_attr_exists</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a function that will add attributes to an obj.</span>
<span class="sd">    Originally meant to be used as a decorator of a function, to inject</span>

<span class="sd">    &gt;&gt;&gt; from dol.util import add_attrs</span>
<span class="sd">    &gt;&gt;&gt; @add_attrs(bar=&#39;bituate&#39;, hello=&#39;world&#39;)</span>
<span class="sd">    ... def foo():</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; [x for x in dir(foo) if not x.startswith(&#39;_&#39;)]</span>
<span class="sd">    [&#39;bar&#39;, &#39;hello&#39;]</span>
<span class="sd">    &gt;&gt;&gt; foo.bar</span>
<span class="sd">    &#39;bituate&#39;</span>
<span class="sd">    &gt;&gt;&gt; foo.hello</span>
<span class="sd">    &#39;world&#39;</span>
<span class="sd">    &gt;&gt;&gt; foo._added_attrs  # Another attr was added to hold the list of attributes added (in case we need to remove them</span>
<span class="sd">    [&#39;bar&#39;, &#39;hello&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_attrs_to_func</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">attrs_added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_val</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> already exists in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s2"> already exists in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s2">&quot;skip&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unknown value for if_attr_exists: </span><span class="si">{</span><span class="n">if_attr_exists</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_val</span><span class="p">)</span>
            <span class="n">attrs_added</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remember_added_attrs</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_added_attrs</span> <span class="o">=</span> <span class="n">attrs_added</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">add_attrs_to_func</span></div>



<span class="k">def</span> <span class="nf">fullpath</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;~&quot;</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">attrs_of</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<div class="viewcode-block" id="format_invocation">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.format_invocation">[docs]</a>
<span class="k">def</span> <span class="nf">format_invocation</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a name, positional arguments, and keyword arguments, format</span>
<span class="sd">    a basic Python-style function call.</span>

<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;func&#39;, args=(1, 2), kwargs={&#39;c&#39;: 3}))</span>
<span class="sd">    func(1, 2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;a_func&#39;, args=(1,)))</span>
<span class="sd">    a_func(1)</span>
<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;kw_func&#39;, kwargs=[(&#39;a&#39;, 1), (&#39;b&#39;, 2)]))</span>
<span class="sd">    kw_func(a=1, b=2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">a_text</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="n">kw_text</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwarg_items</span><span class="p">])</span>

    <span class="n">all_args_text</span> <span class="o">=</span> <span class="n">a_text</span>
    <span class="k">if</span> <span class="n">all_args_text</span> <span class="ow">and</span> <span class="n">kw_text</span><span class="p">:</span>
        <span class="n">all_args_text</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span>
    <span class="n">all_args_text</span> <span class="o">+=</span> <span class="n">kw_text</span>

    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">all_args_text</span><span class="p">)</span></div>



<div class="viewcode-block" id="groupby">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.groupby">[docs]</a>
<span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">],</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Groups items according to group keys updated from those items through the given</span>
<span class="sd">    (item_to_)key function.</span>

<span class="sd">    Args:</span>
<span class="sd">        items: iterable of items</span>
<span class="sd">        key: The function that computes a key from an item. Needs to return a hashable.</span>
<span class="sd">        val: An optional function that computes a val from an item. If not given, the item itself will be taken.</span>
<span class="sd">        group_factory: The function to make new (empty) group objects and accumulate group items.</span>
<span class="sd">            group_items = group_factory() will be called to make a new empty group collection</span>
<span class="sd">            group_items.append(x) will be called to add x to that collection</span>
<span class="sd">            The default is `list`</span>

<span class="sd">    Returns: A dict of {group_key: items_in_that_group, ...}</span>

<span class="sd">    See Also: regroupby, itertools.groupby, and dol.source.SequenceKvReader</span>

<span class="sd">    &gt;&gt;&gt; groupby(range(11), key=lambda x: x % 3)</span>
<span class="sd">    {0: [0, 3, 6, 9], 1: [1, 4, 7, 10], 2: [2, 5, 8]}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, len)</span>
<span class="sd">    {3: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;, &#39;in&#39;], 1: [&#39;a&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; key_map = {1: &#39;one&#39;, 2: &#39;two&#39;}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda x: key_map.get(len(x), &#39;more&#39;))</span>
<span class="sd">    {&#39;more&#39;: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], &#39;two&#39;: [&#39;is&#39;, &#39;in&#39;], &#39;one&#39;: [&#39;a&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda w: w in stopwords)</span>
<span class="sd">    {True: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], False: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda w: [&#39;words&#39;, &#39;stopwords&#39;][int(w in stopwords)])</span>
<span class="sd">    {&#39;stopwords&#39;: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">group_factory</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span></div>



<div class="viewcode-block" id="regroupby">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.regroupby">[docs]</a>
<span class="k">def</span> <span class="nf">regroupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_key_funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursive groupby. Applies the groupby function recursively, using a sequence of key functions.</span>

<span class="sd">    Note: The named_key_funcs argument names don&#39;t have any external effect.</span>
<span class="sd">        They just give a name to the key function, for code reading clarity purposes.</span>

<span class="sd">    See Also: groupby, itertools.groupby, and dol.source.SequenceKvReader</span>

<span class="sd">    &gt;&gt;&gt; # group by how big the number is, then by it&#39;s mod 3 value</span>
<span class="sd">    &gt;&gt;&gt; # note that named_key_funcs argument names doesn&#39;t have any external effect (but give a name to the function)</span>
<span class="sd">    &gt;&gt;&gt; regroupby([1, 2, 3, 4, 5, 6, 7], lambda x: &#39;big&#39; if x &gt; 5 else &#39;small&#39;, mod3=lambda x: x % 3)</span>
<span class="sd">    {&#39;small&#39;: {1: [1, 4], 2: [2, 5], 0: [3]}, &#39;big&#39;: {0: [6], 1: [7]}}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; word_category = lambda x: &#39;stopwords&#39; if x in stopwords else &#39;words&#39;</span>
<span class="sd">    &gt;&gt;&gt; regroupby(tokens, word_category, len)</span>
<span class="sd">    {&#39;stopwords&#39;: {3: [&#39;the&#39;], 2: [&#39;in&#39;], 1: [&#39;a&#39;]}, &#39;words&#39;: {3: [&#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;]}}</span>
<span class="sd">    &gt;&gt;&gt; regroupby(tokens, len, word_category)</span>
<span class="sd">    {3: {&#39;stopwords&#39;: [&#39;the&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;box&#39;]}, 2: {&#39;words&#39;: [&#39;is&#39;], &#39;stopwords&#39;: [&#39;in&#39;]}, 1: {&#39;stopwords&#39;: [&#39;a&#39;]}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">named_key_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;You need to have at least one key_func&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">key_func</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span> <span class="o">=</span> <span class="n">key_funcs</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">group_key</span><span class="p">:</span> <span class="n">regroupby</span><span class="p">(</span><span class="n">group_items</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span></div>



<span class="n">Groups</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">GroupKey</span> <span class="o">=</span> <span class="n">Hashable</span>
<span class="n">GroupItems</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">]</span>
<span class="n">GroupReleaseCond</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">GroupKey</span><span class="p">,</span> <span class="n">GroupItems</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">Groups</span><span class="p">,</span> <span class="n">GroupKey</span><span class="p">,</span> <span class="n">GroupItems</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
<span class="p">]</span>


<div class="viewcode-block" id="igroupby">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.igroupby">[docs]</a>
<span class="k">def</span> <span class="nf">igroupby</span><span class="p">(</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">],</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">GroupKey</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">GroupItems</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">group_release_cond</span><span class="p">:</span> <span class="n">GroupReleaseCond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">release_remainding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">append_to_group_items</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">GroupItems</span><span class="p">,</span> <span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">,</span>
    <span class="n">grouper_mapping</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The generator version of dol groupby.</span>
<span class="sd">    Groups items according to group keys updated from those items through the given (item_to_)key function,</span>
<span class="sd">    yielding the groups according to a logic defined by ``group_release_cond``</span>

<span class="sd">    Args:</span>
<span class="sd">        items: iterable of items</span>
<span class="sd">        key: The function that computes a key from an item. Needs to return a hashable.</span>
<span class="sd">        val: An optional function that computes a val from an item. If not given, the item itself will be taken.</span>
<span class="sd">        group_factory: The function to make new (empty) group objects and accumulate group items.</span>
<span class="sd">            group_items = group_collector() will be called to make a new empty group collection</span>
<span class="sd">            group_items.append(x) will be called to add x to that collection</span>
<span class="sd">            The default is `list`</span>
<span class="sd">        group_release_cond: A boolean function that will be applied, at every iteration,</span>
<span class="sd">            to the accumulated items of the group that was just updated,</span>
<span class="sd">            and determines (if True) if the (group_key, group_items) should be yielded.</span>
<span class="sd">            The default is False, which results in</span>
<span class="sd">            ``lambda group_key, group_items: False`` being used.</span>
<span class="sd">        release_remainding: Once the input items have been consumed, there may still be some</span>
<span class="sd">            items in the grouping &quot;cache&quot;. ``release_remainding`` is a boolean that indicates whether</span>
<span class="sd">            the contents of this cache should be released or not.</span>

<span class="sd">    Yields: ``(group_key, items_in_that_group)`` pairs</span>


<span class="sd">    The following will group numbers according to their parity (0 for even, 1 for odd),</span>
<span class="sd">    releasing a list of numbers collected when that list reaches length 3:</span>

<span class="sd">    &gt;&gt;&gt; g = igroupby(items=range(11),</span>
<span class="sd">    ...             key=lambda x: x % 2,</span>
<span class="sd">    ...             group_release_cond=lambda k, v: len(v) == 3)</span>
<span class="sd">    &gt;&gt;&gt; list(g)</span>
<span class="sd">    [(0, [0, 2, 4]), (1, [1, 3, 5]), (0, [6, 8, 10]), (1, [7, 9])]</span>

<span class="sd">    If we specify ``release_remainding=False`` though, we won&#39;t get</span>

<span class="sd">    &gt;&gt;&gt; g = igroupby(items=range(11),</span>
<span class="sd">    ...             key=lambda x: x % 2,</span>
<span class="sd">    ...             group_release_cond=lambda k, v: len(v) == 3,</span>
<span class="sd">    ...             release_remainding=False)</span>
<span class="sd">    &gt;&gt;&gt; list(g)</span>
<span class="sd">    [(0, [0, 2, 4]), (1, [1, 3, 5]), (0, [6, 8, 10])]</span>

<span class="sd">    # &gt;&gt;&gt; grps = partial(igroupby, group_release_cond=False, release_remainding=True)</span>


<span class="sd">    Below we show that, with the default ``group_release_cond = lambda k, v: False``</span>
<span class="sd">    and release_remainding=True`` we have ``dict(igroupby(...)) == groupby(...)``</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from dol import groupby</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; kws = dict(items=range(11), key=lambda x: x % 3)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {0: [0, 3, 6, 9], 1: [1, 4, 7, 10], 2: [2, 5, 8]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; kws = dict(items=tokens, key=len)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {3: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;, &#39;in&#39;], 1: [&#39;a&#39;]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; key_map = {1: &#39;one&#39;, 2: &#39;two&#39;}</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda x: key_map.get(len(x), &#39;more&#39;))</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {&#39;more&#39;: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], &#39;two&#39;: [&#39;is&#39;, &#39;in&#39;], &#39;one&#39;: [&#39;a&#39;]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda w: w in stopwords)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {True: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], False: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]})</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda w: [&#39;words&#39;, &#39;stopwords&#39;][int(w in stopwords)])</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {&#39;stopwords&#39;: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]})</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">grouper_mapping</span><span class="p">(</span><span class="n">group_factory</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;group_release_cond should be callable (filter boolean function) or False. &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;Was </span><span class="si">{</span><span class="n">group_release_cond</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="n">n_group_release_cond_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_group_release_cond_args</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">(</span>
        <span class="s2">&quot;group_release_cond should take two or three inputs:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot; - (group_key, group_items), or</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot; - (groups, group_key, group_items)&quot;</span>
        <span class="sa">f</span><span class="s2">&quot;The arguments of the function you gave me are: </span><span class="si">{</span><span class="n">signature</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_append_to_group_items</span> <span class="o">=</span> <span class="n">append_to_group_items</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_append_to_group_items</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group_items</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">group_items</span><span class="p">,</span>
            <span class="n">val</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="n">group_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">group_items</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>
        <span class="n">_append_to_group_items</span><span class="p">(</span><span class="n">group_items</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group_release_cond</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span>
            <span class="k">del</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">release_remainding</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span></div>



<span class="k">def</span> <span class="nf">ntup</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;NamedTuple&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="str_to_var_str">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.str_to_var_str">[docs]</a>
<span class="k">def</span> <span class="nf">str_to_var_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a valid python variable string from the input string.</span>
<span class="sd">    Left untouched if already valid.</span>

<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;this_is_a_valid_var_name&#39;)</span>
<span class="sd">    &#39;this_is_a_valid_var_name&#39;</span>
<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;not valid  #)*(&amp;434&#39;)</span>
<span class="sd">    &#39;not_valid_______434&#39;</span>
<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;99_ballons&#39;)</span>
<span class="sd">    &#39;_99_ballons&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">var_str_p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill_with_dflts">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.fill_with_dflts">[docs]</a>
<span class="k">def</span> <span class="nf">fill_with_dflts</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dflt_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fed up with multiline handling of dict arguments?</span>
<span class="sd">    Fed up of repeating the if d is None: d = {} lines ad nauseam (because defaults can&#39;t be dicts as a default</span>
<span class="sd">    because dicts are mutable blah blah, and the python kings don&#39;t seem to think a mutable dict is useful enough)?</span>
<span class="sd">    Well, my favorite solution would be a built-in handling of the problem of complex/smart defaults,</span>
<span class="sd">    that is visible in the code and in the docs. But for now, here&#39;s one of the tricks I use.</span>

<span class="sd">    Main use is to handle defaults of function arguments. Say you have a function `func(d=None)` and you want</span>
<span class="sd">    `d` to be a dict that has at least the keys `foo` and `bar` with default values 7 and 42 respectively.</span>
<span class="sd">    Then, in the beginning of your function code you&#39;ll say:</span>

<span class="sd">        d = fill_with_dflts(d, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>

<span class="sd">    See examples to know how to use it.</span>

<span class="sd">    ATTENTION: A shallow copy of the dict is made. Know how that affects you (or not).</span>
<span class="sd">    ATTENTION: This is not recursive: It won&#39;t be filling any nested fields with defaults.</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The dict you want to &quot;fill&quot;</span>
<span class="sd">        dflt_dict: What to fill it with (a {k: v, ...} dict where if k is missing in d, you&#39;ll get a new field k, with</span>
<span class="sd">            value v.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a dict with the new key:val entries (if the key was missing in d).</span>

<span class="sd">    &gt;&gt;&gt; fill_with_dflts(None)</span>
<span class="sd">    {}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts(None, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts({}, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts({&#39;b&#39;: 1000}, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 1000}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">dflt_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dflt_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dflt_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span></div>



<span class="c1"># Note: Had replaced with cached_property (new in 3.8)</span>
<span class="c1"># if not sys.version_info &gt;= (3, 8):</span>
<span class="c1">#     from functools import cached_property</span>
<span class="c1"># # etc...</span>
<span class="c1"># But then I realized that the way cached_property is implemented, pycharm does not see the properties (lint)</span>
<span class="c1"># So I&#39;m reverting to lazyprop</span>
<span class="c1"># TODO: Keep track of the evolution of functools.cached_property and compare performance.</span>
<div class="viewcode-block" id="lazyprop">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.lazyprop">[docs]</a>
<span class="k">class</span> <span class="nc">lazyprop</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor implementation of lazyprop (cached property).</span>
<span class="sd">    Made based on David Beazley&#39;s &quot;Python Cookbook&quot; book and enhanced with boltons.cacheutils ideas.</span>

<span class="sd">    &gt;&gt;&gt; class Test:</span>
<span class="sd">    ...     def __init__(self, a):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     @lazyprop</span>
<span class="sd">    ...     def len(self):</span>
<span class="sd">    ...         print(&#39;generating &quot;len&quot;&#39;)</span>
<span class="sd">    ...         return len(self.a)</span>
<span class="sd">    &gt;&gt;&gt; t = Test([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4], &#39;len&#39;: 5}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; # But careful when using lazyprop that no one will change the value of a without deleting the property first</span>
<span class="sd">    &gt;&gt;&gt; t.a = [0, 1, 2]  # if we change a...</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... we still get the old cached value of len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; del t.len  # if we delete the len prop</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... then len being recomputed again</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isabstractmethod__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__isabstractmethod__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> func=</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span></div>



<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">weakref</span>


<span class="nd">@wraps</span><span class="p">(</span><span class="n">lru_cache</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">memoized_method</span><span class="p">(</span><span class="o">*</span><span class="n">lru_args</span><span class="p">,</span> <span class="o">**</span><span class="n">lru_kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Storing the wrapped method inside the instance since a strong reference to self would not allow it to die.</span>
            <span class="n">self_weak</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="nd">@lru_cache</span><span class="p">(</span><span class="o">*</span><span class="n">lru_args</span><span class="p">,</span> <span class="o">**</span><span class="n">lru_kwargs</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">cached_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">self_weak</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">cached_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cached_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped_func</span>

    <span class="k">return</span> <span class="n">decorator</span>


<div class="viewcode-block" id="lazyprop_w_sentinel">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.lazyprop_w_sentinel">[docs]</a>
<span class="k">class</span> <span class="nc">lazyprop_w_sentinel</span><span class="p">(</span><span class="n">lazyprop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor implementation of lazyprop (cached property).</span>
<span class="sd">    Inserts a `self.func.__name__ + &#39;__cache_active&#39;` attribute</span>

<span class="sd">    &gt;&gt;&gt; class Test:</span>
<span class="sd">    ...     def __init__(self, a):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     @lazyprop_w_sentinel</span>
<span class="sd">    ...     def len(self):</span>
<span class="sd">    ...         print(&#39;generating &quot;len&quot;&#39;)</span>
<span class="sd">    ...         return len(self.a)</span>
<span class="sd">    &gt;&gt;&gt; t = Test([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; lazyprop_w_sentinel.cache_is_active(t, &#39;len&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__  # let&#39;s look under the hood</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; lazyprop_w_sentinel.cache_is_active(t, &#39;len&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; t.len  # notice there&#39;s no &#39;generating &quot;len&quot;&#39; print this time!</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__  # let&#39;s look under the hood</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4], &#39;len&#39;: 5, &#39;sentinel_of__len&#39;: True}</span>
<span class="sd">    &gt;&gt;&gt; # But careful when using lazyprop that no one will change the value of a without deleting the property first</span>
<span class="sd">    &gt;&gt;&gt; t.a = [0, 1, 2]  # if we change a...</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... we still get the old cached value of len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; del t.len  # if we delete the len prop</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... then len being recomputed again</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sentinel_prefix</span> <span class="o">=</span> <span class="s2">&quot;sentinel_of__&quot;</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel_prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">)</span>  <span class="c1"># my hack</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">cache_is_active</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">sentinel_prefix</span> <span class="o">+</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>



<span class="k">class</span> <span class="nc">Struct</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_val_dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MutableStruct</span><span class="p">(</span><span class="n">Struct</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_val_dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2"> already exists. Delete it if you want to reuse it!&quot;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<div class="viewcode-block" id="max_common_prefix">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.max_common_prefix">[docs]</a>
<span class="k">def</span> <span class="nf">max_common_prefix</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of strings (or other sliceable seq), returns the longest common prefix</span>

<span class="sd">    :param a: list-like of strings</span>
<span class="sd">    :return: the smallest common prefix of all strings in a</span>

<span class="sd">    &gt;&gt;&gt; max_common_prefix([&#39;absolutely&#39;, &#39;abc&#39;, &#39;abba&#39;])</span>
<span class="sd">    &#39;ab&#39;</span>
<span class="sd">    &gt;&gt;&gt; max_common_prefix([&#39;absolutely&#39;, &#39;not&#39;, &#39;abc&#39;, &#39;abba&#39;])</span>
<span class="sd">    &#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt; max_common_prefix([[3,2,1], [3,2,0]])</span>
<span class="sd">    [3, 2]</span>
<span class="sd">    &gt;&gt;&gt; max_common_prefix([[3,2,1], [3,2,0], [1,2,3]])</span>
<span class="sd">    []</span>

<span class="sd">    If the input is empty, will return default (which defaults to &#39;&#39;).</span>

<span class="sd">    &gt;&gt;&gt; max_common_prefix([])</span>
<span class="sd">    &#39;&#39;</span>

<span class="sd">    If you want a different default, you can specify it with the default</span>
<span class="sd">    keyword argument.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; my_max_common_prefix = partial(max_common_prefix, default=[])</span>
<span class="sd">    &gt;&gt;&gt; my_max_common_prefix([])</span>
<span class="sd">    []</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="c1"># Note: Try to optimize by using a min_max function to give me both in one pass.</span>
    <span class="c1"># The current version is still faster</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># lexicographically minimal</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># lexicographically maximal</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s1</span></div>



<span class="k">class</span> <span class="nc">SimpleProperty</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">d</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">d</span>


<span class="k">class</span> <span class="nc">DelegatedAttribute</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delegate_name</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span> <span class="o">=</span> <span class="n">attr_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delegate_name</span> <span class="o">=</span> <span class="n">delegate_name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return instance.delegate.attr</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># instance.delegate.attr = value</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delegate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delegate_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># def __call__(self, instance, *args, **kwargs):</span>
    <span class="c1">#     return self.delegate(instance)(*args, **kwargs)</span>


<span class="k">def</span> <span class="nf">delegate_as</span><span class="p">(</span><span class="n">delegate_cls</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s2">&quot;delegate&quot;</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(),</span> <span class="n">exclude</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t manage to make this work fully&quot;</span><span class="p">)</span>
    <span class="c1"># turn include and ignore into sets, if they aren&#39;t already</span>
    <span class="n">include</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">include</span><span class="p">)</span>
    <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
    <span class="n">delegate_attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">delegate_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="n">include</span> <span class="o">|</span> <span class="n">delegate_attrs</span> <span class="o">-</span> <span class="n">exclude</span>

    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># create property for storing the delegate</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="nb">property</span><span class="p">())</span>
        <span class="c1"># don&#39;t bother adding attributes that the class already has</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">attributes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># set all the attributes</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">DelegatedAttribute</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">return</span> <span class="n">inner</span>


<span class="k">class</span> <span class="nc">HashableMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ImmutableMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;object is immutable&quot;</span><span class="p">)</span>

    <span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">clear</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">update</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">setdefault</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">popitem</span> <span class="o">=</span> <span class="n">_immutable</span>


<span class="c1"># TODO: Lint still considers instances of imdict to be mutable.</span>
<span class="c1">#  Probably because it still sees the mutator methods in the class definition.</span>
<span class="c1">#  Maybe I should just remove them from the class definition?</span>
<span class="c1"># TODO: Generalize to a function that makes any class immutable.</span>
<div class="viewcode-block" id="imdict">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.imdict">[docs]</a>
<span class="k">class</span> <span class="nc">imdict</span><span class="p">(</span><span class="n">ImmutableMixin</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">HashableMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A frozen hashable dict&quot;&quot;&quot;</span></div>



<span class="k">def</span> <span class="nf">move_files_of_folder_to_trash</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
    <span class="n">trash_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;HOME&quot;</span><span class="p">),</span> <span class="s2">&quot;.Trash&quot;</span>
    <span class="p">)</span>  <span class="c1"># works with mac (perhaps linux too?)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">trash_dir</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trash_dir</span><span class="si">}</span><span class="s2"> directory not found&quot;</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">trash_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Moving to trash: </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundErrorNiceMessage</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">It seems you don&#39;t have required `</span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">` package for this Store.</span>
<span class="s2">Try installing it by running:</span>

<span class="s2">    pip install </span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span>
<span class="s2">    </span>
<span class="s2">in your terminal.</span>
<span class="s2">For more information: https://pypi.org/project/</span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span>
<span class="s2">            &quot;&quot;&quot;</span>
                <span class="p">)</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundWarning</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;It seems you don&#39;t have a required package.&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1">#             if exc_val is not None and getattr(exc_val, &#39;name&#39;, None) is not None:</span>
            <span class="c1">#                 warn(f&quot;&quot;&quot;</span>
            <span class="c1"># It seems you don&#39;t have required `{exc_val.name}` package for this Store.</span>
            <span class="c1"># This is just a warning: The process goes on...</span>
            <span class="c1"># (But, hey, if you really need that package, try installing it by running:</span>
            <span class="c1">#</span>
            <span class="c1">#     pip install {exc_val.name}</span>
            <span class="c1">#</span>
            <span class="c1"># in your terminal.</span>
            <span class="c1"># For more information: https://pypi.org/project/{exc_val.name}, or google around...</span>
            <span class="c1">#                 &quot;&quot;&quot;)</span>
            <span class="c1">#             else:</span>
            <span class="c1">#                 print(&quot;It seems you don&#39;t have a required package&quot;)</span>
            <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundIgnore</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="num_of_required_args">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.num_of_required_args">[docs]</a>
<span class="k">def</span> <span class="nf">num_of_required_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number or REQUIRED arguments of a function.</span>

<span class="sd">    Contrast the behavior below with that of ``num_of_args``, which counts all</span>
<span class="sd">    parameters, including the variadics and defaulted ones.</span>

<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, b, c: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, b, c=3: None)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, *args, b, c=1, d=2, **kwargs: None)</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var_param_kinds</span> <span class="o">=</span> <span class="p">{</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="mi">1</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="num_of_args">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.num_of_args">[docs]</a>
<span class="k">def</span> <span class="nf">num_of_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of arguments (parameters) of the function.</span>

<span class="sd">    Contrast the behavior below with that of ``num_of_required_args``.</span>

<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, b, c: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, b, c=3: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, *args, b, c=1, d=2, **kwargs: None)</span>
<span class="sd">    6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">single_nest_in_dict</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">nest_in_dict</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">)}</span>


<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">KT</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="n">Buffer</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">]</span>
<span class="n">FileWriter</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">VT</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>
<span class="n">Writer</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">VT</span><span class="p">,</span> <span class="n">KT</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">KT</span><span class="p">,</span> <span class="n">VT</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_call_writer</span><span class="p">(</span>
    <span class="n">writer</span><span class="p">:</span> <span class="n">Writer</span><span class="p">,</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">VT</span><span class="p">,</span>
    <span class="n">destination</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">],</span>
    <span class="n">obj_arg_position_in_writer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to handle writing to the buffer based on obj_arg_position_in_writer.</span>

<span class="sd">    :param writer: A function that writes an object to a file-like object.</span>
<span class="sd">    :param obj: The object to write.</span>
<span class="sd">    :param destination: The key (e.g. filepath) or file-like object.</span>
<span class="sd">    :param obj_arg_position_in_writer: Position of the object argument in writer function (0 or 1).</span>

<span class="sd">    :raises ValueError: If obj_arg_position_in_writer is not 0 or 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj_arg_position_in_writer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">writer</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">obj_arg_position_in_writer</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">writer</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;obj_arg_position_in_writer must be 0 or 1&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="written_bytes">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.written_bytes">[docs]</a>
<span class="k">def</span> <span class="nf">written_bytes</span><span class="p">(</span>
    <span class="n">file_writer</span><span class="p">:</span> <span class="n">FileWriter</span><span class="p">,</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">VT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">obj_arg_position_in_writer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">io_buffer_cls</span><span class="p">:</span> <span class="n">Buffer</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a file writing function that expects an object and a file-like object,</span>
<span class="sd">    and returns a function that instead of writing to a file, returns the bytes that</span>
<span class="sd">    would have been written.</span>

<span class="sd">    Note: If obj is not given, write_bytes will return a &quot;bytes writer&quot; function that</span>
<span class="sd">    takes obj as the first argument, and uses the file_writer to write the bytes.</span>

<span class="sd">    :param file_writer: A function that writes an object to a file-like object.</span>
<span class="sd">    :param obj: The object to write.</span>
<span class="sd">    :return: The bytes that would have been written to a file.</span>

<span class="sd">    Use case: When you have a function that writes to files, and you want to get an</span>
<span class="sd">    equivalent function but that gives you what bytes or string WOULD have been written</span>
<span class="sd">    to a file, so you can better reuse (to write elsewhere, for example, or because</span>
<span class="sd">    you need to pipe those bytes to another function).</span>

<span class="sd">    Example usage: Yes, we have json.dumps to get the JSON string, but what if</span>
<span class="sd">    (like is often the case) you just have a function that writes to a file-like object,</span>
<span class="sd">    like the `json.dump(obj, fp)` function? You can use `written_bytes` to get a</span>
<span class="sd">    function that will act as `json.dumps` like so:</span>

<span class="sd">    &gt;&gt;&gt; import json</span>
<span class="sd">    &gt;&gt;&gt; get_json_bytes = written_bytes(json.dump, io_buffer_cls=io.StringIO)</span>
<span class="sd">    &gt;&gt;&gt; get_json_bytes({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">    &#39;{&quot;a&quot;: 1, &quot;b&quot;: 2}&#39;</span>

<span class="sd">    Here&#39;s another example with pandas DataFrame.to_parquet:</span>

<span class="sd">    &gt;&gt;&gt; # import pandas as pd</span>

<span class="sd">    df = pd.DataFrame({</span>
<span class="sd">        &#39;column1&#39;: [1, 2, 3],</span>
<span class="sd">        &#39;column2&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
<span class="sd">    })</span>

<span class="sd">    # Get a function that converts DataFrame to Parquet bytes</span>
<span class="sd">    df_to_parquet_bytes = written_bytes(pd.DataFrame.to_parquet)</span>

<span class="sd">    # Get the bytes of the DataFrame in Parquet format</span>
<span class="sd">    parquet_bytes = df_to_parquet_bytes(df)</span>
<span class="sd">    all(pd.read_parquet(io.BytesIO(parquet_bytes)) == df)</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">written_bytes</span><span class="p">,</span>
            <span class="n">file_writer</span><span class="p">,</span>
            <span class="n">obj_arg_position_in_writer</span><span class="o">=</span><span class="n">obj_arg_position_in_writer</span><span class="p">,</span>
            <span class="n">io_buffer_cls</span><span class="o">=</span><span class="n">io_buffer_cls</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Create a BytesIO object to act as an in-memory file</span>
    <span class="n">buffer</span> <span class="o">=</span> <span class="n">io_buffer_cls</span><span class="p">()</span>

    <span class="c1"># Use the provided file_writer function to write to the buffer</span>
    <span class="n">_call_writer</span><span class="p">(</span><span class="n">file_writer</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">obj_arg_position_in_writer</span><span class="p">)</span>

    <span class="c1"># Retrieve the bytes from the buffer</span>
    <span class="n">buffer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buffer</span><span class="o">.</span><span class="n">read</span><span class="p">()</span></div>



<span class="k">def</span> <span class="nf">write_to_file</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">VT</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">KT</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<div class="viewcode-block" id="written_key">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.written_key">[docs]</a>
<span class="k">def</span> <span class="nf">written_key</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">VT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">writer</span><span class="p">:</span> <span class="n">Writer</span> <span class="o">=</span> <span class="n">write_to_file</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">KT</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obj_arg_position_in_writer</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Writes an object to a key and returns the key.</span>
<span class="sd">    If key is not given, a temporary file is created and its path is returned.</span>

<span class="sd">    :param obj: The object to write.</span>
<span class="sd">    :param writer: A function that writes an object to a file.</span>
<span class="sd">    :param key: The key (by default, filepath) to write to.</span>
<span class="sd">        If None, a temporary file is created.</span>
<span class="sd">        If a string with a &#39;*&#39;, the &#39;*&#39; is replaced with a unique temporary filename.</span>
<span class="sd">    :param obj_arg_position_in_writer: Position of the object argument in writer function (0 or 1).</span>

<span class="sd">    :return: The file path where the object was written.</span>

<span class="sd">    Example usage:</span>

<span class="sd">    Let&#39;s make a store and a writer for that store.</span>

<span class="sd">    &gt;&gt;&gt; store = dict()</span>
<span class="sd">    &gt;&gt;&gt; writer = writer=lambda obj, key: store.__setitem__(key, obj)</span>

<span class="sd">    Note the order a writer expects is (obj, key), or we&#39;d just be able to use</span>
<span class="sd">    `store.__setitem__` as our writer.</span>

<span class="sd">    If we specify a key, the object will be written to that key in the store</span>
<span class="sd">    and the key is output.</span>

<span class="sd">    &gt;&gt;&gt; written_key(42, writer=writer, key=&#39;my_key&#39;)</span>
<span class="sd">    &#39;my_key&#39;</span>
<span class="sd">    &gt;&gt;&gt; store</span>
<span class="sd">    {&#39;my_key&#39;: 42}</span>

<span class="sd">    Often, you&#39;ll want to fix your writer (and possibly your key).</span>
<span class="sd">    You can do so with `functools.partial`, but for convenience, you can also</span>
<span class="sd">    just specify a writer, without an input object, and get a function that</span>
<span class="sd">    will write an object to a key.</span>

<span class="sd">    &gt;&gt;&gt; write_to_store = written_key(writer=writer, key=&#39;another_key&#39;)</span>
<span class="sd">    &gt;&gt;&gt; write_to_store(99)</span>
<span class="sd">    &#39;another_key&#39;</span>
<span class="sd">    &gt;&gt;&gt; store</span>
<span class="sd">    {&#39;my_key&#39;: 42, &#39;another_key&#39;: 99}</span>

<span class="sd">    If you don&#39;t specify a key, a temporary file is created and the key is output.</span>

<span class="sd">    &gt;&gt;&gt; write_to_store = written_key(writer=writer)</span>
<span class="sd">    &gt;&gt;&gt; key = write_to_store(43)</span>
<span class="sd">    &gt;&gt;&gt; key  # doctest: +SKIP</span>
<span class="sd">    &#39;/var/folders/mc/c070wfh51kxd9lft8dl74q1r0000gn/T/tmp8yaczd8b&#39;</span>
<span class="sd">    &gt;&gt;&gt; store[key]</span>
<span class="sd">    43</span>

<span class="sd">    If the key you specify is a string with a &#39;*&#39;, the &#39;*&#39; is replaced with a</span>
<span class="sd">    unique temporary filename, or the full path of the temporary file if the *</span>
<span class="sd">    is at the start.</span>

<span class="sd">    &gt;&gt;&gt; write_to_store = written_key(writer=writer, key=&#39;*.ext&#39;)</span>
<span class="sd">    &gt;&gt;&gt; key = write_to_store(44)</span>
<span class="sd">    &gt;&gt;&gt; key  # doctest: +ELLIPSIS</span>
<span class="sd">    &#39;....ext&#39;</span>
<span class="sd">    &gt;&gt;&gt; store[key]</span>
<span class="sd">    44</span>

<span class="sd">    One useful use case is when you want to pipe the output of one function into</span>
<span class="sd">    another function that expects a file path.</span>
<span class="sd">    What you need to do then is just pipe your written_key function into that</span>
<span class="sd">    function that expects to work with a file path, and it&#39;ll be like piping the</span>
<span class="sd">    value of your input object into that function (just via a temp file).</span>

<span class="sd">    &gt;&gt;&gt; from dol.util import Pipe</span>
<span class="sd">    &gt;&gt;&gt; store.clear()</span>
<span class="sd">    &gt;&gt;&gt; key_func = lambda key: store.get(key) * 10</span>
<span class="sd">    &gt;&gt;&gt; pipe_obj_to_reader = Pipe(written_key(writer=writer), key_func)</span>
<span class="sd">    &gt;&gt;&gt; pipe_obj_to_reader(45)</span>
<span class="sd">    450</span>
<span class="sd">    &gt;&gt;&gt; store  # doctest: +ELLIPSIS</span>
<span class="sd">    {...: 45}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">written_key</span><span class="p">,</span>
            <span class="n">writer</span><span class="o">=</span><span class="n">writer</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
            <span class="n">obj_arg_position_in_writer</span><span class="o">=</span><span class="n">obj_arg_position_in_writer</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Create a temporary file</span>
        <span class="n">fd</span><span class="p">,</span> <span class="n">temp_filepath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">()</span>
        <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">temp_filepath</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="s2">&quot;*&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">temp_filepath</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mktemp</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
            <span class="c1"># Replace * of key with a unique temporary filename</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">temp_filepath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># separate directory and filename</span>
            <span class="n">dir_name</span><span class="p">,</span> <span class="n">base_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">temp_filepath</span><span class="p">)</span>
            <span class="c1"># Replace * of key with a unique temporary filename</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">base_name</span><span class="p">)</span>

    <span class="c1"># Write the object to the specified filepath</span>
    <span class="n">_call_writer</span><span class="p">(</span><span class="n">writer</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj_arg_position_in_writer</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">key</span></div>



<span class="c1"># TODO: This function should be symmetric, and if so, the code should use recursion</span>
<div class="viewcode-block" id="invertible_maps">
<a class="viewcode-back" href="../../module_docs/dol/util.html#dol.util.invertible_maps">[docs]</a>
<span class="k">def</span> <span class="nf">invertible_maps</span><span class="p">(</span>
    <span class="n">mapping</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">inv_mapping</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Mapping</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns two maps that are inverse of each other.</span>
<span class="sd">    Raises an AssertionError iif both maps are None, or if the maps are not inverse of</span>
<span class="sd">    each other.</span>

<span class="sd">    Get a pair of invertible maps</span>

<span class="sd">    &gt;&gt;&gt; invertible_maps({1: 11, 2: 22})</span>
<span class="sd">    ({1: 11, 2: 22}, {11: 1, 22: 2})</span>
<span class="sd">    &gt;&gt;&gt; invertible_maps(None, {11: 1, 22: 2})</span>
<span class="sd">    ({1: 11, 2: 22}, {11: 1, 22: 2})</span>

<span class="sd">    You can specify one argument as an iterable (of keys for the mapping) and the </span>
<span class="sd">    other as a function (to be applied to the keys to get the inverse mapping).</span>
<span class="sd">    The function acts similarly to a `Mapping.__getitem__`, transforming each key to </span>
<span class="sd">    its associated value. The iterable defines the keys for the mapping, while the </span>
<span class="sd">    function is applied to each key to produce the values.</span>

<span class="sd">    &gt;&gt;&gt; invertible_maps([1,2,3], lambda x: x * 10)</span>
<span class="sd">    ({10: 1, 20: 2, 30: 3}, {1: 10, 2: 20, 3: 30})</span>
<span class="sd">    &gt;&gt;&gt; invertible_maps(lambda x: x * 10, [1,2,3])</span>
<span class="sd">    ({1: 10, 2: 20, 3: 30}, {10: 1, 20: 2, 30: 3})</span>

<span class="sd">    If two maps are given and invertible, you just get them back</span>

<span class="sd">    &gt;&gt;&gt; invertible_maps({1: 11, 2: 22}, {11: 1, 22: 2})</span>
<span class="sd">    ({1: 11, 2: 22}, {11: 1, 22: 2})</span>

<span class="sd">    Or if they&#39;re not invertible</span>

<span class="sd">    &gt;&gt;&gt; invertible_maps({1: 11, 2: 22}, {11: 1, 22: &#39;ha, not what you expected!&#39;})</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: mapping and inv_mapping are not inverse of each other!</span>

<span class="sd">    &gt;&gt;&gt; invertible_maps(None, None)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    ValueError: You need to specify one or both maps</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">inv_mapping</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You need to specify one or both maps&#39;</span><span class="p">)</span>
    
    <span class="c1"># Take care of the case where one is a function and the other is a list</span>
    <span class="c1"># Here, we apply the function to the list items to get the mappings</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inv_mapping</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If one argument is callable, the other one must be an iterable of keys&quot;</span>
        <span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">mapping</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="p">}</span>
        <span class="n">inv_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">inv_mapping</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;If one argument is callable, the other one must be an iterable of keys&quot;</span>
        <span class="p">)</span>
        <span class="n">inv_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">inv_mapping</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">}</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    
    <span class="k">if</span> <span class="n">inv_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">)</span>
        <span class="n">inv_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_mapping</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">mapping</span>
        <span class="p">),</span> <span class="s1">&#39;The values of mapping are not unique, so the mapping is not invertible&#39;</span>
    <span class="k">elif</span> <span class="n">mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">inv_mapping</span><span class="p">,</span> <span class="s1">&#39;items&#39;</span><span class="p">)</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">inv_mapping</span>
        <span class="p">),</span> <span class="s1">&#39;The values of inv_mapping are not unique, so the mapping is not invertible&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_mapping</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">mapping</span> <span class="o">==</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="p">),</span> <span class="s1">&#39;mapping and inv_mapping are not inverse of each other!&#39;</span>

    <span class="k">return</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">inv_mapping</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>