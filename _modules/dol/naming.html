

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.naming &mdash; dol 0.2.90 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=1d2c14bc"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/kv_codecs.html">dol.kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/new_store_wrap.html">dol.scrap.new_store_wrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_appendable.html">dol.tests.test_appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_dol_tools.html">dol.tests.test_dol_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_filesys.html">dol.tests.test_filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_kv_codecs.html">dol.tests.test_kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_paths.html">dol.tests.test_paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_trans.html">dol.tests.test_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/utils_for_tests.html">dol.tests.utils_for_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dol.html">dol</a></li>
      <li class="breadcrumb-item active">dol.naming</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.naming</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module is about generating, validating, and operating on (parametrized) fields (i.e. stings, e.g. paths).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">dol.signatures</span> <span class="kn">import</span> <span class="n">set_signature_of_func</span>
<span class="kn">from</span> <span class="nn">dol.errors</span> <span class="kn">import</span> <span class="n">KeyValidationError</span><span class="p">,</span> <span class="n">_assert_condition</span>

<span class="n">assert_condition</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_assert_condition</span><span class="p">,</span> <span class="n">err_cls</span><span class="o">=</span><span class="n">KeyValidationError</span><span class="p">)</span>

<span class="n">path_sep</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span>

<span class="n">base_validation_funs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;be a&quot;</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">,</span>
    <span class="s2">&quot;be in&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">:</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">check_val</span><span class="p">,</span>
    <span class="s2">&quot;be at least&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">:</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="n">check_val</span><span class="p">,</span>
    <span class="s2">&quot;be more than&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">:</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">check_val</span><span class="p">,</span>
    <span class="s2">&quot;be no more than&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">:</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">check_val</span><span class="p">,</span>
    <span class="s2">&quot;be less than&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">:</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">check_val</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">dflt_validation_funs</span> <span class="o">=</span> <span class="n">base_validation_funs</span>
<span class="n">dflt_all_kwargs_should_be_in_validation_dict</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">dflt_ignore_misunderstood_validation_instructions</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">dflt_arg_pattern</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;.+&quot;</span>

<span class="n">day_format</span> <span class="o">=</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span>
<span class="n">day_format_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d</span><span class="si">{4}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">-\d</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">capture_template</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{format}</span><span class="s2">)&quot;</span>
<span class="n">named_capture_template</span> <span class="o">=</span> <span class="s2">&quot;(?P&lt;</span><span class="si">{name}</span><span class="s2">&gt;</span><span class="si">{format}</span><span class="s2">)&quot;</span>

<span class="n">fields_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;(?&lt;={)[^}]+(?=})&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="validate_kwargs">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.validate_kwargs">[docs]</a>
<span class="k">def</span> <span class="nf">validate_kwargs</span><span class="p">(</span>
    <span class="n">kwargs_to_validate</span><span class="p">,</span>
    <span class="n">validation_dict</span><span class="p">,</span>
    <span class="n">validation_funs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">all_kwargs_should_be_in_validation_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_misunderstood_validation_instructions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to validate a dict. It&#39;s main use is to validate function arguments (expressing the validation checks</span>
<span class="sd">    in validation_dict) by doing validate_kwargs(locals()), usually in the beginning of the function</span>
<span class="sd">    (to avoid having more accumulated variables than we need in locals())</span>
<span class="sd">    :param kwargs_to_validate: as the name implies...</span>
<span class="sd">    :param validation_dict: A dict specifying what to validate. Keys are usually name of variables (when feeding</span>
<span class="sd">        locals()) and values are dicts, themselves specifying check:check_val pairs where check is a string that</span>
<span class="sd">        points to a function (see validation_funs argument) and check_val is an object that the kwargs_to_validate</span>
<span class="sd">        value will be checked against.</span>
<span class="sd">    :param validation_funs: A dict of check:check_function(val, check_val) where check_function is a function returning</span>
<span class="sd">        True if val is valid (with respect to check_val).</span>
<span class="sd">    :param all_kwargs_should_be_in_validation_dict: If True, will raise an error if kwargs_to_validate contains</span>
<span class="sd">        keys that are not in validation_dict.</span>
<span class="sd">    :param ignore_misunderstood_validation_instructions: If True, will raise an error if validation_dict contains</span>
<span class="sd">        a key that is not in validation_funs (safer, since if you mistype a key in validation_dict, the function will</span>
<span class="sd">        tell you so!</span>
<span class="sd">    :return: True if all the validations passed.</span>

<span class="sd">    &gt;&gt;&gt; validation_dict = {</span>
<span class="sd">    ...     &#39;system&#39;: {</span>
<span class="sd">    ...         &#39;be in&#39;: {&#39;darwin&#39;, &#39;linux&#39;}</span>
<span class="sd">    ...     },</span>
<span class="sd">    ...     &#39;fv_version&#39;: {</span>
<span class="sd">    ...         &#39;be a&#39;: int,</span>
<span class="sd">    ...         &#39;be at least&#39;: 5</span>
<span class="sd">    ...     }</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; validate_kwargs({&#39;system&#39;: &#39;darwin&#39;}, validation_dict)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     validate_kwargs({&#39;system&#39;: &#39;windows&#39;}, validation_dict)</span>
<span class="sd">    ... except AssertionError as e:</span>
<span class="sd">    ...     assert str(e).startswith(&#39;system must be in&#39;)  # omitting the set because inconsistent order</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     validate_kwargs({&#39;fv_version&#39;: 9.9}, validation_dict)</span>
<span class="sd">    ... except AssertionError as e:</span>
<span class="sd">    ...     print(e)</span>
<span class="sd">    fv_version must be a &lt;class &#39;int&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     validate_kwargs({&#39;fv_version&#39;: 4}, validation_dict)</span>
<span class="sd">    ... except AssertionError as e:</span>
<span class="sd">    ...     print(e)</span>
<span class="sd">    fv_version must be at least 5</span>
<span class="sd">    &gt;&gt;&gt; validate_kwargs({&#39;fv_version&#39;: 6}, validation_dict)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validation_funs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">base_validation_funs</span> <span class="ow">or</span> <span class="p">{},</span> <span class="o">**</span><span class="p">(</span><span class="n">validation_funs</span> <span class="ow">or</span> <span class="p">{}))</span>
    <span class="k">for</span> <span class="p">(</span>
        <span class="n">var</span><span class="p">,</span>
        <span class="n">val</span><span class="p">,</span>
    <span class="p">)</span> <span class="ow">in</span> <span class="n">kwargs_to_validate</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># for every (var, val) pair of kwargs</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">validation_dict</span><span class="p">:</span>  <span class="c1"># if var is in the validation_dict</span>
            <span class="k">for</span> <span class="n">check</span><span class="p">,</span> <span class="n">check_val</span> <span class="ow">in</span> <span class="n">validation_dict</span><span class="p">[</span>
                <span class="n">var</span>
            <span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>  <span class="c1"># for every (key, val) of this dict</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">check</span> <span class="ow">in</span> <span class="n">base_validation_funs</span>
                <span class="p">):</span>  <span class="c1"># if you have a validation check for it</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">validation_funs</span><span class="p">[</span><span class="n">check</span><span class="p">](</span><span class="n">val</span><span class="p">,</span> <span class="n">check_val</span><span class="p">):</span>  <span class="c1"># check it&#39;s valid</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> must </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">check</span><span class="p">,</span> <span class="n">check_val</span><span class="p">)</span>
                        <span class="p">)</span>  <span class="c1"># and raise an error if not</span>
                <span class="k">elif</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="n">ignore_misunderstood_validation_instructions</span>
                <span class="p">):</span>  <span class="c1"># should ignore if check not understood?</span>
                    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                        <span class="s2">&quot;I don&#39;t know what to do with the validation check &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">check</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">all_kwargs_should_be_in_validation_dict</span>
        <span class="p">):</span>  <span class="c1"># should all variables have checks?</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> wasn&#39;t in the validation_dict&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="namedtuple_to_dict">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.namedtuple_to_dict">[docs]</a>
<span class="k">def</span> <span class="nf">namedtuple_to_dict</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; from collections import namedtuple</span>
<span class="sd">    &gt;&gt;&gt; NT = namedtuple(&#39;MyTuple&#39;, (&#39;foo&#39;, &#39;hello&#39;))</span>
<span class="sd">    &gt;&gt;&gt; nt = NT(1, 42)</span>
<span class="sd">    &gt;&gt;&gt; nt</span>
<span class="sd">    MyTuple(foo=1, hello=42)</span>
<span class="sd">    &gt;&gt;&gt; d = namedtuple_to_dict(nt)</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo&#39;: 1, &#39;hello&#39;: 42}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">nt</span><span class="o">.</span><span class="n">_fields</span><span class="p">}</span></div>



<div class="viewcode-block" id="dict_to_namedtuple">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.dict_to_namedtuple">[docs]</a>
<span class="k">def</span> <span class="nf">dict_to_namedtuple</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">namedtuple_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; from collections import namedtuple</span>
<span class="sd">    &gt;&gt;&gt; NT = namedtuple(&#39;MyTuple&#39;, (&#39;foo&#39;, &#39;hello&#39;))</span>
<span class="sd">    &gt;&gt;&gt; nt = NT(1, 42)</span>
<span class="sd">    &gt;&gt;&gt; nt</span>
<span class="sd">    MyTuple(foo=1, hello=42)</span>
<span class="sd">    &gt;&gt;&gt; d = namedtuple_to_dict(nt)</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo&#39;: 1, &#39;hello&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; dict_to_namedtuple(d)</span>
<span class="sd">    NamedTupleFromDict(foo=1, hello=42)</span>
<span class="sd">    &gt;&gt;&gt; dict_to_namedtuple(d, nt)</span>
<span class="sd">    MyTuple(foo=1, hello=42)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">namedtuple_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">namedtuple_obj</span> <span class="o">=</span> <span class="s2">&quot;NamedTupleFromDict&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">namedtuple_obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">namedtuple_name</span> <span class="o">=</span> <span class="n">namedtuple_obj</span>
        <span class="n">namedtuple_cls</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="n">namedtuple_name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">namedtuple_obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">namedtuple_obj</span><span class="p">,</span> <span class="s2">&quot;_fields&quot;</span><span class="p">):</span>
        <span class="n">namedtuple_cls</span> <span class="o">=</span> <span class="n">namedtuple_obj</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">namedtuple_obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">namedtuple_cls</span> <span class="o">=</span> <span class="n">namedtuple_obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Can&#39;t resolve the nametuple class specification: </span><span class="si">{</span><span class="n">namedtuple_obj</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">namedtuple_cls</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_fields_of_namedtuple">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.update_fields_of_namedtuple">[docs]</a>
<span class="k">def</span> <span class="nf">update_fields_of_namedtuple</span><span class="p">(</span>
    <span class="n">nt</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name_of_output_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_fields</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace fields of namedtuple</span>

<span class="sd">    &gt;&gt;&gt; from collections import namedtuple</span>
<span class="sd">    &gt;&gt;&gt; NT = namedtuple(&#39;NT&#39;, (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;))</span>
<span class="sd">    &gt;&gt;&gt; nt = NT(1,2,3)</span>
<span class="sd">    &gt;&gt;&gt; nt</span>
<span class="sd">    NT(a=1, b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; update_fields_of_namedtuple(nt, c=3000)  # replacing a single field</span>
<span class="sd">    NT(a=1, b=2, c=3000)</span>
<span class="sd">    &gt;&gt;&gt; update_fields_of_namedtuple(nt, c=3000, a=1000)  # replacing two fields</span>
<span class="sd">    NT(a=1000, b=2, c=3000)</span>
<span class="sd">    &gt;&gt;&gt; update_fields_of_namedtuple(nt, a=1000, c=3000)  # see that the original order doesn&#39;t change</span>
<span class="sd">    NT(a=1000, b=2, c=3000)</span>
<span class="sd">    &gt;&gt;&gt; update_fields_of_namedtuple(nt, b=2000, d=&#39;hello&#39;)  # replacing one field and adding a new one</span>
<span class="sd">    UpdatedNT(a=1, b=2000, c=3, d=&#39;hello&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # Now let&#39;s try controlling the name of the output type, remove fields, and add new ones</span>
<span class="sd">    &gt;&gt;&gt; update_fields_of_namedtuple(nt, name_of_output_type=&#39;NewGuy&#39;, remove_fields=(&#39;a&#39;, &#39;c&#39;), hello=&#39;world&#39;)</span>
<span class="sd">    NewGuy(b=2, hello=&#39;world&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_type_can_be_the_same_as_input_type</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">remove_fields</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">_fields</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">namedtuple_to_dict</span><span class="p">(</span><span class="n">nt</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">remove_fields</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">output_type_can_be_the_same_as_input_type</span> <span class="ow">and</span> <span class="n">name_of_output_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dict_to_namedtuple</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">nt</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name_of_output_type</span> <span class="o">=</span> <span class="n">name_of_output_type</span> <span class="ow">or</span> <span class="sa">f</span><span class="s2">&quot;Updated</span><span class="si">{</span><span class="n">nt</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">dict_to_namedtuple</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">name_of_output_type</span><span class="p">)</span></div>



<span class="n">empty_field_p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="get_fields_from_template">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.get_fields_from_template">[docs]</a>
<span class="k">def</span> <span class="nf">get_fields_from_template</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get list from {item} items of template string</span>
<span class="sd">    :param template: a &quot;template&quot; string (a string with {item} items</span>
<span class="sd">    -- the kind that is used to mark token for str.format)</span>
<span class="sd">    :return: a list of the token items of the string, in the order they appear</span>

<span class="sd">    &gt;&gt;&gt; get_fields_from_template(&#39;this{is}an{example}of{a}template&#39;)</span>
<span class="sd">    [&#39;is&#39;, &#39;example&#39;, &#39;a&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Need to use the string module, and need to auto-name the fields instead of refusing unnamed</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">empty_field_p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span>
        <span class="n">template</span>
    <span class="p">),</span> <span class="s2">&quot;All fields must be named: That is, no empty </span><span class="si">{}</span><span class="s2"> allowed&quot;</span>
    <span class="k">return</span> <span class="n">fields_re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">template</span><span class="p">)</span></div>



<span class="c1"># until_slash = &quot;[^&quot; + path_sep + &quot;]+&quot;</span>
<span class="c1"># until_slash_capture = &#39;(&#39; + until_slash + &#39;)&#39;</span>


<span class="k">def</span> <span class="nf">mk_format_mapping_dict</span><span class="p">(</span><span class="n">format_dict</span><span class="p">,</span> <span class="n">required_keys</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">path_sep</span><span class="p">):</span>
    <span class="n">until_sep</span> <span class="o">=</span> <span class="s2">&quot;[^&quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]+&quot;</span>
    <span class="n">new_format_dict</span> <span class="o">=</span> <span class="n">format_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">required_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_format_dict</span><span class="p">:</span>
            <span class="n">new_format_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">until_sep</span>
    <span class="k">return</span> <span class="n">new_format_dict</span>


<span class="k">def</span> <span class="nf">mk_capture_patterns</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">):</span>
    <span class="n">new_mapping_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">new_v</span> <span class="o">=</span> <span class="n">capture_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="n">new_mapping_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v</span>
    <span class="k">return</span> <span class="n">new_mapping_dict</span>


<span class="k">def</span> <span class="nf">mk_named_capture_patterns</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">):</span>
    <span class="n">new_mapping_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">new_v</span> <span class="o">=</span> <span class="n">named_capture_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">v</span><span class="p">)</span>
        <span class="n">new_mapping_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v</span>
    <span class="k">return</span> <span class="n">new_mapping_dict</span>


<span class="k">def</span> <span class="nf">template_to_pattern</span><span class="p">(</span><span class="n">mapping_dict</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mapping_dict</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mapping_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">string</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]],</span>
            <span class="n">template</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">template</span>


<span class="k">def</span> <span class="nf">mk_extract_pattern</span><span class="p">(</span>
    <span class="n">template</span><span class="p">,</span> <span class="n">format_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">named_capture_patterns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="n">format_dict</span> <span class="o">=</span> <span class="n">format_dict</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">named_capture_patterns</span> <span class="o">=</span> <span class="n">named_capture_patterns</span> <span class="ow">or</span> <span class="n">mk_named_capture_patterns</span><span class="p">(</span>
        <span class="n">format_dict</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">mapping_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">format_dict</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">named_capture_patterns</span><span class="p">[</span><span class="n">name</span><span class="p">]})</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapping_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">mapping_dict</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">string</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]],</span>
            <span class="n">template</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>


<span class="c1"># TODO: Is dependent on path sep -- separate concern</span>
<div class="viewcode-block" id="mk_pattern_from_template_and_format_dict">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.mk_pattern_from_template_and_format_dict">[docs]</a>
<span class="k">def</span> <span class="nf">mk_pattern_from_template_and_format_dict</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="n">format_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">path_sep</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a compiled regex to match template</span>
<span class="sd">    Args:</span>
<span class="sd">        template: A format string</span>
<span class="sd">        format_dict: A dict whose keys are template fields and values are regex strings to capture them</span>
<span class="sd">    Returns: a compiled regex</span>

<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt; p = mk_pattern_from_template_and_format_dict(&#39;{here}/and/{there}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; if os.name == &#39;nt&#39;:  # for windows</span>
<span class="sd">    ...     assert p == re.compile(&#39;(?P&lt;here&gt;[^\\\\]+)/and/(?P&lt;there&gt;[^\\\\]+)&#39;)</span>
<span class="sd">    ... else:</span>
<span class="sd">    ...     assert p == re.compile(&#39;(?P&lt;here&gt;[^/]+)/and/(?P&lt;there&gt;[^/]+)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; p = mk_pattern_from_template_and_format_dict(&#39;{here}/and/{there}&#39;, {&#39;there&#39;: r&#39;\d+&#39;})</span>
<span class="sd">    &gt;&gt;&gt; if os.name == &#39;nt&#39;:  # for windows</span>
<span class="sd">    ...     assert p == re.compile(r&#39;(?P&lt;here&gt;[^\\\\]+)/and/(?P&lt;there&gt;\d+)&#39;)</span>
<span class="sd">    ... else:</span>
<span class="sd">    ...     assert p == re.compile(r&#39;(?P&lt;here&gt;[^/]+)/and/(?P&lt;there&gt;\d+)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; type(p)</span>
<span class="sd">    &lt;class &#39;re.Pattern&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; p.match(&#39;HERE/and/1234&#39;).groupdict()</span>
<span class="sd">    {&#39;here&#39;: &#39;HERE&#39;, &#39;there&#39;: &#39;1234&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">format_dict</span> <span class="o">=</span> <span class="n">format_dict</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="n">fields</span> <span class="o">=</span> <span class="n">get_fields_from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">format_dict</span> <span class="o">=</span> <span class="n">mk_format_mapping_dict</span><span class="p">(</span><span class="n">format_dict</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">named_capture_patterns</span> <span class="o">=</span> <span class="n">mk_named_capture_patterns</span><span class="p">(</span><span class="n">format_dict</span><span class="p">)</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">template_to_pattern</span><span class="p">(</span><span class="n">named_capture_patterns</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Got an error when attempting to re.compile(&#39;</span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s2">&#39;): &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span></div>



<span class="k">def</span> <span class="nf">mk_prefix_templates_dicts</span><span class="p">(</span><span class="n">template</span><span class="p">):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">get_fields_from_template</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
    <span class="n">prefix_template_dict_including_name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">none_and_fields</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">fields</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">none_and_fields</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">fields</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">prefix_template_dict_including_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">next_name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span>
                    <span class="mi">1</span> <span class="o">+</span> <span class="nb">next</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="k">if</span> <span class="n">_name</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="n">p</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">next_name</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>
            <span class="n">template_idx_of_next_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">prefix_template_dict_including_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span><span class="p">[</span>
                <span class="p">:</span><span class="n">template_idx_of_next_name</span>
            <span class="p">]</span>

    <span class="n">prefix_template_dict_excluding_name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fields</span><span class="p">):</span>
        <span class="n">prefix_template_dict_excluding_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">prefix_template_dict_including_name</span><span class="p">[</span>
            <span class="n">none_and_fields</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">]</span>
    <span class="n">prefix_template_dict_excluding_name</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">template</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">prefix_template_dict_including_name</span><span class="p">,</span>
        <span class="n">prefix_template_dict_excluding_name</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="mk_kwargs_trans">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.mk_kwargs_trans">[docs]</a>
<span class="k">def</span> <span class="nf">mk_kwargs_trans</span><span class="p">(</span><span class="o">**</span><span class="n">trans_func_for_key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a dict transformer from functions that depends solely on keys (of the dict to be transformed)</span>
<span class="sd">    Used to easily make process_kwargs and process_info_dict arguments for LinearNaming.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span><span class="nb">callable</span><span class="p">,</span> <span class="n">trans_func_for_key</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="p">),</span> <span class="s2">&quot;all argument values must be callable&quot;</span>

    <span class="k">def</span> <span class="nf">key_based_val_trans</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">trans_func_for_key</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_func_for_key</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">return</span> <span class="n">key_based_val_trans</span></div>



<span class="k">def</span> <span class="nf">_mk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a full name with given kwargs. All required name=val must be present (or infered by self.process_kwargs</span>
<span class="sd">    function.</span>
<span class="sd">    The required fields are in self.fields.</span>
<span class="sd">    Does NOT check for validity of the vals.</span>
<span class="sd">    :param kwargs: The name=val arguments needed to construct a valid name</span>
<span class="sd">    :return: an name</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You have too many arguments: (args, kwargs) is (</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You have too few arguments: (args, kwargs) is (</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">)},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># from dol.trans import add_wrapper_method</span>
<span class="c1">#</span>
<span class="c1"># # @add_wrapper_method</span>
<span class="k">class</span> <span class="nc">StrTupleDict</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">template</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">],</span>
        <span class="n">format_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">process_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">process_info_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">named_tuple_type_name</span><span class="o">=</span><span class="s2">&quot;NamedTuple&quot;</span><span class="p">,</span>
        <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">path_sep</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converting from and to strings, tuples, and dicts.</span>

<span class="sd">        Args:</span>
<span class="sd">            template: The string format template</span>
<span class="sd">            format_dict: A {field_name: field_value_format_regex, ...} dict</span>
<span class="sd">            process_kwargs: A function taking the field=value pairs and producing a dict of processed</span>
<span class="sd">                {field: value,...} dict (where both fields and values could have been processed.</span>
<span class="sd">                This is useful when we need to process (format, default, etc.) fields, or their values,</span>
<span class="sd">                according to the other fields of values in the collection.</span>
<span class="sd">                A specification of {field: function_to_process_this_value,...} wouldn&#39;t allow the full powers</span>
<span class="sd">                we are allowing here.</span>
<span class="sd">            process_info_dict: A sort of converse of format_dict.</span>
<span class="sd">                This is a {field_name: field_conversion_func, ...} dict that is used to convert info_dict values</span>
<span class="sd">                before returning them.</span>
<span class="sd">            name_separator: Used</span>

<span class="sd">        &gt;&gt;&gt; ln = StrTupleDict(&#39;/home/{user}/fav/{num}.txt&#39;,</span>
<span class="sd">        ...	                  format_dict={&#39;user&#39;: &#39;[^/]+&#39;, &#39;num&#39;: r&#39;\d+&#39;},</span>
<span class="sd">        ...	                  process_info_dict={&#39;num&#39;: int},</span>
<span class="sd">        ...                   sep=&#39;/&#39;</span>
<span class="sd">        ...	                 )</span>
<span class="sd">        &gt;&gt;&gt; ln.is_valid(&#39;/home/USER/fav/123.txt&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; ln.is_valid(&#39;/home/US/ER/fav/123.txt&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ln.is_valid(&#39;/home/US/ER/fav/not_a_number.txt&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; ln.mk(&#39;USER&#39;, num=123)  # making a string (with args or kwargs)</span>
<span class="sd">        &#39;/home/USER/fav/123.txt&#39;</span>
<span class="sd">        &gt;&gt;&gt; # Note: but ln.mk(&#39;USER&#39;, num=&#39;not_a_number&#39;) would fail because num is not valid</span>
<span class="sd">        &gt;&gt;&gt; ln.info_dict(&#39;/home/USER/fav/123.txt&#39;)  # note in the output, 123 is an int, not a string</span>
<span class="sd">        {&#39;user&#39;: &#39;USER&#39;, &#39;num&#39;: 123}</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Trying with template given as a tuple, and with different separator</span>
<span class="sd">        &gt;&gt;&gt; ln = StrTupleDict(template=(&#39;first&#39;, &#39;last&#39;, &#39;age&#39;),</span>
<span class="sd">        ...                   format_dict={&#39;age&#39;: r&#39;-*\d+&#39;},</span>
<span class="sd">        ...                   process_info_dict={&#39;age&#39;: int},</span>
<span class="sd">        ...                   sep=&#39;,&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ln.tuple_to_str((&#39;Thor&#39;, &quot;Odinson&quot;, 1500))</span>
<span class="sd">        &#39;Thor,Odinson,1500&#39;</span>
<span class="sd">        &gt;&gt;&gt; ln.str_to_dict(&#39;Loki,Laufeyson,1070&#39;)</span>
<span class="sd">        {&#39;first&#39;: &#39;Loki&#39;, &#39;last&#39;: &#39;Laufeyson&#39;, &#39;age&#39;: 1070}</span>
<span class="sd">        &gt;&gt;&gt; ln.str_to_tuple(&#39;Odin,Himself,-1&#39;)</span>
<span class="sd">        (&#39;Odin&#39;, &#39;Himself&#39;, -1)</span>
<span class="sd">        &gt;&gt;&gt; ln.tuple_to_dict((&#39;Odin&#39;, &#39;Himself&#39;, -1))</span>
<span class="sd">        {&#39;first&#39;: &#39;Odin&#39;, &#39;last&#39;: &#39;Himself&#39;, &#39;age&#39;: -1}</span>
<span class="sd">        &gt;&gt;&gt; ln.dict_to_tuple({&#39;first&#39;: &#39;Odin&#39;, &#39;last&#39;: &#39;Himself&#39;, &#39;age&#39;: -1})</span>
<span class="sd">        (&#39;Odin&#39;, &#39;Himself&#39;, -1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">format_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">format_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sep</span> <span class="o">=</span> <span class="n">sep</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">template</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="n">template</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">{{</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">template</span><span class="p">])</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="n">get_fields_from_template</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span>

        <span class="n">format_dict</span> <span class="o">=</span> <span class="n">mk_format_mapping_dict</span><span class="p">(</span><span class="n">format_dict</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep</span><span class="p">)</span>

        <span class="n">named_capture_patterns</span> <span class="o">=</span> <span class="n">mk_named_capture_patterns</span><span class="p">(</span><span class="n">format_dict</span><span class="p">)</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">template_to_pattern</span><span class="p">(</span><span class="n">named_capture_patterns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">+=</span> <span class="s2">&quot;$&quot;</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

        <span class="n">extract_pattern</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">extract_pattern</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mk_extract_pattern</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">,</span> <span class="n">format_dict</span><span class="p">,</span> <span class="n">named_capture_patterns</span><span class="p">,</span> <span class="n">name</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">process_info_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">_processor_for_kw</span> <span class="o">=</span> <span class="n">process_info_dict</span>

            <span class="k">def</span> <span class="nf">process_info_dict</span><span class="p">(</span><span class="o">**</span><span class="n">info_dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">_processor_for_kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)(</span><span class="n">v</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format_dict</span> <span class="o">=</span> <span class="n">format_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_capture_patterns</span> <span class="o">=</span> <span class="n">named_capture_patterns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extract_pattern</span> <span class="o">=</span> <span class="n">extract_pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span> <span class="o">=</span> <span class="n">process_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_info_dict</span> <span class="o">=</span> <span class="n">process_info_dict</span>

        <span class="k">def</span> <span class="nf">_mk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Make a full name with given kwargs. All required name=val must be present (or infered by self.process_kwargs</span>
<span class="sd">            function.</span>
<span class="sd">            The required fields are in self.fields.</span>
<span class="sd">            Does NOT check for validity of the vals.</span>
<span class="sd">            :param kwargs: The name=val arguments needed to construct a valid name</span>
<span class="sd">            :return: an name</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;You have too many arguments: (args, kwargs) is (</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;You have too few arguments: (args, kwargs) is (</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">)},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">set_signature_of_func</span><span class="p">(</span><span class="n">_mk</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;self&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mk</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">_mk</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">NamedTuple</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="n">named_tuple_type_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the name has the &quot;upload format&quot; (i.e. the kind of fields that are _ids of fv_mgc, and what</span>
<span class="sd">        name means in most of the iatis system.</span>
<span class="sd">        :param s: the string to check</span>
<span class="sd">        :return: True iff name has the upload format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">str_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dict with the arguments of an name (for example group, user, subuser, etc.)</span>
<span class="sd">        :param s:</span>
<span class="sd">        :return: a dict holding the argument fields and values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">info_dict</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_info_dict</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_info_dict</span><span class="p">(</span><span class="o">**</span><span class="n">info_dict</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">info_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid string format: </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">str_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">info_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">str_to_dict</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">str_to_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_to_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">str_to_dict</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">str_to_simple_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">str_to_tuple</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">simple_str_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ss</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tuple_to_str</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sep</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">super_dict_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like dict_to_str, but the input dict can have extra keys that are not used by dict_to_str&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">dict_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dict_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="n">assert_condition</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;len(d)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> but len(fields)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dict_to_namedtuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">NamedTuple</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tuple_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">assert_condition</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;len(d)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="si">}</span><span class="s2"> but len(fields)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">t</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">tuple_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">namedtuple_to_tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">namedtuple_to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">namedtuple_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nt</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict_to_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">namedtuple_to_dict</span><span class="p">(</span><span class="n">nt</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract a single item from an name</span>
<span class="sd">        :param field: field of the item to extract</span>
<span class="sd">        :param s: the string from which to extract it</span>
<span class="sd">        :return: the value for name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_pattern</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">info_dict</span> <span class="o">=</span> <span class="n">str_to_dict</span>  <span class="c1"># alias</span>
    <span class="n">info_tuple</span> <span class="o">=</span> <span class="n">str_to_tuple</span>  <span class="c1"># alias</span>

    <span class="k">def</span> <span class="nf">replace_name_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">elements_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace specific name argument values with others</span>
<span class="sd">        :param s: the string to replace</span>
<span class="sd">        :param elements_kwargs: the arguments to replace (and their values)</span>
<span class="sd">        :return: a new name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name_info_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_dict</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">elements_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">name_info_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">**</span><span class="n">name_info_dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;process_kwargs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;extract_pattern&quot;</span><span class="p">,</span>
            <span class="s2">&quot;prefix_pattern&quot;</span><span class="p">,</span>
            <span class="s2">&quot;prefix_template_including_name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;prefix_template_excluding_name&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">kv</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  * </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  * </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;template&quot;</span><span class="p">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;sep&quot;</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  * </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;format_dict&quot;</span><span class="p">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;format_dict&quot;</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kv</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;pattern&quot;</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">pattern</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;  * </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_print_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_str</span><span class="p">())</span>


<span class="c1"># TODO: mk_prefix has wrong signature. Repair.</span>
<div class="viewcode-block" id="StrTupleDictWithPrefix">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.StrTupleDictWithPrefix">[docs]</a>
<span class="k">class</span> <span class="nc">StrTupleDictWithPrefix</span><span class="p">(</span><span class="n">StrTupleDict</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Converting from and to strings, tuples, and dicts, but with partial &quot;prefix&quot; specs allowed.</span>

<span class="sd">    Args:</span>
<span class="sd">        template: The string format template</span>
<span class="sd">        format_dict: A {field_name: field_value_format_regex, ...} dict</span>
<span class="sd">        process_kwargs: A function taking the field=value pairs and producing a dict of processed</span>
<span class="sd">            {field: value,...} dict (where both fields and values could have been processed.</span>
<span class="sd">            This is useful when we need to process (format, default, etc.) fields, or their values,</span>
<span class="sd">            according to the other fields of values in the collection.</span>
<span class="sd">            A specification of {field: function_to_process_this_value,...} wouldn&#39;t allow the full powers</span>
<span class="sd">            we are allowing here.</span>
<span class="sd">        process_info_dict: A sort of converse of format_dict.</span>
<span class="sd">            This is a {field_name: field_conversion_func, ...} dict that is used to convert info_dict values</span>
<span class="sd">            before returning them.</span>
<span class="sd">        name_separator: Used</span>

<span class="sd">    &gt;&gt;&gt; ln = StrTupleDictWithPrefix(&#39;/home/{user}/fav/{num}.txt&#39;,</span>
<span class="sd">    ...	                  format_dict={&#39;user&#39;: &#39;[^/]+&#39;, &#39;num&#39;: r&#39;\d+&#39;},</span>
<span class="sd">    ...	                  process_info_dict={&#39;num&#39;: int},</span>
<span class="sd">    ...                   sep=&#39;/&#39;</span>
<span class="sd">    ...	                 )</span>
<span class="sd">    &gt;&gt;&gt; ln.mk(&#39;USER&#39;, num=123)  # making a string (with args or kwargs)</span>
<span class="sd">    &#39;/home/USER/fav/123.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; ####### prefix methods #######</span>
<span class="sd">    &gt;&gt;&gt; ln.is_valid_prefix(&#39;/home/USER/fav/&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ln.is_valid_prefix(&#39;/home/USER/fav/12&#39;)  # False because too long</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ln.is_valid_prefix(&#39;/home/USER/fav&#39;)  # False because too short</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ln.is_valid_prefix(&#39;/home/&#39;)  # True because just right</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ln.is_valid_prefix(&#39;/home/USER/fav/123.txt&#39;)  # full path, so output same as is_valid() method</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ln.mk_prefix(&#39;ME&#39;)</span>
<span class="sd">    &#39;/home/ME/fav/&#39;</span>
<span class="sd">    &gt;&gt;&gt; ln.mk_prefix(user=&#39;YOU&#39;, num=456)  # full specification, so output same as same as mk() method</span>
<span class="sd">    &#39;/home/YOU/fav/456.txt&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">StrTupleDict</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefix_template_including_name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefix_template_excluding_name</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">mk_prefix_templates_dicts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">template</span><span class="p">)</span>

        <span class="n">_prefix_pattern</span> <span class="o">=</span> <span class="s2">&quot;$|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">x</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">format_dict</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_template_including_name</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span>
                <span class="p">)</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">_prefix_pattern</span> <span class="o">+=</span> <span class="s2">&quot;$&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">_prefix_pattern</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_mk_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Make a prefix for an uploads name that has has the path up to the first None argument.</span>
<span class="sd">            :return: A string that is the prefix of a valid name</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_fields</span>
            <span class="p">),</span> <span class="s2">&quot;You have too many arguments&quot;</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">,</span> <span class="n">args</span><span class="p">)},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># ascertain that no fields were skipped (we can leave fields out at the end, but not in the middle)</span>
            <span class="n">a_name_was_skipped</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">a_name_was_skipped</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;You are making a PREFIX: This means you can&#39;t skip any fields. &quot;</span>
                            <span class="s2">&quot;Once a name is omitted, you need to omit all further fields. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;The name order is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="si">}</span><span class="s2">. You specified </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">a_name_was_skipped</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="n">keep_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">last_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">keep_kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">last_name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_template_including_name</span><span class="p">[</span><span class="n">last_name</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">keep_kwargs</span><span class="p">)</span>

        <span class="n">set_signature_of_func</span><span class="p">(</span><span class="n">_mk_prefix</span><span class="p">,</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mk_prefix</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">_mk_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="StrTupleDictWithPrefix.is_valid_prefix">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.StrTupleDictWithPrefix.is_valid_prefix">[docs]</a>
    <span class="k">def</span> <span class="nf">is_valid_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if name is a valid prefix.</span>
<span class="sd">        :param s: a string (that might or might not be a valid prefix)</span>
<span class="sd">        :return: True iff name is a valid prefix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">))</span></div>
</div>



<span class="n">LinearNaming</span> <span class="o">=</span> <span class="n">StrTupleDictWithPrefix</span>

<span class="kn">from</span> <span class="nn">dol.base</span> <span class="kn">import</span> <span class="n">Store</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">dol.util</span> <span class="kn">import</span> <span class="n">lazyprop</span>


<div class="viewcode-block" id="ParametricKeyStore">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.ParametricKeyStore">[docs]</a>
<span class="k">class</span> <span class="nc">ParametricKeyStore</span><span class="p">(</span><span class="n">Store</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="p">,</span> <span class="n">keymap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span> <span class="o">=</span> <span class="n">keymap</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_linear_naming</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;_linear_naming Deprecated: Use _keymap instead&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span></div>



<div class="viewcode-block" id="StoreWithTupleKeys">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.StoreWithTupleKeys">[docs]</a>
<span class="k">class</span> <span class="nc">StoreWithTupleKeys</span><span class="p">(</span><span class="n">ParametricKeyStore</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_key_of_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">info_tuple</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span></div>



<div class="viewcode-block" id="StoreWithDictKeys">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.StoreWithDictKeys">[docs]</a>
<span class="k">class</span> <span class="nc">StoreWithDictKeys</span><span class="p">(</span><span class="n">ParametricKeyStore</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">**</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_key_of_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">info_dict</span><span class="p">(</span><span class="n">_id</span><span class="p">)</span></div>



<div class="viewcode-block" id="StoreWithNamedTupleKeys">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.StoreWithNamedTupleKeys">[docs]</a>
<span class="k">class</span> <span class="nc">StoreWithNamedTupleKeys</span><span class="p">(</span><span class="n">ParametricKeyStore</span><span class="p">):</span>
    <span class="nd">@lazyprop</span>
    <span class="k">def</span> <span class="nf">NamedTupleKey</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;NamedTupleKey&quot;</span><span class="p">,</span> <span class="n">field_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">mk</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_key_of_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">NamedTupleKey</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_keymap</span><span class="o">.</span><span class="n">info_tuple</span><span class="p">(</span><span class="n">_id</span><span class="p">))</span></div>



<span class="c1"># def mk_parametric_key_store_cls(store_cls, key_type=tuple):</span>
<span class="c1">#     if key_type == tuple:</span>
<span class="c1">#         super_cls = StoreWithTupleKeys</span>
<span class="c1">#     elif key_type == dict:</span>
<span class="c1">#         super_cls = StoreWithDictKeys</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise ValueError(&quot;key_type needs to be tuple or dict&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     class A(super_cls, store_cls):</span>
<span class="c1">#         def __init__(self, rootdir, subpath=&#39;&#39;, format_dict=None, process_kwargs=None, process_info_dict=None,</span>
<span class="c1">#                      **extra_store_kwargs):</span>
<span class="c1">#</span>
<span class="c1">#             path_format = os.path.join(rootdir, subpath)</span>
<span class="c1">#             store = store_cls.__init__(self, path_format=path_format, **extra_store_kwargs)</span>
<span class="c1">#             linear_naming = LinearNaming()</span>
<span class="c1">#</span>
<span class="c1">#             # FilepathFormatKeys.__init__(self, path_format)</span>


<span class="k">class</span> <span class="nc">NamingInterface</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">validation_funs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">all_kwargs_should_be_in_validation_dict</span><span class="o">=</span><span class="n">dflt_all_kwargs_should_be_in_validation_dict</span><span class="p">,</span>
        <span class="n">ignore_misunderstood_validation_instructions</span><span class="o">=</span><span class="n">dflt_ignore_misunderstood_validation_instructions</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">validation_funs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">validation_funs</span> <span class="o">=</span> <span class="n">dflt_validation_funs</span>
        <span class="n">validation_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;validation&quot;</span><span class="p">,</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">default_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">var</span><span class="p">:</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">arg_pattern</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;arg_pattern&quot;</span><span class="p">,</span> <span class="n">dflt_arg_pattern</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">named_arg_pattern</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;(?P&lt;&quot;</span> <span class="o">+</span> <span class="n">var</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span> <span class="o">+</span> <span class="n">pat</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">arg_pattern</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">to_str</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;to_str&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;to_str&quot;</span> <span class="ow">in</span> <span class="n">info</span>
        <span class="p">}</span>
        <span class="n">to_val</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">var</span><span class="p">:</span> <span class="n">info</span><span class="p">[</span><span class="s2">&quot;to_val&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">info</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;to_val&quot;</span> <span class="ow">in</span> <span class="n">info</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validation_dict</span> <span class="o">=</span> <span class="n">validation_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_dict</span> <span class="o">=</span> <span class="n">default_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arg_pattern</span> <span class="o">=</span> <span class="n">arg_pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">named_arg_pattern</span> <span class="o">=</span> <span class="n">named_arg_pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_str</span> <span class="o">=</span> <span class="n">to_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_val</span> <span class="o">=</span> <span class="n">to_val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">validation_funs</span> <span class="o">=</span> <span class="n">validation_funs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_kwargs_should_be_in_validation_dict</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">all_kwargs_should_be_in_validation_dict</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_misunderstood_validation_instructions</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ignore_misunderstood_validation_instructions</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">validate_kwargs</span><span class="p">(</span>
            <span class="n">kwargs_to_validate</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">validation_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_dict</span><span class="p">,</span>
            <span class="n">validation_funs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">validation_funs</span><span class="p">,</span>
            <span class="n">all_kwargs_should_be_in_validation_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_kwargs_should_be_in_validation_dict</span><span class="p">,</span>
            <span class="n">ignore_misunderstood_validation_instructions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ignore_misunderstood_validation_instructions</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">default_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_dict</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="ow">or</span> <span class="s2">&quot;args&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">default</span>
            <span class="ow">or</span> <span class="s2">&quot;func&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">default</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># call the func on the default[&#39;args&#39;] values given in kwargs</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="n">arg_</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">arg_</span><span class="p">]</span> <span class="k">for</span> <span class="n">arg_</span> <span class="ow">in</span> <span class="n">default</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]}</span>
            <span class="k">return</span> <span class="n">default</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">str_kwargs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_str</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_str</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">val_kwargs_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_val</span><span class="p">[</span><span class="n">k</span><span class="p">](</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_val</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">name_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interface method: Method needs to be implemented&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">info_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interface method: Method needs to be implemented&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_valid_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Interface method: Method needs to be implemented&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BigDocTest">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.BigDocTest">[docs]</a>
<span class="k">class</span> <span class="nc">BigDocTest</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; e_name = BigDocTest.mk_e_naming()</span>
<span class="sd">    &gt;&gt;&gt; u_name = BigDocTest.mk_u_naming()</span>
<span class="sd">    &gt;&gt;&gt; e_sref = &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/2017-01-24/1485272231982_1485261448469&#39;</span>
<span class="sd">    &gt;&gt;&gt; u_sref = &quot;s3://uploads/GROUP/upload/files/USER/2017-01-24/SUBUSER/a_file.wav&quot;</span>
<span class="sd">    &gt;&gt;&gt; u_name_2 = &quot;s3://uploads/ANOTHER_GROUP/upload/files/ANOTHER_USER/2017-01-24/SUBUSER/a_file.wav&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ####### is_valid(self, name): ######</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid(e_sref)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid(u_sref)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; u_name.is_valid(u_sref)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ####### is_valid_prefix(self, name): ######</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP/example/&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP/example/files&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP/example/files/&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP/example/files/USER/SUBUSER/2017-01-24/&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; e_name.is_valid_prefix(&#39;s3://bucket-GROUP/example/files/USER/SUBUSER/2017-01-24/0_0&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ####### info_dict(self, name): ######</span>
<span class="sd">    &gt;&gt;&gt; e_name.info_dict(e_sref)  # see that utc_ms args were cast to ints</span>
<span class="sd">    {&#39;group&#39;: &#39;GROUP&#39;, &#39;user&#39;: &#39;USER&#39;, &#39;subuser&#39;: &#39;SUBUSER&#39;, &#39;day&#39;: &#39;2017-01-24&#39;, &#39;s_ums&#39;: 1485272231982, &#39;e_ums&#39;: 1485261448469}</span>
<span class="sd">    &gt;&gt;&gt; u_name.info_dict(u_sref)  # returns None (because self was made for example!</span>
<span class="sd">    {&#39;group&#39;: &#39;GROUP&#39;, &#39;user&#39;: &#39;USER&#39;, &#39;day&#39;: &#39;2017-01-24&#39;, &#39;subuser&#39;: &#39;SUBUSER&#39;, &#39;filename&#39;: &#39;a_file.wav&#39;}</span>
<span class="sd">    &gt;&gt;&gt; # but with a u_name, it will work</span>
<span class="sd">    &gt;&gt;&gt; u_name.info_dict(u_sref)</span>
<span class="sd">    {&#39;group&#39;: &#39;GROUP&#39;, &#39;user&#39;: &#39;USER&#39;, &#39;day&#39;: &#39;2017-01-24&#39;, &#39;subuser&#39;: &#39;SUBUSER&#39;, &#39;filename&#39;: &#39;a_file.wav&#39;}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ####### extract(self, item, name): ######</span>
<span class="sd">    &gt;&gt;&gt; e_name.extract(&#39;group&#39;, e_sref)</span>
<span class="sd">    &#39;GROUP&#39;</span>
<span class="sd">    &gt;&gt;&gt; e_name.extract(&#39;user&#39;, e_sref)</span>
<span class="sd">    &#39;USER&#39;</span>
<span class="sd">    &gt;&gt;&gt; u_name.extract(&#39;group&#39;, u_name_2)</span>
<span class="sd">    &#39;ANOTHER_GROUP&#39;</span>
<span class="sd">    &gt;&gt;&gt; u_name.extract(&#39;user&#39;, u_name_2)</span>
<span class="sd">    &#39;ANOTHER_USER&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    #</span>
<span class="sd">    # &gt;&gt;&gt; ####### mk_prefix(self, *args, **kwargs): ######</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix()</span>
<span class="sd">    # &#39;s3://bucket-&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;, day=&#39;0000-00-00&#39;)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/0000-00-00/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;, day=&#39;0000-00-00&#39;,</span>
<span class="sd">    # ... s_ums=1485272231982)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/0000-00-00/1485272231982_&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;, day=&#39;0000-00-00&#39;,</span>
<span class="sd">    # ... s_ums=1485272231982, e_ums=1485261448469)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/0000-00-00/1485272231982_1485261448469&#39;</span>
<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix()</span>
<span class="sd">    # &#39;s3://uploads/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix(group=&#39;GROUP&#39;)</span>
<span class="sd">    # &#39;s3://uploads/GROUP/upload/files/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;)</span>
<span class="sd">    # &#39;s3://uploads/GROUP/upload/files/USER/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, day=&#39;DAY&#39;)</span>
<span class="sd">    # &#39;s3://uploads/GROUP/upload/files/USER/DAY/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, day=&#39;DAY&#39;)</span>
<span class="sd">    # &#39;s3://uploads/GROUP/upload/files/USER/DAY/&#39;</span>
<span class="sd">    # &gt;&gt;&gt; u_name.mk_prefix(group=&#39;GROUP&#39;, user=&#39;USER&#39;, day=&#39;DAY&#39;, subuser=&#39;SUBUSER&#39;)</span>
<span class="sd">    # &#39;s3://uploads/GROUP/upload/files/USER/DAY/SUBUSER/&#39;</span>
<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; ####### mk(self, *args, **kwargs): ######</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;, day=&#39;0000-00-00&#39;,</span>
<span class="sd">    # ...             s_ums=1485272231982, e_ums=1485261448469)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/0000-00-00/1485272231982_1485261448469&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.mk(group=&#39;GROUP&#39;, user=&#39;USER&#39;, subuser=&#39;SUBUSER&#39;, day=&#39;from_s_ums&#39;,</span>
<span class="sd">    # ...             s_ums=1485272231982, e_ums=1485261448469)</span>
<span class="sd">    # &#39;s3://bucket-GROUP/example/files/USER/SUBUSER/2017-01-24/1485272231982_1485261448469&#39;</span>
<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; ####### replace_name_elements(self, *args, **kwargs): ######</span>
<span class="sd">    # &gt;&gt;&gt; name = &#39;s3://bucket-redrum/example/files/oopsy@domain.com/ozeip/2008-11-04/1225779243969_1225779246969&#39;</span>
<span class="sd">    # &gt;&gt;&gt; e_name.replace_name_elements(name, user=&#39;NEW_USER&#39;, group=&#39;NEW_GROUP&#39;)</span>
<span class="sd">    # &#39;s3://bucket-NEW_GROUP/example/files/NEW_USER/ozeip/2008-11-04/1225779243969_1225779246969&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">process_info_dict_for_example</span><span class="p">(</span><span class="o">**</span><span class="n">info_dict</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;s_ums&quot;</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="p">:</span>
            <span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;e_ums&quot;</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="p">:</span>
            <span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;e_ums&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;e_ums&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">info_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">example_process_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

        <span class="n">epoch</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">second_ms</span> <span class="o">=</span> <span class="mf">1000.0</span>

        <span class="k">def</span> <span class="nf">utcnow_ms</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span> <span class="o">-</span> <span class="n">epoch</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="n">second_ms</span>

        <span class="c1"># from ut.util.time import second_ms, utcnow_ms</span>
        <span class="k">if</span> <span class="s2">&quot;s_ums&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;e_ums&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;e_ums&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;e_ums&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;day&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">day</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span>
            <span class="c1"># get the day in the expected format</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">day</span> <span class="o">==</span> <span class="s2">&quot;now&quot;</span><span class="p">:</span>
                    <span class="n">day</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">utcnow_ms</span><span class="p">()</span> <span class="o">/</span> <span class="n">second_ms</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">day_format</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">day</span> <span class="o">==</span> <span class="s2">&quot;from_s_ums&quot;</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="s2">&quot;s_ums&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s2">&quot;need to have s_ums argument&quot;</span>
                    <span class="n">day</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">second_ms</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">day_format</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">day_format_pattern</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">day</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">day</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
                <span class="n">day</span> <span class="o">=</span> <span class="n">day</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">day_format</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s2">&quot;s_ums&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>  <span class="c1"># if day is neither a string nor a datetime</span>
                <span class="n">day</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;s_ums&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">second_ms</span><span class="p">)</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">day_format</span><span class="p">)</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;day&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">day</span>

        <span class="k">return</span> <span class="n">kwargs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mk_e_naming</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">LinearNaming</span><span class="p">(</span>
            <span class="n">template</span><span class="o">=</span><span class="s2">&quot;s3://bucket-</span><span class="si">{group}</span><span class="s2">/example/files/</span><span class="si">{user}</span><span class="s2">/</span><span class="si">{subuser}</span><span class="s2">/</span><span class="si">{day}</span><span class="s2">/</span><span class="si">{s_ums}</span><span class="s2">_</span><span class="si">{e_ums}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">format_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;s_ums&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="s2">&quot;e_ums&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="s2">&quot;day&quot;</span><span class="p">:</span> <span class="s2">&quot;[^/]+&quot;</span><span class="p">},</span>
            <span class="n">process_kwargs</span><span class="o">=</span><span class="n">BigDocTest</span><span class="o">.</span><span class="n">example_process_kwargs</span><span class="p">,</span>
            <span class="n">process_info_dict</span><span class="o">=</span><span class="n">BigDocTest</span><span class="o">.</span><span class="n">process_info_dict_for_example</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mk_u_naming</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">LinearNaming</span><span class="p">(</span>
            <span class="n">template</span><span class="o">=</span><span class="s2">&quot;s3://uploads/</span><span class="si">{group}</span><span class="s2">/upload/files/</span><span class="si">{user}</span><span class="s2">/</span><span class="si">{day}</span><span class="s2">/</span><span class="si">{subuser}</span><span class="s2">/</span><span class="si">{filename}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">format_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;day&quot;</span><span class="p">:</span> <span class="s2">&quot;[^/]+&quot;</span><span class="p">,</span> <span class="s2">&quot;filepath&quot;</span><span class="p">:</span> <span class="s2">&quot;.+&quot;</span><span class="p">},</span>
        <span class="p">)</span></div>



<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">dol.trans</span> <span class="kn">import</span> <span class="n">wrap_kvs</span><span class="p">,</span> <span class="n">store_decorator</span>

<span class="n">pjoin</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span>

<span class="n">KeyMapNames</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;KeyMaps&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">,</span> <span class="s2">&quot;id_of_key&quot;</span><span class="p">])</span>
<span class="n">KeyMaps</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;KeyMaps&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">,</span> <span class="s2">&quot;id_of_key&quot;</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_get_keymap_names_for_str_to_key_type</span><span class="p">(</span><span class="n">key_type</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">key_type</span> <span class="o">=</span> <span class="p">{</span>
            <span class="nb">tuple</span><span class="p">:</span> <span class="s2">&quot;tuple&quot;</span><span class="p">,</span>
            <span class="n">namedtuple</span><span class="p">:</span> <span class="s2">&quot;namedtuple&quot;</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">:</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span>
        <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">key_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;tuple&quot;</span><span class="p">,</span> <span class="s2">&quot;namedtuple&quot;</span><span class="p">,</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not a recognized key_type: </span><span class="si">{</span><span class="n">key_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">KeyMapNames</span><span class="p">(</span><span class="n">key_of_id</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;str_to_</span><span class="si">{</span><span class="n">key_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key_type</span><span class="si">}</span><span class="s2">_to_str&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_method_for_str_to_key_type</span><span class="p">(</span><span class="n">keymap</span><span class="p">,</span> <span class="n">key_type</span><span class="p">):</span>
    <span class="n">kmn</span> <span class="o">=</span> <span class="n">_get_keymap_names_for_str_to_key_type</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">KeyMaps</span><span class="p">(</span>
        <span class="n">key_of_id</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">keymap</span><span class="p">,</span> <span class="n">kmn</span><span class="o">.</span><span class="n">key_of_id</span><span class="p">),</span>
        <span class="n">id_of_key</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">keymap</span><span class="p">,</span> <span class="n">kmn</span><span class="o">.</span><span class="n">id_of_key</span><span class="p">),</span>
    <span class="p">)</span>


<span class="c1"># TODO: Make this into a proper store decorator</span>
<div class="viewcode-block" id="mk_store_from_path_format_store_cls">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.mk_store_from_path_format_store_cls">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span> <span class="nf">mk_store_from_path_format_store_cls</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">subpath</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">store_cls_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_type</span><span class="o">=</span><span class="n">namedtuple</span><span class="p">,</span>
    <span class="n">keymap</span><span class="o">=</span><span class="n">StrTupleDict</span><span class="p">,</span>
    <span class="n">keymap_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrap a store (instance or class) that uses string keys to make it into a store that uses a specific key format.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The instance or class to wrap</span>
<span class="sd">        subpath: The subpath (defining the subset of the data pointed at by the URI</span>
<span class="sd">        store_cls_kwargs:  # if store is a class, the kwargs that you would have given the store_cls to make itself</span>
<span class="sd">        key_type: The key type you want to interface with:</span>
<span class="sd">            dict, tuple, namedtuple, str or &#39;dict&#39;, &#39;tuple&#39;, &#39;namedtuple&#39;, &#39;str&#39;</span>
<span class="sd">        keymap:  # the keymap instance or class you want to use to map keys</span>
<span class="sd">        keymap_kwargs:  # if keymap is a cls, the kwargs to give it (besides the subpath)</span>
<span class="sd">        name: The name to give the class the function will make here</span>

<span class="sd">    Returns: An instance of a wrapped class</span>


<span class="sd">    Example:</span>
<span class="sd">    ```</span>
<span class="sd">    # Get a (session, bt) indexed LocalJsonStore</span>
<span class="sd">    s = mk_store_from_path_format_store_cls(LocalJsonStore,</span>
<span class="sd">                                                   os.path.join(root_dir, &#39;d&#39;),</span>
<span class="sd">                                                   subpath=&#39;{session}/d/{bt}&#39;,</span>
<span class="sd">                                                   keymap_kwargs=dict(process_info_dict={&#39;session&#39;: int, &#39;bt&#39;: int}))</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keymap</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">keymap</span> <span class="o">=</span> <span class="n">keymap</span><span class="p">(</span><span class="n">subpath</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">keymap_kwargs</span> <span class="ow">or</span> <span class="p">{}))</span>  <span class="c1"># make the keymap instance</span>

    <span class="n">km</span> <span class="o">=</span> <span class="n">_get_method_for_str_to_key_type</span><span class="p">(</span><span class="n">keymap</span><span class="p">,</span> <span class="n">key_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;KeyWrapped&quot;</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">_WrappedStoreCls</span> <span class="o">=</span> <span class="n">wrap_kvs</span><span class="p">(</span>
            <span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">key_of_id</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">id_of_key</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">WrappedStoreCls</span><span class="p">(</span><span class="n">_WrappedStoreCls</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_uri</span><span class="p">):</span>
                <span class="n">path_format</span> <span class="o">=</span> <span class="n">pjoin</span><span class="p">(</span><span class="n">root_uri</span><span class="p">,</span> <span class="n">subpath</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">path_format</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">store_cls_kwargs</span> <span class="ow">or</span> <span class="p">{}))</span>

        <span class="k">return</span> <span class="n">WrappedStoreCls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;KeyWrapped&quot;</span> <span class="o">+</span> <span class="n">store</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span>
            <span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">key_of_id</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">km</span><span class="o">.</span><span class="n">id_of_key</span>
        <span class="p">)</span></div>



<span class="n">mk_tupled_store_from_path_format_store_cls</span> <span class="o">=</span> <span class="n">mk_store_from_path_format_store_cls</span>

<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">Formatter</span>


<span class="c1"># TODO: Make .vformat (therefore .format) work with args and kwargs</span>
<span class="c1"># TODO: Make it not blow up and conserve spec (e.g. the 1.2f of {foo:1.2f}) when not specified</span>
<div class="viewcode-block" id="PartialFormatter">
<a class="viewcode-back" href="../../module_docs/dol/naming.html#dol.naming.PartialFormatter">[docs]</a>
<span class="k">class</span> <span class="nc">PartialFormatter</span><span class="p">(</span><span class="n">Formatter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A string formatter that won&#39;t complain if the fields are only partially formatted.</span>
<span class="sd">    But note that you will lose the spec part of your template (e.g. in {foo:1.2f}, you&#39;ll loose the 1.2f</span>
<span class="sd">    if not foo is given -- but {foo} will remain).</span>

<span class="sd">    &gt;&gt;&gt; partial_formatter = PartialFormatter()</span>
<span class="sd">    &gt;&gt;&gt; str_template = &#39;foo:{foo} bar={bar} a={a} b={b:0.02f} c={c}&#39;</span>
<span class="sd">    &gt;&gt;&gt; partial_formatter.format(str_template, bar=&quot;BAR&quot;, b=34)</span>
<span class="sd">    &#39;foo:{foo} bar=BAR a={a} b=34.00 c={c}&#39;</span>

<span class="sd">    Note: If you only need a formatting function (not the transformed formatting string), a simpler solution may be:</span>
<span class="sd">    ```</span>
<span class="sd">    import functools</span>
<span class="sd">    format_str = functools.partial(str_template.format, bar=&quot;BAR&quot;, b=34)</span>
<span class="sd">    ```</span>
<span class="sd">    See https://stackoverflow.com/questions/11283961/partial-string-formatting for more options and discussions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">key</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

    <span class="k">def</span> <span class="nf">format_fields_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>

    <span class="k">def</span> <span class="nf">format_with_non_none_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_string</span><span class="p">,</span> <span class="o">**</span><span class="n">mapping</span><span class="p">):</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">vformat</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="p">(),</span> <span class="n">mapping</span><span class="p">)</span></div>



<span class="n">partial_formatter</span> <span class="o">=</span> <span class="n">PartialFormatter</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>