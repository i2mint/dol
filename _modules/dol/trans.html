

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.trans &mdash; dol 0.3.33 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=61118ce6"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/kv_codecs.html">dol.kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/new_store_wrap.html">dol.scrap.new_store_wrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_appendable.html">dol.tests.test_appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_caching.html">dol.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_dig.html">dol.tests.test_dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_dol_tools.html">dol.tests.test_dol_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_errors.html">dol.tests.test_errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_filesys.html">dol.tests.test_filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_kv_codecs.html">dol.tests.test_kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_paths.html">dol.tests.test_paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_trans.html">dol.tests.test_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/utils_for_tests.html">dol.tests.utils_for_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dol.html">dol</a></li>
      <li class="breadcrumb-item active">dol.trans</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.trans</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Transformation/wrapping tools&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Generic</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">KeysView</span> <span class="k">as</span> <span class="n">BaseKeysView</span><span class="p">,</span>
    <span class="n">ValuesView</span> <span class="k">as</span> <span class="n">BaseValuesView</span><span class="p">,</span>
    <span class="n">ItemsView</span> <span class="k">as</span> <span class="n">BaseItemsView</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dol.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">SetattrNotAllowed</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">Store</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">,</span> <span class="n">AttrNames</span><span class="p">,</span> <span class="n">kv_walk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol.util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">safe_compile</span><span class="p">,</span>
    <span class="n">lazyprop</span><span class="p">,</span>
    <span class="n">attrs_of</span><span class="p">,</span>
    <span class="n">wraps</span><span class="p">,</span>
    <span class="n">Pipe</span><span class="p">,</span>
    <span class="n">LiteralVal</span><span class="p">,</span>
    <span class="n">num_of_args</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol.signatures</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">KO</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Internal Utils</span>


<div class="viewcode-block" id="double_up_as_factory">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.double_up_as_factory">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">double_up_as_factory</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Repurpose a decorator both as it&#39;s original form, and as a decorator factory.</span>
<span class="sd">    That is, from a decorator that is defined do ``wrapped_func = decorator(func, **params)``,</span>
<span class="sd">    make it also be able to do ``wrapped_func = decorator(**params)(func)``.</span>

<span class="sd">    Note: You&#39;ll only be able to do this if all but the first argument are keyword-only,</span>
<span class="sd">    and the first argument (the function to decorate) has a default of ``None`` (this is for your own good).</span>
<span class="sd">    This is validated before making the &quot;double up as factory&quot; decorator.</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator(func=None, *, multiplier=2):</span>
<span class="sd">    ...     def _func(x):</span>
<span class="sd">    ...         return func(x) * multiplier</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = decorator(foo, multiplier=10)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; multiply_by_3 = decorator(multiplier=3)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = multiply_by_3(foo)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @decorator(multiplier=3)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    9</span>

<span class="sd">    Note that to be able to use double_up_as_factory, your first argument (the object to be wrapped) needs to default</span>
<span class="sd">    to None and be the only argument that is not keyword-only (i.e. all other arguments need to be keyword only).</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator_2(func, *, multiplier=2):</span>
<span class="sd">    ...     &#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: First argument of the decorator function needs to default to None. Was &lt;class &#39;inspect._empty&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator_3(func=None, multiplier=2):</span>
<span class="sd">    ...     &#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: All arguments (besides the first) need to be keyword-only</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
        <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;First argument of the decorator function needs to default to None. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Was </span><span class="si">{</span><span class="n">first_param</span><span class="o">.</span><span class="n">default</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other_params</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;All arguments (besides the first) need to be keyword-only&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_double_up_as_factory</span><span class="p">(</span><span class="n">wrapped</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decorator_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_double_up_as_factory</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_all_but_first_arg_are_keyword_only</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, *, b, c=2): ...</span>
<span class="sd">    &gt;&gt;&gt; _all_but_first_arg_are_keyword_only(foo)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; def bar(a, b, *, c=2): ...</span>
<span class="sd">    &gt;&gt;&gt; _all_but_first_arg_are_keyword_only(bar)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kinds</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span>  <span class="c1"># consume first item, and all remaining should be KEYWORD_ONLY</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">)</span>


<span class="c1"># TODO: Separate the wrapper_assignments injection (and possibly make these not show up at the interface?)</span>
<span class="c1"># FIXME: doctest line numbers not shown correctly when wrapped by store_decorator!</span>
<div class="viewcode-block" id="store_decorator">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.store_decorator">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">store_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper to make store decorators.</span>

<span class="sd">    You provide a class-decorating function ``func`` that takes a store type (and possibly additional params)</span>
<span class="sd">    and returns another decorated store type.</span>

<span class="sd">    ``store_decorator`` takes that ``func`` and provides an enhanced class decorator specialized for stores.</span>
<span class="sd">    Namely it will:</span>
<span class="sd">    - Add ``__module__``, ``__qualname__``, ``__name__`` and ``__doc__`` arguments to it</span>
<span class="sd">    - Copy the aforementioned arguments to the decorated class, or copy the attributes of the original if not specified.</span>
<span class="sd">    - Output a decorator that can be used in four different ways: a class/instance decorator/factory.</span>

<span class="sd">    By class/instance decorator/factory we mean that if ``A`` is a class, ``a`` an instance of it,</span>
<span class="sd">    and ``deco`` a decorator obtained with ``store_decorator(func)``,</span>
<span class="sd">    we can use ``deco`` to</span>
<span class="sd">    - class decorator: decorate a class</span>
<span class="sd">    - class decorator factory: make a function that decorates classes</span>
<span class="sd">    - instance decorator: decorate an instance of a store</span>
<span class="sd">    - instancce decorator factor: make a function that decorates instances of stores</span>

<span class="sd">    For example, say we have the following ``deco`` that we made with ``store_decorator``:</span>

<span class="sd">    &gt;&gt;&gt; @store_decorator</span>
<span class="sd">    ... def deco(cls=None, *, x=1):</span>
<span class="sd">    ...     # do stuff to cls, or a copy of it...</span>
<span class="sd">    ...     cls.x = x  # like this for example</span>
<span class="sd">    ...     return cls</span>

<span class="sd">    And a class that has nothing to it:</span>

<span class="sd">    &gt;&gt;&gt; class A: ...</span>

<span class="sd">    Nammely, it doesn&#39;t have an ``x``</span>

<span class="sd">    &gt;&gt;&gt; hasattr(A, &#39;x&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    We make a ``decorated_A`` with ``deco`` (class decorator example)</span>

<span class="sd">    &gt;&gt;&gt; t = deco(A, x=42)</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(t, type)</span>

<span class="sd">    and we see that we now have an ``x`` and it&#39;s 42</span>

<span class="sd">    &gt;&gt;&gt; hasattr(A, &#39;x&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; A.x</span>
<span class="sd">    42</span>

<span class="sd">    But we could have also made a factory to decorate ``A`` and anything else that comes our way.</span>

<span class="sd">    &gt;&gt;&gt; paint_it_42 = deco(x=42)</span>
<span class="sd">    &gt;&gt;&gt; decorated_A = paint_it_42(A)</span>
<span class="sd">    &gt;&gt;&gt; assert decorated_A.x == 42</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     x = &#39;destined to disappear&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert paint_it_42(B).x == 42</span>

<span class="sd">    To be fair though, you&#39;ll probably see the factory usage appear in the following form,</span>
<span class="sd">    where the class is decorated at definition time.</span>

<span class="sd">    &gt;&gt;&gt; @deco(x=42)</span>
<span class="sd">    ... class B:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert B.x == 42</span>

<span class="sd">    If your exists already, and you want to keep it as is (with the same name), you can</span>
<span class="sd">    use subclassing to transform a copy of ``A`` instead, as below.</span>
<span class="sd">    Also note in the following example, that ``deco`` was used without parentheses,</span>
<span class="sd">    which is equivalent to ``@deco()``,</span>
<span class="sd">    and yes, store_decorator makes that possible to, as long as your params have defaults</span>

<span class="sd">    &gt;&gt;&gt; @deco</span>
<span class="sd">    ... class decorated_A(A):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert decorated_A.x == 1</span>
<span class="sd">    &gt;&gt;&gt; assert A.x == 42</span>

<span class="sd">    Finally, you can also decorate instances:</span>

<span class="sd">    &gt;&gt;&gt; class A: ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; hasattr(a, &#39;x&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = deco(a); assert b.x == 1; # b has an x and it&#39;s 1</span>
<span class="sd">    &gt;&gt;&gt; b = deco()(a); assert b.x == 1; # b has an x and it&#39;s 1</span>
<span class="sd">    &gt;&gt;&gt; b = deco(a, x=42); assert b.x == 42  # b has an x and it&#39;s 42</span>
<span class="sd">    &gt;&gt;&gt; b = deco(x=42)(a); assert b.x == 42; # b has an x and it&#39;s 42</span>

<span class="sd">    WARNING: Note though that the type of ``b`` is not the same type as ``a``</span>

<span class="sd">    &gt;&gt;&gt; isinstance(b, a.__class__)</span>
<span class="sd">    False</span>

<span class="sd">    No, ``b`` is an instance of a ``dol.base.Store``, which is a class containing an</span>
<span class="sd">    instance of a store (here, ``a``).</span>

<span class="sd">    &gt;&gt;&gt; type(b)</span>
<span class="sd">    &lt;class &#39;dol.base.Store&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; b.store == a</span>
<span class="sd">    True</span>

<span class="sd">    Now, here&#39;s some more example, slightly closer to real usage</span>

<span class="sd">    &gt;&gt;&gt; from dol.trans import store_decorator</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def rm_deletion(store=None, *, msg=&#39;Deletions not allowed.&#39;):</span>
<span class="sd">    ...     name = getattr(store, &#39;__name__&#39;, &#39;Something&#39;) + &#39;_w_sommething&#39;</span>
<span class="sd">    ...     assert isinstance(store, type), f&quot;Should be a type, was {type(store)}: {store}&quot;</span>
<span class="sd">    ...     wrapped_store = type(name, (store,), {})</span>
<span class="sd">    ...     wrapped_store.__delitem__ = lambda self, k: msg</span>
<span class="sd">    ...     return wrapped_store</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; remove_deletion = store_decorator(rm_deletion)</span>

<span class="sd">    See how the signature of the wrapper has some extra inputs that were injected (__module__, __qualname__, etc.):</span>

<span class="sd">    &gt;&gt;&gt; print(str(signature(remove_deletion)))</span>
<span class="sd">    (store=None, *, msg=&#39;Deletions not allowed.&#39;, __module__=None, __name__=None, __qualname__=None, __doc__=None, __annotations__=None, __defaults__=None, __kwdefaults__=None)</span>

<span class="sd">    Using it as a class decorator factory (the most common way):</span>

<span class="sd">    As a class decorator &quot;factory&quot;, without parameters (and without ()):</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; @remove_deletion</span>
<span class="sd">    ... class WD(UserDict):</span>
<span class="sd">    ...     &quot;Here&#39;s the doc&quot;</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__doc__ == &quot;Here&#39;s the doc&quot;</span>

<span class="sd">    As a class decorator &quot;factory&quot;, with parameters:</span>

<span class="sd">    &gt;&gt;&gt; @remove_deletion(msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    ... class WD(UserDict): ...</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    The __doc__ is empty:</span>

<span class="sd">    &gt;&gt;&gt; assert WD.__doc__ == None</span>

<span class="sd">    But we could specify a doc if we wanted to:</span>

<span class="sd">    &gt;&gt;&gt; @remove_deletion(__doc__=&quot;Hi, I&#39;m a doc.&quot;)</span>
<span class="sd">    ... class WD(UserDict):</span>
<span class="sd">    ...     &quot;This is the original doc, that will be overritten&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert WD.__doc__ == &quot;Hi, I&#39;m a doc.&quot;</span>


<span class="sd">    The class decorations above are equivalent to the two following:</span>

<span class="sd">    &gt;&gt;&gt; WD = remove_deletion(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; WD = remove_deletion(UserDict, msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    &gt;&gt;&gt; wd = WD(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == UserDict(x=5, y=7)  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    But we can also decorate instances. In this case they will be wrapped in a Store class</span>
<span class="sd">    before being passed on to the actual decorator.</span>

<span class="sd">    &gt;&gt;&gt; d = UserDict(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; wd = remove_deletion(d)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == d  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;Deletions not allowed.&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; d = UserDict(x=5, y=7)</span>
<span class="sd">    &gt;&gt;&gt; wd = remove_deletion(d, msg=&#39;No way. I do not trust you!!&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert wd == d  # same as far as dict comparison goes</span>
<span class="sd">    &gt;&gt;&gt; assert wd.__delitem__(&#39;x&#39;) == &#39;No way. I do not trust you!!&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># wrapper_assignments = (&#39;__module__&#39;, &#39;__qualname__&#39;, &#39;__name__&#39;, &#39;__doc__&#39;, &#39;__annotations__&#39;)</span>
    <span class="n">wrapper_assignments</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;__module__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__name__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__doc__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__annotations__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__defaults__&quot;</span><span class="p">,</span>
        <span class="s2">&quot;__kwdefaults__&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_func_wrapping_store_in_cls_if_not_type</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">specials</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">specials</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">store_instance</span> <span class="o">=</span> <span class="n">store</span>
            <span class="c1"># StoreWrap = type(</span>
            <span class="c1">#     &#39;StoreWrap&#39;, (Store,), {}</span>
            <span class="c1"># )  # a copy of Store, so Store isn&#39;t transformed directly</span>

            <span class="n">WrapperStore</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">Store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">WrapperStore</span><span class="p">(</span><span class="n">store_instance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">_all_but_first_arg_are_keyword_only</span><span class="p">(</span><span class="n">func</span><span class="p">),</span> <span class="p">(</span>
                <span class="s2">&quot;To use decorating_store_cls, all but the first of your function&#39;s arguments need to be all keyword only. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The signature was </span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}{</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">specials</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span>

    <span class="c1"># Two standard attributes for storing the original function are func and __wrapped__</span>
    <span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
    <span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">func</span>

    <span class="c1"># @wraps(func)</span>
    <span class="n">wrapper_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">],</span>
        <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># TODO: Re-use double_up_as_factory here</span>
    <span class="nd">@wrapper_sig</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">wrapped_store_cls</span> <span class="o">=</span> <span class="n">_func_wrapping_store_in_cls_if_not_type</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">wrapped_store_cls</span>

    <span class="c1"># Make sure the wrapper (yes, also the wrapper) has the same key dunders as the func</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wrapper_assignments</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">wrapper</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">ensure_set</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_class_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dflt_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__class__&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dflt_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dflt_name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> has no name I could extract&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="k">def</span><span class="w"> </span><span class="nf">store_wrap</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">updated</span><span class="o">=</span><span class="p">())</span>  <span class="c1"># added this: test</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">StoreWrap</span><span class="p">(</span><span class="n">Store</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">persister</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">persister</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">StoreWrap</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Store</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_bound</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;__self__&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_first_param_is_an_instance_param</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">self_names</span>


<span class="c1"># TODO: Add validation of func: That all but perhaps 1 argument (not counting self)</span>
<span class="c1">#  has a default</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_has_unbound_self</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        func:</span>

<span class="sd">    Returns:</span>

<span class="sd">    &gt;&gt;&gt; def f1(x): ...</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f1) == 0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f2(self, x): ...</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f2) == 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f3 = lambda self, x: True</span>
<span class="sd">    &gt;&gt;&gt; assert _has_unbound_self(f3) == 1</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def bar(self, x): ...</span>
<span class="sd">    ...     def foo(dacc, x): ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(a.bar)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(a.foo)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(A.bar)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; _has_unbound_self(A.foo)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># If there was a problem getting the signature, assume it&#39;s a signature-less builtin (so not a bound method)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no argument, so we can&#39;t be wrapping anything!!!</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The function has no parameters, so I can&#39;t guess which one you want to wrap&quot;</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_bound</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">_first_param_is_an_instance_param</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">transparent_key_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">k</span>


<div class="viewcode-block" id="mk_kv_reader_from_kv_collection">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.mk_kv_reader_from_kv_collection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mk_kv_reader_from_kv_collection</span><span class="p">(</span>
    <span class="n">kv_collection</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">getitem</span><span class="o">=</span><span class="n">transparent_key_method</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a KvReader class from a Collection class.</span>

<span class="sd">    Args:</span>
<span class="sd">        kv_collection: The Collection class</span>
<span class="sd">        name: The name to give the KvReader class (by default, it will be kv_collection.__qualname__ + &#39;Reader&#39;)</span>
<span class="sd">        getitem: The method that will be assigned to __getitem__. Should have the (self, k) signature.</span>
<span class="sd">            By default, getitem will be transparent_key_method, returning the key as is.</span>
<span class="sd">            This default is useful when you want to delegate the actual getting to a _obj_of_data wrapper.</span>

<span class="sd">    Returns: A KvReader class that subclasses the input kv_collection</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">kv_collection</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;Reader&quot;</span>
    <span class="n">reader_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">kv_collection</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">),</span> <span class="p">{</span><span class="s2">&quot;__getitem__&quot;</span><span class="p">:</span> <span class="n">getitem</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">reader_cls</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">raise_disabled_error</span><span class="p">(</span><span class="n">functionality</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">disabled_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">functionality</span><span class="si">}</span><span class="s2"> is disabled&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">disabled_function</span>


<span class="k">def</span><span class="w"> </span><span class="nf">disable_delitem</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">):</span>
        <span class="n">o</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">raise_disabled_error</span><span class="p">(</span><span class="s2">&quot;deletion&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>


<span class="k">def</span><span class="w"> </span><span class="nf">disable_setitem</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>
        <span class="n">o</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">raise_disabled_error</span><span class="p">(</span><span class="s2">&quot;writing&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>


<span class="k">def</span><span class="w"> </span><span class="nf">mk_read_only</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">disable_delitem</span><span class="p">(</span><span class="n">disable_setitem</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>


<div class="viewcode-block" id="add_ipython_key_completions">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_ipython_key_completions">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_ipython_key_completions</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add tab completion that shows you the keys of the store.</span>
<span class="sd">    Note: ipython already adds local path listing automatically,</span>
<span class="sd">     so you&#39;ll still get those along with your valid store keys.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_ipython_key_completions_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">_ipython_key_completions_</span> <span class="o">=</span> <span class="n">_ipython_key_completions_</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span>
            <span class="n">store</span><span class="p">,</span>
            <span class="s2">&quot;_ipython_key_completions_&quot;</span><span class="p">,</span>
            <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">_ipython_key_completions_</span><span class="p">,</span> <span class="n">store</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">store</span></div>



<span class="kn">from</span><span class="w"> </span><span class="nn">dol.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">copy_attrs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dol.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">OverWritesNotAllowedError</span>


<span class="k">def</span><span class="w"> </span><span class="nf">disallow_overwrites</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">error_msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">disable_deletes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;store needs to be a type&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">OverWritesNotAllowedError</span><span class="p">(</span>
                    <span class="s2">&quot;key </span><span class="si">{}</span><span class="s2"> already exists and cannot be overwritten. &quot;</span>
                    <span class="s2">&quot;If you really want to write to that key, delete it before writing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">k</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>


<div class="viewcode-block" id="OverWritesNotAllowedMixin">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.OverWritesNotAllowedMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OverWritesNotAllowedMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin for only allowing a write to a key if they key doesn&#39;t already exist.</span>
<span class="sd">    Note: Should be before the persister in the MRO.</span>

<span class="sd">    &gt;&gt;&gt; class TestPersister(OverWritesNotAllowedMixin, dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; p = TestPersister()</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; #p[&#39;foo&#39;] = &#39;bar2&#39;  # will raise error</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;this value should not be stored&#39; # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    dol.errors.OverWritesNotAllowedError: key foo already exists and cannot be overwritten.</span>
<span class="sd">        If you really want to write to that key, delete it before writing</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;]  # foo is still bar</span>
<span class="sd">    &#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; del p[&#39;foo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;] = &#39;this value WILL be stored&#39;</span>
<span class="sd">    &gt;&gt;&gt; p[&#39;foo&#39;]</span>
<span class="sd">    &#39;this value WILL be stored&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrap</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># TODO: Consider moving to trans and making instances wrappable too</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">NoOverWritesClass</span><span class="p">(</span><span class="n">OverWritesNotAllowedMixin</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span> <span class="o">...</span>

        <span class="n">copy_attrs</span><span class="p">(</span><span class="n">NoOverWritesClass</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">NoOverWritesClass</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">OverWritesNotAllowedError</span><span class="p">(</span>
                <span class="s2">&quot;key </span><span class="si">{}</span><span class="s2"> already exists and cannot be overwritten. &quot;</span>
                <span class="s2">&quot;If you really want to write to that key, delete it before writing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">k</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>



<span class="c1"># TODO: Should replace wrapper=Store with wrapper=Store.wrap, to depend on a function,</span>
<span class="c1">#  not a class that has a ``wrap`` method. But need to first</span>
<span class="c1">#  investigate how wrap_kvs uses that argument to not break anything.</span>
<span class="c1"># TODO: It seems like at this point, we could merge store_decorator and _wrap_store</span>
<span class="c1">#  to dispose of the need for a separate class_trans_maker function and the body</span>
<span class="c1">#  of the decorators to be the smelly _wrap_store(class_trans_maker, locals(), ...)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_store</span><span class="p">(</span>
    <span class="n">class_trans_maker</span><span class="p">,</span>
    <span class="n">class_trans_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">wrapper_arg_name</span><span class="o">=</span><span class="s2">&quot;wrapper&quot;</span><span class="p">,</span>
    <span class="n">store_arg_name</span><span class="o">=</span><span class="s2">&quot;store&quot;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">class_trans_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">wrapper_arg_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">Store</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">class_trans_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">store_arg_name</span><span class="p">)</span>
    <span class="n">class_trans</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">class_trans_maker</span><span class="p">,</span> <span class="o">**</span><span class="n">class_trans_kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">class_trans</span><span class="o">=</span><span class="n">class_trans</span><span class="p">)</span>


<div class="viewcode-block" id="insert_hash_method">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.insert_hash_method">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">insert_hash_method</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">hash_method</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">id</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a store hashable using the specified ``hash_method``.</span>
<span class="sd">    Will add (or overwrite) a ``__hash__`` method to the store that uses the</span>
<span class="sd">    hash_method to hash the store and an ``__eq__`` method that compares the store to</span>
<span class="sd">    another based on the hash_method.</span>

<span class="sd">    The ``hash_method``, which will be used as the ``__hash__`` method of a class</span>
<span class="sd">    should return an integer value that represents the hash of the object.</span>
<span class="sd">    To remain sane, the hash value must be the same for an object every time the</span>
<span class="sd">    ``__hash__`` method is called during the lifetime of the object, and objects</span>
<span class="sd">    that compare equal (using the __eq__ method) must have the same hash value.</span>

<span class="sd">    It&#39;s also important that the hash function has the property of being deterministic</span>
<span class="sd">    and returning a hash value that is uniformly distributed across the range of</span>
<span class="sd">    possible integers for the given data. This is important for the hash table</span>
<span class="sd">    data structure to work efficiently.</span>

<span class="sd">    See `This issue &lt;https://github.com/i2mint/dol/issues/7&gt;`_ for further information.</span>

<span class="sd">    &gt;&gt;&gt; d = {1: 2}  # not hashable!</span>
<span class="sd">    &gt;&gt;&gt; dd = insert_hash_method(d)</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(hash(dd), int)  # now hashable!</span>

<span class="sd">    It looks the same:</span>

<span class="sd">    &gt;&gt;&gt; dd</span>
<span class="sd">    {1: 2}</span>

<span class="sd">    But don&#39;t be fooled: dd is not equal to the original ``d`` (since</span>
<span class="sd">    insert_hash_method``overwrote the ``__eq__`` method to compare based on the</span>
<span class="sd">    hash value):</span>

<span class="sd">    &gt;&gt;&gt; d == dd</span>
<span class="sd">    False</span>

<span class="sd">    But if you cast both to dicts and then compare, you&#39;ll be using the key and value</span>
<span class="sd">    based comparison of dicts, which makes these two equal.</span>

<span class="sd">    &gt;&gt;&gt; dict(d) == dict(dd)</span>
<span class="sd">    True</span>

<span class="sd">    The default ``hash_method`` is ``id``, so two hashable wrappers won&#39;t be equal</span>
<span class="sd">    to eachother:</span>

<span class="sd">    &gt;&gt;&gt; insert_hash_method(d) == insert_hash_method(d)</span>
<span class="sd">    False</span>

<span class="sd">    In the following we show two things: That you can specify your own custom</span>
<span class="sd">    ``hash_method``, and that you can use ``insert_hash_method`` to wrap classes</span>

<span class="sd">    &gt;&gt;&gt; class D(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; DD = insert_hash_method(D, hash_method=lambda x: 42)</span>
<span class="sd">    &gt;&gt;&gt; hash(DD(d))</span>
<span class="sd">    42</span>

<span class="sd">    You can also use it as a decorator, without arguments,</span>

<span class="sd">    &gt;&gt;&gt; @insert_hash_method</span>
<span class="sd">    ... class E(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(hash(E({1: 2})), int)</span>

<span class="sd">    or with arguments (which you must specify as keyword arguments):</span>

<span class="sd">    &gt;&gt;&gt; @insert_hash_method(hash_method=lambda x: sum(x.values()))</span>
<span class="sd">    ... class F(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; hash(F({1: 2, 3: 4}))</span>
<span class="sd">    6</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrap_store</span><span class="p">(</span><span class="n">_insert_hash_method</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_is_hashable</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__hash__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_hash_method</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">hash_method</span><span class="p">):</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">hashable_cls</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A hashable wrapper to stores&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">hash_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">hash_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">hash_method</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hashable_cls</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Caching keys</span>


<span class="c1"># TODO: If a read-one-by-one (vs the current read all implementation) is necessary one day,</span>
<span class="c1">#   see https://github.com/zahlman/indexify/blob/master/src/indexify.py for ideas</span>
<span class="c1">#   but probably buffered (read by chunks) version of the later is better.</span>
<div class="viewcode-block" id="cached_keys">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.cached_keys">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">cached_keys</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">keys_cache</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="n">Collection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">iter_to_container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated: use keys_cache instead</span>
    <span class="n">cache_update_method</span><span class="o">=</span><span class="s2">&quot;update&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
    <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span> <span class="o">|</span> <span class="n">KvReader</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a class that wraps input class&#39;s __iter__ becomes cached.</span>

<span class="sd">    Quite often we have a lot of keys, that we get from a remote data source, and don&#39;t want to have to ask for</span>
<span class="sd">    them again and again, having them be fetched, sent over the network, etc.</span>
<span class="sd">    So we need caching.</span>

<span class="sd">    But this caching is not the typical read caching, since it&#39;s __iter__ we want to cache, and that&#39;s a generator.</span>
<span class="sd">    So we&#39;ll implement a store class decorator specialized for this.</span>

<span class="sd">    The following decorator, when applied to a class (that has an __iter__), will perform the __iter__ code, consuming</span>
<span class="sd">    all items of the generator and storing them in _keys_cache, and then will yield from there every subsequent call.</span>

<span class="sd">    It is assumed, if you&#39;re using the cached_keys transformation, that you&#39;re dealing with static data</span>
<span class="sd">    (or data that can be considered static for the life of the store -- for example, when conducting analytics).</span>
<span class="sd">    If you ever need to refresh the cache during the life of the store, you can to delete _keys_cache like this:</span>
<span class="sd">    ```</span>
<span class="sd">    del your_store._keys_cache</span>
<span class="sd">    ```</span>
<span class="sd">    Once you do that, the next time you try to ask something about the contents of the store, it will actually do</span>
<span class="sd">    a live query again, as for the first time.</span>

<span class="sd">    Note: The default keys_cache is list though in many cases, you&#39;d probably should use set, or an explicitly</span>
<span class="sd">    computer set instead. The reason list is used as the default is because (1) we didn&#39;t want to assume that</span>
<span class="sd">    order did not matter (maybe it does to you) and (2) we didn&#39;t want to assume that your keys were hashable.</span>
<span class="sd">    That said, if you&#39;re keys are hashable, and order does not matter, use set. That&#39;ll give you two things:</span>
<span class="sd">    (a) your `key in store` checks will be faster (O(1) instead of O(n)) and (b) you&#39;ll enforce unicity of keys.</span>

<span class="sd">    Know also that if you precompute the keys you want to cache with a container that has an update</span>
<span class="sd">    method (by default `update`) your cache updates will be faster and if the container you use has</span>
<span class="sd">    a `remove` method, you&#39;ll be able to delete as well.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store instance or class to wrap (must have an __iter__), or None if you want a decorator.</span>
<span class="sd">        keys_cache: An explicit collection of keys</span>
<span class="sd">        iter_to_container: The function that will be applied to existing __iter__() and assigned to cache.</span>
<span class="sd">            The default is list. Another useful one is the sorted function.</span>
<span class="sd">        cache_update_method: Name of the keys_cache update method to use, if it is an attribute of keys_cache.</span>
<span class="sd">            Note that this cache_update_method will be used only</span>
<span class="sd">                if keys_cache is an explicit iterable and has that attribute</span>
<span class="sd">                if keys_cache is a callable and has that attribute.</span>
<span class="sd">            The default None</span>
<span class="sd">        name: The name of the new class</span>

<span class="sd">    Returns:</span>
<span class="sd">        If store is:</span>
<span class="sd">            None: Will return a decorator that can be applied to a store</span>
<span class="sd">            a store class: Will return a wrapped class that caches it&#39;s keys</span>
<span class="sd">            a store instance: Will return a wrapped instance that caches it&#39;s keys</span>

<span class="sd">        The instances of such key-cached classes have some extra attributes:</span>
<span class="sd">            _explicit_keys: The actual cache. An iterable container</span>
<span class="sd">            update_keys_cache: Is called if a user uses the instance to mutate the store (i.e. write or delete).</span>

<span class="sd">    You have two ways of caching keys:</span>
<span class="sd">    - By providing the explicit list of keys you want cache (and use)</span>
<span class="sd">    - By providing a callable that will iterate through your store and collect an explicit list of keys</span>

<span class="sd">    Let&#39;s take a simple dict as our original store.</span>

<span class="sd">    &gt;&gt;&gt; source = dict(c=3, b=2, a=1)</span>

<span class="sd">    Specify an iterable, and it will be used as the cached keys</span>

<span class="sd">    &gt;&gt;&gt; cached = cached_keys(source, keys_cache=&#39;bc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(cached.items())  # notice that the order you get things is also ruled by the cache</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    Specify a callable, and it will apply it to the existing keys to make your cache</span>

<span class="sd">    &gt;&gt;&gt; list(cached_keys(source, keys_cache=sorted))</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    You can use the callable keys_cache specification to filter as well!</span>
<span class="sd">    Oh, and let&#39;s demo the fact that if you don&#39;t specify the store, it will make a store decorator for you:</span>

<span class="sd">    &gt;&gt;&gt; cache_my_keys = cached_keys(keys_cache=lambda keys: list(filter(lambda k: k &gt;= &#39;b&#39;, keys)))</span>
<span class="sd">    &gt;&gt;&gt; d = cache_my_keys(source)  # used as to transform an instance</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;c&#39;, &#39;b&#39;]</span>

<span class="sd">    Let&#39;s use that same `cache_my_keys` to decorate a class instead:</span>

<span class="sd">    &gt;&gt;&gt; cached_dict = cache_my_keys(dict)</span>
<span class="sd">    &gt;&gt;&gt; d = cached_dict(c=3, b=2, a=1)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;c&#39;, &#39;b&#39;]</span>

<span class="sd">    Note that there&#39;s still an underlying store (dict) that has the data:</span>

<span class="sd">    &gt;&gt;&gt; repr(d)  # repr isn&#39;t wrapped, so you can still see your underlying dict</span>
<span class="sd">    &quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 1}&quot;</span>

<span class="sd">    And yes, you can still add elements,</span>

<span class="sd">    &gt;&gt;&gt; d[&#39;z&#39;] = 26</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26)]</span>

<span class="sd">    do bulk updates,</span>

<span class="sd">    &gt;&gt;&gt; d.update({&#39;more&#39;: &#39;of this&#39;}, more_of=&#39;that&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more&#39;, &#39;of this&#39;), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    and delete...</span>

<span class="sd">    &gt;&gt;&gt; del d[&#39;more&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    But careful! Know what you&#39;re doing if you try to get creative. Have a look at this:</span>

<span class="sd">    &gt;&gt;&gt; d[&#39;a&#39;] = 100  # add an &#39;a&#39; item</span>
<span class="sd">    &gt;&gt;&gt; d.update(and_more=&#39;of that&#39;)  # update to add yet another item</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>

<span class="sd">    Indeed: No &#39;a&#39; or &#39;and_more&#39;.</span>

<span class="sd">    Now... they were indeed added. Or to be more precise, the value of the already existing a was changed,</span>
<span class="sd">    and a new (&#39;and_more&#39;, &#39;of that&#39;) item was indeed added in the underlying store:</span>

<span class="sd">    &gt;&gt;&gt; repr(d)</span>
<span class="sd">    &quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 100, &#39;z&#39;: 26, &#39;more_of&#39;: &#39;that&#39;, &#39;and_more&#39;: &#39;of that&#39;}&quot;</span>

<span class="sd">    But you&#39;re not seeing it.</span>

<span class="sd">    Why?</span>

<span class="sd">    Because you chose to use a callable keys_cache that doesn&#39;t have an &#39;update&#39; method.</span>
<span class="sd">    When your _keys_cache attribute (the iterable cache) is not updatable itself, the</span>
<span class="sd">    way updates work is that we iterate through the underlying store (where the updates actually took place),</span>
<span class="sd">    and apply the keys_cache (callable) to that iterable.</span>

<span class="sd">    So what happened here was that you have your new &#39;a&#39; and &#39;and_more&#39; items, but your cached version of the</span>
<span class="sd">    store doesn&#39;t see it because it&#39;s filtered out. On the other hand, check out what happens if you have</span>
<span class="sd">    an updateable cache.</span>

<span class="sd">    Using `set` instead of `list`, after the `filter`.</span>

<span class="sd">    &gt;&gt;&gt; cache_my_keys = cached_keys(keys_cache=set)</span>
<span class="sd">    &gt;&gt;&gt; d = cache_my_keys(source)  # used as to transform an instance</span>
<span class="sd">    &gt;&gt;&gt; sorted(d)  # using sorted because a set&#39;s order is not always the same</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;a&#39;] = 100</span>
<span class="sd">    &gt;&gt;&gt; d.update(and_more=&#39;of that&#39;)  # update to add yet another item</span>
<span class="sd">    &gt;&gt;&gt; sorted(d.items())</span>
<span class="sd">    [(&#39;a&#39;, 100), (&#39;and_more&#39;, &#39;of that&#39;), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    This example was to illustrate a more subtle aspect of cached_keys. You would probably deal with</span>
<span class="sd">    the filter concern in a different way in this case. But the rope is there -- it&#39;s your choice on how</span>
<span class="sd">    to use it.</span>

<span class="sd">    And here&#39;s some more examples if that wasn&#39;t enough!</span>

<span class="sd">    &gt;&gt;&gt; # Lets cache the keys of a dict.</span>
<span class="sd">    &gt;&gt;&gt; cached_dict = cached_keys(dict)</span>
<span class="sd">    &gt;&gt;&gt; d = cached_dict(a=1, b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; # And you get a store that behaves as expected (but more speed and RAM)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # whether you iterate with .keys(), .values(), or .items()</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>

<span class="sd">    This is where the keys are stored:</span>

<span class="sd">    &gt;&gt;&gt; d._keys_cache</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>

<span class="sd">    &gt;&gt;&gt; # Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=list)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be in the order they were defined</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=sorted)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=lambda x: sorted(x, key=len))</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;bbb&#39;: 3, &#39;aa&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted according to their length</span>
<span class="sd">    [&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>

<span class="sd">    If you change the keys (adding new ones with __setitem__ or update, or removing with pop or popitem)</span>
<span class="sd">    then the cache is recomputed (the first time you use an operation that iterates over keys)</span>

<span class="sd">    &gt;&gt;&gt; d.update(d=4)  # let&#39;s add an element (try d[&#39;d&#39;] = 4 as well)</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;e&#39;] = 5</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # whether you iterate with .keys(), .values(), or .items()</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)]</span>

<span class="sd">    &gt;&gt;&gt; @cached_keys</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     def __iter__(self):</span>
<span class="sd">    ...         yield from [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; # Note, could have also used this form: AA = cached_keys(A)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; list(a)</span>
<span class="sd">    [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; a._keys_cache = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  # changing the cache, to prove that subsequent listing will read from there</span>
<span class="sd">    &gt;&gt;&gt; list(a)  # proof:</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    &gt;&gt;&gt; # Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=list)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be in the order they were defined</span>
<span class="sd">    [&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=sorted)</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;b&#39;: 3, &#39;a&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_dict = cached_keys(dict, keys_cache=lambda x: sorted(x, key=len))</span>
<span class="sd">    &gt;&gt;&gt; s = sorted_dict({&#39;bbb&#39;: 3, &#39;aa&#39;: 2, &#39;c&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt; list(s)  # keys will be sorted according to their length</span>
<span class="sd">    [&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_wrap_store</span><span class="p">(</span>
        <span class="n">_cached_keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;Wrapped&quot;</span><span class="p">)</span>
    <span class="p">)</span></div>


    <span class="c1"># TODO: Replaced the following with the above:</span>
    <span class="c1"># arguments = {k: v for k, v in locals().items() if k != &#39;arguments&#39;}</span>
    <span class="c1"># store = arguments.pop(&#39;store&#39;)</span>
    <span class="c1"># class_trans = partial(_cached_keys, **arguments)</span>
    <span class="c1"># arguments[&#39;name&#39;] = arguments[&#39;name&#39;] or store.__qualname__ + &#39;Wrapped&#39;</span>
    <span class="c1">#</span>
    <span class="c1"># return Store.wrap(store, class_trans=class_trans)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cached_keys</span><span class="p">(</span>
    <span class="n">store</span><span class="p">,</span>
    <span class="n">keys_cache</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="n">Collection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">iter_to_container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated: use keys_cache instead</span>
    <span class="n">cache_update_method</span><span class="o">=</span><span class="s2">&quot;update&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
    <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="n">iter_to_container</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">iter_to_container</span><span class="p">)</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The argument name &#39;iter_to_container&#39; is being deprecated in favor &quot;</span>
            <span class="s2">&quot;of the more general &#39;keys_cache&#39;&quot;</span>
        <span class="p">)</span>
        <span class="c1"># assert keys_cache == iter_to_container</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;store_cls must be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># name = name or &#39;IterCached&#39; + get_class_name(store_cls)</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">get_class_name</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
    <span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">cached_cls</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
        <span class="n">_keys_cache</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

    <span class="c1"># cached_cls = type(name, (store_cls,), {&quot;_keys_cache&quot;: None})</span>

    <span class="c1"># The following class is not the class that will be returned, but the class from which we&#39;ll take the methods</span>
    <span class="c1">#   that will be copied in the class that will be returned.</span>
    <span class="c1"># @_define_keys_values_and_items_according_to_iter</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">CachedIterMethods</span><span class="p">:</span>
        <span class="n">_explicit_keys</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_updatable_cache</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">_iter_to_container</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">keys_cache</span><span class="p">,</span> <span class="n">cache_update_method</span><span class="p">):</span>
            <span class="n">_updatable_cache</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">is_iterable</span><span class="p">(</span>
            <span class="n">keys_cache</span>
        <span class="p">):</span>  <span class="c1"># if keys_cache is iterable, it is the cache instance itself.</span>
            <span class="n">_keys_cache</span> <span class="o">=</span> <span class="n">keys_cache</span>
            <span class="n">_explicit_keys</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">keys_cache</span><span class="p">):</span>
            <span class="c1"># if keys_cache is not iterable, but callable, we&#39;ll use it to make the keys_cache from __iter__</span>
            <span class="n">_iter_to_container</span> <span class="o">=</span> <span class="n">keys_cache</span>

            <span class="nd">@lazyprop</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># print(iter_to_container)</span>
                <span class="k">return</span> <span class="n">keys_cache</span><span class="p">(</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>
                <span class="p">)</span>  <span class="c1"># TODO: Should it be iter(super(...)?</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_iter_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># for back-compatibility</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The new name for `_iter_cache` is `_keys_cache`. Start using that!&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># If _keys_cache is None, then we haven&#39;t iterated yet, so we&#39;ll do it now.</span>
            <span class="c1"># This if clause was commmented out 3 years ago, and recently uncommented.</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_keys_cache&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span> <span class="o">=</span> <span class="n">keys_cache</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>

        <span class="c1"># The write and update stuff ###################################################################</span>

        <span class="k">if</span> <span class="n">_updatable_cache</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">update_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;updates the keys by calling the&quot;&quot;&quot;</span>
                <span class="n">update_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">cache_update_method</span><span class="p">)</span>
                <span class="n">update_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">keys</span><span class="p">)</span>

            <span class="n">update_keys_cache</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Updates the _keys_cache by calling its </span><span class="si">{}</span><span class="s2"> method&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">update_keys_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Updates the _keys_cache by deleting the attribute&quot;&quot;&quot;</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
                    <span class="c1"># print(&#39;deleted _keys_cache&#39;)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="c1"># self.store[k] = v</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span>
            <span class="p">):</span>  <span class="c1"># just to avoid deleting the cache if we already had the key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">((</span><span class="n">k</span><span class="p">,))</span>
                <span class="c1"># Note: different construction performances: (k,)-&gt;10ns, [k]-&gt;38ns, {k}-&gt;50ns</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="c1"># print(other, kwds)</span>
            <span class="c1"># super(cached_cls, self).update(other, **kwds)</span>
            <span class="n">super_setitem</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="p">:</span>
                <span class="c1"># print(k, other[k])</span>
                <span class="n">super_setitem</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="c1"># self.store[k] = other[k]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># print(k, v)</span>
                <span class="n">super_setitem</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="c1"># self.store[k] = v</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_keys_cache</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># And this is where we add all the needed methods (for example, no __setitem__ won&#39;t be added if the original</span>
    <span class="c1">#   class didn&#39;t have one in the first place.</span>
    <span class="n">special_attrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;update_keys_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_keys_cache&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_explicit_keys&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_updatable_cache&quot;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">special_attrs</span> <span class="o">|</span> <span class="p">(</span>
        <span class="n">AttrNames</span><span class="o">.</span><span class="n">KvPersister</span> <span class="o">&amp;</span> <span class="n">attrs_of</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">attrs_of</span><span class="p">(</span><span class="n">CachedIterMethods</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">cached_cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">CachedIterMethods</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>

    <span class="k">if</span> <span class="vm">__module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">):</span>
        <span class="n">cached_cls</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">return</span> <span class="n">cached_cls</span>


<span class="n">cache_iter</span> <span class="o">=</span> <span class="n">cached_keys</span>  <span class="c1"># TODO: Alias, partial it and make it more like the original, for back compatibility.</span>


<div class="viewcode-block" id="catch_and_cache_error_keys">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.catch_and_cache_error_keys">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">catch_and_cache_error_keys</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">errors_caught</span><span class="o">=</span><span class="ne">Exception</span><span class="p">,</span>
    <span class="n">error_callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">use_cached_keys_after_completed_iter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Store that will cache keys as they&#39;re accessed, separating those that raised errors and those that didn&#39;t.</span>
<span class="sd">    Getting a key will still through an error, but the access attempts will be collected in an ._error_keys attribute.</span>
<span class="sd">    Successfful attemps will be stored in _keys_cache.</span>
<span class="sd">    Retrieval iteration (items() or values()) will on the other hand, skip the error (while still caching it).</span>
<span class="sd">    If the iteration completes (and use_cached_keys_after_completed_iter), the use_cached_keys flag is turned on,</span>
<span class="sd">    which will result in the store now getting it&#39;s keys from the _keys_cache.</span>

<span class="sd">    &gt;&gt;&gt; @catch_and_cache_error_keys(</span>
<span class="sd">    ...     error_callback=lambda store, key, err: print(f&quot;Error with {key} key: {err}&quot;))</span>
<span class="sd">    ... class Blacklist(dict):</span>
<span class="sd">    ...     _black_list = {&#39;black&#39;, &#39;list&#39;}</span>
<span class="sd">    ...</span>
<span class="sd">    ...     def __getitem__(self, k):</span>
<span class="sd">    ...         if k not in self._black_list:</span>
<span class="sd">    ...             return super().__getitem__(k)</span>
<span class="sd">    ...         else:</span>
<span class="sd">    ...             raise KeyError(f&quot;Nope, that&#39;s from the black list!&quot;)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = Blacklist(black=7,  friday=20, frenzy=13)</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    [(&#39;friday&#39;, 20), (&#39;frenzy&#39;, 13)]</span>
<span class="sd">    &gt;&gt;&gt; sorted(s)  # sorting to get consistent output</span>
<span class="sd">    [&#39;frenzy&#39;, &#39;friday&#39;]</span>


<span class="sd">    See that? First we had three keys, then we iterated and got only 2 items (fortunately,</span>
<span class="sd">    we specified an ``error_callback`` so we ccould see that the iteration actually</span>
<span class="sd">    dropped a key).</span>

<span class="sd">    That&#39;s strange. And even stranger is the fact that when we list our keys again,</span>
<span class="sd">    we get only two.</span>

<span class="sd">    You don&#39;t like it? Neither do I. But</span>

<span class="sd">    - It&#39;s not a completely outrageous behavior -- if you&#39;re talking to live data, it</span>
<span class="sd">        often happens that you get more, or less, from one second to another.</span>

<span class="sd">    - This store isn&#39;t meant to be long living, but rather meant to solve the problem of</span>
<span class="sd">        skiping items that are problematic (for example, malformatted files),</span>
<span class="sd">        with a trace of what was skipped and what&#39;s valid (in case we need to iterate</span>
<span class="sd">        again and don&#39;t want to bear the hit of requesting values for keys we already</span>
<span class="sd">        know are problematic.</span>

<span class="sd">    Here&#39;s a little peep of what is happening under the hood.</span>
<span class="sd">    Meet ``_keys_cache`` and ``_error_keys`` sets (yes, unordered -- so know it) that are meant</span>
<span class="sd">    to acccumulate valid and problematic keys respectively.</span>

<span class="sd">    &gt;&gt;&gt; s = Blacklist(black=7,  friday=20, frenzy=13)</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    (set(), set())</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;friday&#39;]</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    ({&#39;friday&#39;}, set())</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;black&#39;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    KeyError: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    &gt;&gt;&gt; s._keys_cache, s._error_keys</span>
<span class="sd">    ({&#39;friday&#39;}, {&#39;black&#39;})</span>

<span class="sd">    But see that we still have the full list:</span>

<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>

<span class="sd">    Meet ``use_cached_keys``: He&#39;s the culprit. It&#39;s a flag that indicates whether</span>
<span class="sd">    we should be using the cached keys or not. Obviously, it&#39;ll start off being</span>
<span class="sd">    ``False``:</span>

<span class="sd">    &gt;&gt;&gt; s.use_cached_keys</span>
<span class="sd">    False</span>

<span class="sd">    Now we could set it to ``True`` manually to change the mode.</span>
<span class="sd">    But know that this switch happens automatically (UNLESS you specify otherwise by</span>
<span class="sd">    saying:``use_cached_keys_after_completed_iter=False``) when ever you got through a</span>
<span class="sd">    VALUE-PRODUCING iteration (i.e. entirely consuming `items()` or `values()`).</span>

<span class="sd">    &gt;&gt;&gt; sorted(s.values())  # sorting to get consistent output</span>
<span class="sd">    Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="sd">    [13, 20]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;store_cls must be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="c1"># assert isinstance(store, Mapping), f&quot;store_cls must be a Mapping.</span>
    <span class="c1">#  Was not. mro is {store.mro()}: {store}&quot;</span>

    <span class="c1"># class cached_cls(store):</span>
    <span class="c1">#     _keys_cache = None</span>
    <span class="c1">#     _error_keys = None</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">dol.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">MappingViewMixin</span>

    <span class="c1"># The following class is not the class that will be returned,</span>
    <span class="c1">#   but the class from which we&#39;ll take the methods</span>
    <span class="c1">#   that will be copied in the class that will be returned.</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">CachedKeyErrorsStore</span><span class="p">(</span><span class="n">MappingViewMixin</span><span class="p">,</span> <span class="n">store</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_error_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys_after_completed_iter</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">use_cached_keys_after_completed_iter</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors_caught</span> <span class="o">=</span> <span class="n">errors_caught</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_callback</span> <span class="o">=</span> <span class="n">error_callback</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">v</span>
                <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors_caught</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_error_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="c1"># if self.error_callback is not None:</span>
                    <span class="c1">#     self.error_callback(store, k, err)</span>
                    <span class="k">raise</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># if getattr(self, &#39;_keys_cache&#39;, None) is None:</span>
            <span class="c1">#    self._keys_cache = iter_to_container(super(cached_cls, self).__iter__())</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys_after_completed_iter</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ItemsView</span><span class="p">(</span><span class="n">BaseKeysView</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">except</span> <span class="n">m</span><span class="o">.</span><span class="n">errors_caught</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">error_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">m</span><span class="o">.</span><span class="n">error_callback</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">use_cached_keys_after_completed_iter</span><span class="p">:</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">use_cached_keys</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">_keys_cache</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ValuesView</span><span class="p">(</span><span class="n">BaseValuesView</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapping</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cached_keys</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_cache</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">CachedKeyErrorsStore</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">iterate_values_and_accumulate_non_error_keys</span><span class="p">(</span>
    <span class="n">store</span><span class="p">,</span> <span class="n">cache_keys_here</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">errors_caught</span><span class="o">=</span><span class="ne">Exception</span><span class="p">,</span> <span class="n">error_callback</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">store</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">store</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">cache_keys_here</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">v</span>
        <span class="k">except</span> <span class="n">errors_caught</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">error_callback</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_callback</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Filtering iteration</span>


<span class="k">def</span><span class="w"> </span><span class="nf">take_everything</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="n">FiltFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>


<span class="c1"># Note: The full definition of filt_iter includes some attributes that will be added</span>
<span class="c1">#   to it below (seach for FiltIter.__dict__.items())</span>
<div class="viewcode-block" id="filt_iter">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.filt_iter">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filt_iter</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">filt</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="n">take_everything</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: might be able to be deprecated since included in store_decorator</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a wrapper that will transform a store (class or instance thereof) into a sub-store (i.e. subset of keys).</span>

<span class="sd">    Args:</span>
<span class="sd">        filt: A callable or iterable:</span>
<span class="sd">            callable: Boolean filter function. A func taking a key and and returns True iff the key should be included.</span>
<span class="sd">            iterable: The collection of keys you want to filter &quot;in&quot;</span>
<span class="sd">        name: The name to give the wrapped class</span>

<span class="sd">    Returns: A wrapper (that then needs to be applied to a store instance or class.</span>

<span class="sd">    &gt;&gt;&gt; filtered_dict = filt_iter(filt=lambda k: (len(k) % 2) == 1)(dict)  # keep only odd length keys</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = filtered_dict({&#39;a&#39;: 1, &#39;bb&#39;: object, &#39;ccc&#39;: &#39;a string&#39;, &#39;dddd&#39;: [1, 2]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; &#39;a&#39; in s  # True because odd (length) key</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; &#39;bb&#39; in s  # False because odd (length) key</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;, None) == None</span>
<span class="sd">    &gt;&gt;&gt; len(s)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [1, &#39;a string&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; s.get(&#39;a&#39;)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; assert s.get(&#39;bb&#39;) is None</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;x&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;), (&#39;x&#39;, 10)]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     s[&#39;xx&#39;] = &#39;not an odd key&#39;</span>
<span class="sd">    ...     raise ValueError(&quot;This should have failed&quot;)</span>
<span class="sd">    ... except KeyError:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_wrap_store</span><span class="p">(</span><span class="n">_filt_iter</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;Wrapped&quot;</span><span class="p">))</span></div>



<span class="c1"># TODO: Factor out the method injection pattern (e.g. __getitem__, __setitem__</span>
<span class="c1">#  and __delitem__ are nearly identical)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_filt_iter</span><span class="p">(</span><span class="n">store_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="vm">__module__</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;store_cls must be a type: </span><span class="si">{</span><span class="n">store_cls</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">filt</span><span class="p">):</span>  <span class="c1"># if filt is not a callable...</span>
        <span class="c1"># ... assume it&#39;s the collection of keys you want and make a filter function</span>
        <span class="c1"># to filter those &quot;in&quot;.</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">),</span> <span class="s2">&quot;filt should be a callable, or an iterable&quot;</span>
        <span class="n">keys_that_should_be_filtered_in</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_that_should_be_filtered_in</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="nb">filter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">())</span>

    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__iter__</span> <span class="o">=</span> <span class="fm">__iter__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="fm">__len__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__contains__</span> <span class="o">=</span> <span class="fm">__contains__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="s2">&quot;get&quot;</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">default</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="n">get</span> <span class="o">=</span> <span class="n">get</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">):</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">filt</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key not in store: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="fm">__delitem__</span>
    <span class="k">return</span> <span class="n">store_cls</span>


<div class="viewcode-block" id="filter_regex">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.filter_regex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_regex</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_search_func</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a filter that returns True if a string matches the given regex</span>

<span class="sd">    &gt;&gt;&gt; is_txt = filter_regex(r&#39;.*\.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_txt(&quot;test.txt&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_txt(&quot;report.doc&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">regex</span> <span class="o">=</span> <span class="n">safe_compile</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_search_func</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">regex</span><span class="o">.</span><span class="n">search</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pipe</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="n">pipe</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="n">regex</span>
        <span class="k">return</span> <span class="n">pipe</span></div>



<div class="viewcode-block" id="filter_suffixes">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.filter_suffixes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_suffixes</span><span class="p">(</span><span class="n">suffixes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a filter that returns True if a string ends with one of the given suffixes</span>

<span class="sd">    &gt;&gt;&gt; ends_with_txt = filter_suffixes(&#39;.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ends_with_txt(&quot;test.txt&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ends_with_txt(&quot;report.doc&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_text = filter_suffixes([&#39;.txt&#39;, &#39;.doc&#39;, &#39;.pdf&#39;])</span>
<span class="sd">    &gt;&gt;&gt; is_text(&quot;test.txt&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_text(&quot;report.doc&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_text(&quot;image.jpg&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">suffixes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">suffixes</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">filter_regex</span><span class="p">(</span><span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">suffixes</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span> <span class="o">+</span> <span class="s2">&quot;$&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="filter_prefixes">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.filter_prefixes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_prefixes</span><span class="p">(</span><span class="n">prefixes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a filter that returns True if a string starts with one of the given prefixes</span>

<span class="sd">    &gt;&gt;&gt; starts_with_test = filter_prefixes(&#39;test&#39;)</span>
<span class="sd">    &gt;&gt;&gt; starts_with_test(&quot;test.txt&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; starts_with_test(&quot;report.doc&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_test_or_report = filter_prefixes([&#39;test&#39;, &#39;report&#39;])</span>
<span class="sd">    &gt;&gt;&gt; is_test_or_report(&quot;test.txt&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_test_or_report(&quot;report.doc&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_test_or_report(&quot;image.jpg&quot;)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prefixes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[</span><span class="n">prefixes</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">filter_regex</span><span class="p">(</span><span class="s2">&quot;^&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="n">prefixes</span><span class="p">)))</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">FiltIter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This class is not meant to be instantiated, but only act as a collection &quot;</span>
            <span class="s2">&quot;of functions to make mapping filtering decorators.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">regex</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a mapping-filtering decorator that filters keys with a regex.</span>

<span class="sd">        :param regex: A regex string or compiled regex</span>

<span class="sd">        &gt;&gt;&gt; contains_a = FiltIter.regex(r&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;apple&#39;: 1, &#39;banana&#39;: 2, &#39;cherry&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; dd = contains_a(d)</span>
<span class="sd">        &gt;&gt;&gt; dict(dd)</span>
<span class="sd">        {&#39;apple&#39;: 1, &#39;banana&#39;: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">filt_iter</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="n">filter_regex</span><span class="p">(</span><span class="n">regex</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">prefixes</span><span class="p">(</span><span class="n">prefixes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a mapping-filtering decorator that filters keys with a prefixes.</span>

<span class="sd">        :param prefixes: A string or iterable of strings that are the prefixes to filter</span>

<span class="sd">        &gt;&gt;&gt; is_test = FiltIter.prefixes(&#39;test&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;test.txt&#39;: 1, &#39;report.doc&#39;: 2, &#39;test_image.jpg&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; dd = is_test(d)</span>
<span class="sd">        &gt;&gt;&gt; dict(dd)</span>
<span class="sd">        {&#39;test.txt&#39;: 1, &#39;test_image.jpg&#39;: 3}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">filt_iter</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="n">filter_prefixes</span><span class="p">(</span><span class="n">prefixes</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">suffixes</span><span class="p">(</span><span class="n">suffixes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a mapping-filtering decorator that filters keys with a suffixes.</span>

<span class="sd">        :param suffixes: A string or iterable of strings that are the suffixes to filter</span>

<span class="sd">        &gt;&gt;&gt; is_text = FiltIter.suffixes([&#39;.txt&#39;, &#39;.doc&#39;, &#39;.pdf&#39;])</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;test.txt&#39;: 1, &#39;report.doc&#39;: 2, &#39;image.jpg&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; dd = is_text(d)</span>
<span class="sd">        &gt;&gt;&gt; dict(dd)</span>
<span class="sd">        {&#39;test.txt&#39;: 1, &#39;report.doc&#39;: 2}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">filt_iter</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="n">filter_suffixes</span><span class="p">(</span><span class="n">suffixes</span><span class="p">))</span>


<span class="c1"># TODO: Is there a better way to solve the tab-completion problem</span>
<span class="c1"># Here we add attributes to filt_iter via explicit statements assigning to None before</span>
<span class="c1"># looping through FilterIter and adding the actual functions, because Tab-completion</span>
<span class="c1"># wasn&#39;t working with the loop alone</span>
<span class="n">filt_iter</span><span class="o">.</span><span class="n">regex</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">filt_iter</span><span class="o">.</span><span class="n">prefixes</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">filt_iter</span><span class="o">.</span><span class="n">suffixes</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># add all the functions in FiltIter as attributes of filt_iter, so they&#39;re ready to use</span>
<span class="k">for</span> <span class="n">filt_name</span><span class="p">,</span> <span class="n">filt_func</span> <span class="ow">in</span> <span class="n">FiltIter</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">filt_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
        <span class="c1"># filt_func.__name__ = filt_name</span>
        <span class="n">filt_func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span><span class="n">filt_func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;FiltIter&quot;</span><span class="p">,</span> <span class="s2">&quot;filt_iter&quot;</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">filt_iter</span><span class="p">,</span> <span class="n">filt_name</span><span class="p">,</span> <span class="n">filt_func</span><span class="p">)</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Wrapping keys and values</span>

<span class="n">self_names</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">([</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="s2">&quot;mapping&quot;</span><span class="p">])</span>


<span class="c1"># TODO: Consider deprecation. Besides the name arg (whose usefulness is doubtful), this is just Store.wrap</span>
<div class="viewcode-block" id="kv_wrap_persister_cls">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.kv_wrap_persister_cls">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">persister_cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a class that wraps a persister into a dol.base.Store,</span>

<span class="sd">    Args:</span>
<span class="sd">        persister_cls: The persister class to wrap</span>

<span class="sd">    Returns: A Store wrapping the persister (see dol.base)</span>

<span class="sd">    &gt;&gt;&gt; A = kv_wrap_persister_cls(dict)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;one&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;two&#39;] = 2</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;three&#39;] = 3</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())</span>
<span class="sd">    [(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)]</span>
<span class="sd">    &gt;&gt;&gt; assert hasattr(a, &#39;_obj_of_data&#39;)  # for example, it has this magic method</span>
<span class="sd">    &gt;&gt;&gt; # If you overwrite the _obj_of_data method, you&#39;ll transform outcomming values with it.</span>
<span class="sd">    &gt;&gt;&gt; # For example, say the data you stored were minutes, but you want to get then in secs...</span>
<span class="sd">    &gt;&gt;&gt; a._obj_of_data = lambda data: data * 60</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # And if you want to have class that has this weird &quot;store minutes, retrieve seconds&quot;, you can do this:</span>
<span class="sd">    &gt;&gt;&gt; class B(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     def _obj_of_data(self, data):</span>
<span class="sd">    ...         return data * 60</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt; b.update({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})  # you can write several key-value pairs at once this way!</span>
<span class="sd">    &gt;&gt;&gt; list(b.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; # Warning! Advanced under-the-hood chat coming up.... Note this:</span>
<span class="sd">    &gt;&gt;&gt; print(b)</span>
<span class="sd">    {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # What?!? Well, remember, printing an object calls the objects __str__, which usually calls __repr__</span>
<span class="sd">    &gt;&gt;&gt; # The wrapper doesn&#39;t wrap those methods, since they don&#39;t have consistent behaviors.</span>
<span class="sd">    &gt;&gt;&gt; # Here you&#39;re getting the __repr__ of the underlying dict store, without the key and value transforms.</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Say you wanted to transform the incoming minute-unit data, converting to secs BEFORE they were stored...</span>
<span class="sd">    &gt;&gt;&gt; class C(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     def _data_of_obj(self, obj):</span>
<span class="sd">    ...         return obj * 60</span>
<span class="sd">    &gt;&gt;&gt; c = C()</span>
<span class="sd">    &gt;&gt;&gt; c.update(one=1, two=2, three=3)  # yet another way you can write multiple key-vals at once</span>
<span class="sd">    &gt;&gt;&gt; list(c.items())</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; print(c)  # but notice that unlike when we printed b, here the stored data is actually transformed!</span>
<span class="sd">    {&#39;one&#39;: 60, &#39;two&#39;: 120, &#39;three&#39;: 180}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Now, just to demonstrate key transformation, let&#39;s say that we need internal (stored) keys to be upper case,</span>
<span class="sd">    &gt;&gt;&gt; # but external (the keys you see when listed) ones to be lower case, for some reason...</span>
<span class="sd">    &gt;&gt;&gt; class D(kv_wrap_persister_cls(dict)):</span>
<span class="sd">    ...     _data_of_obj = staticmethod(lambda obj: obj * 60)  # to demonstrated another way of doing this</span>
<span class="sd">    ...     _key_of_id = lambda self, _id: _id.lower()  # note if you don&#39;t specify staticmethod, 1st arg must be self</span>
<span class="sd">    ...     def _id_of_key(self, k):  # a function definition like you&#39;re used to</span>
<span class="sd">    ...         return k.upper()</span>
<span class="sd">    &gt;&gt;&gt; d = D()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;oNe&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; d.update(TwO=2, tHrEE=3)</span>
<span class="sd">    &gt;&gt;&gt; list(d.items())  # you see clean lower cased keys at the interface of the store</span>
<span class="sd">    [(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="sd">    &gt;&gt;&gt; # but internally, the keys are all upper case</span>
<span class="sd">    &gt;&gt;&gt; print(d)  # equivalent to print(d.store), so keys and values not wrapped (values were transformed before stored)</span>
<span class="sd">    {&#39;ONE&#39;: 60, &#39;TWO&#39;: 120, &#39;THREE&#39;: 180}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # On the other hand, careful, if you gave the data directly to D, you wouldn&#39;t get that.</span>
<span class="sd">    &gt;&gt;&gt; d = D({&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt; print(d)</span>
<span class="sd">    {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # Thus is because when you construct a D with the dict, it initializes the dicts data with it directly</span>
<span class="sd">    &gt;&gt;&gt; # before the key/val transformers are in place to do their jobs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="bp">cls</span> <span class="o">=</span> <span class="n">Store</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">persister_cls</span><span class="p">)</span>

    <span class="c1"># TODO: The whole name and qualname thing -- is it really necessary, correct, what we want?</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="p">(</span><span class="n">persister_cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;PWrapped&quot;</span><span class="p">)</span>
    <span class="n">qname</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="p">(</span><span class="n">persister_cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;PWrapped&quot;</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">qname</span>
    <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">return</span> <span class="bp">cls</span></div>


    <span class="c1"># name = name or (persister_cls.__qualname__ + &quot;PWrapped&quot;)</span>
    <span class="c1">#</span>
    <span class="c1"># cls = type(name, (Store,), {})</span>
    <span class="c1">#</span>
    <span class="c1"># # TODO: Investigate sanity and alternatives (cls = type(name, (Store, persister_cls), {}) leads to MRO problems)</span>
    <span class="c1"># for attr in set(dir(persister_cls)) - set(dir(Store)):</span>
    <span class="c1">#     persister_cls_attribute = getattr(persister_cls, attr)</span>
    <span class="c1">#     setattr(cls, attr, persister_cls_attribute)  # copy the attribute over to cls</span>
    <span class="c1">#</span>
    <span class="c1"># if hasattr(persister_cls, &#39;__doc__&#39;):</span>
    <span class="c1">#     cls.__doc__ = persister_cls.__doc__</span>
    <span class="c1">#</span>
    <span class="c1"># @wraps(persister_cls.__init__)</span>
    <span class="c1"># def __init__(self, *args, **kwargs):</span>
    <span class="c1">#     super(cls, self).__init__(persister_cls(*args, **kwargs))</span>
    <span class="c1">#</span>
    <span class="c1"># cls.__init__ = __init__</span>
    <span class="c1">#</span>
    <span class="c1"># return cls</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_outcoming</span><span class="p">(</span>
    <span class="n">store_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trans_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Output-transforming wrapping of the wrapped_method of store_cls.</span>
<span class="sd">    The transformation is given by trans_func, which could be a one (trans_func(x)</span>
<span class="sd">    or two (trans_func(self, x)) argument function.</span>

<span class="sd">    Args:</span>
<span class="sd">        store_cls: The class that will be transformed</span>
<span class="sd">        wrapped_method: The method (name) that will be transformed.</span>
<span class="sd">        trans_func: The transformation function.</span>
<span class="sd">        wrap_arg_idx: The index of the</span>

<span class="sd">    Returns: Nothing. It transforms the class in-place</span>

<span class="sd">    &gt;&gt;&gt; from dol.trans import store_wrap</span>
<span class="sd">    &gt;&gt;&gt; S = store_wrap(dict)</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, lambda x: f&#39;wrapped_{x}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, lambda self, x: f&#39;wrapped_{x}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2}); assert list(s) == [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, prefix=&#39;wrapped_&#39;):</span>
<span class="sd">    ...         self.prefix = prefix</span>
<span class="sd">    ...     def _key_of_id(self, x):</span>
<span class="sd">    ...         return self.prefix + x</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_key_of_id&#39;, A(prefix=&#39;wrapped_&#39;)._key_of_id)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2}); assert list(s) == [&#39;wrapped_a&#39;, &#39;wrapped_b&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; S = store_wrap(dict)</span>
<span class="sd">    &gt;&gt;&gt; _wrap_outcoming(S, &#39;_obj_of_data&#39;, lambda x: x * 7)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;a&#39;: 1, &#39;b&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [7, 14]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapped_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
            <span class="c1"># print(f&quot;00000: {store_cls}: {wrapped_method}, {trans_func}, {wrapped_func}, {wrap_arg_idx}&quot;)</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="c1"># # Long form (for explanation)</span>
                <span class="c1"># super_method = getattr(super(store_cls, self), wrapped_method)</span>
                <span class="c1"># output_of_super_method = super_method(x)</span>
                <span class="c1"># transformed_output_of_super_method = trans_func(output_of_super_method)</span>
                <span class="c1"># return transformed_output_of_super_method</span>
                <span class="k">return</span> <span class="n">trans_func</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(f&quot;11111: {store_cls}: {wrapped_method}, {trans_func}, {wrapped_func}, {wrap_arg_idx}&quot;)</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="c1"># # Long form (for explanation)</span>
                <span class="c1"># super_method = getattr(super(store_cls, self), wrapped_method)</span>
                <span class="c1"># output_of_super_method = super_method(x)</span>
                <span class="c1"># transformed_output_of_super_method = trans_func(self, output_of_super_method)</span>
                <span class="c1"># return transformed_output_of_super_method</span>
                <span class="k">return</span> <span class="n">trans_func</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_ingoing</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">trans_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wrapped_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span><span class="n">trans_func</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped_func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">new_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="n">wrapped_method</span><span class="p">)(</span>
                    <span class="n">trans_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">new_method</span><span class="p">)</span>


<div class="viewcode-block" id="wrap_kvs">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.wrap_kvs">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">wrap_kvs</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">wrapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_of_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_of_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">obj_of_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data_of_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">preset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">postget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_codec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">value_codec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">key_decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">value_encoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">value_decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">outcoming_key_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">outcoming_value_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">ingoing_key_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">ingoing_value_methods</span><span class="o">=</span><span class="p">(),</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Make a Store that is wrapped with the given key/val transformers.</span>

<span class="sd">    Naming convention:</span>
<span class="sd">        Morphemes:</span>
<span class="sd">            key: outer key</span>
<span class="sd">            _id: inner key</span>
<span class="sd">            obj: outer value</span>
<span class="sd">            data: inner value</span>
<span class="sd">        Grammar:</span>
<span class="sd">            Y_of_X: means that you get a Y output when giving an X input. Also known as X_to_Y.</span>


<span class="sd">    Args:</span>
<span class="sd">        store: Store class or instance</span>
<span class="sd">        name: Name to give the wrapper class</span>
<span class="sd">        key_of_id: The outcoming key transformation function.</span>
<span class="sd">            Forms are `k = key_of_id(_id)` or `k = key_of_id(self, _id)`</span>
<span class="sd">        id_of_key: The ingoing key transformation function.</span>
<span class="sd">            Forms are `_id = id_of_key(k)` or `_id = id_of_key(self, k)`</span>
<span class="sd">        obj_of_data: The outcoming val transformation function.</span>
<span class="sd">            Forms are `obj = obj_of_data(data)` or `obj = obj_of_data(self, data)`</span>
<span class="sd">        data_of_obj: The ingoing val transformation function.</span>
<span class="sd">            Forms are `data = data_of_obj(obj)` or `data = data_of_obj(self, obj)`</span>
<span class="sd">        preset: A function that is called before doing a `__setitem__`.</span>
<span class="sd">            The function is called with both `k` and `v` as inputs, and should output a transformed value.</span>
<span class="sd">            The intent use is to do ingoing value transformations conditioned on the key.</span>
<span class="sd">            For example, you may want to serialize an object depending on if you&#39;re writing to a</span>
<span class="sd">             &#39;.csv&#39;, or &#39;.json&#39;, or &#39;.pickle&#39; file.</span>
<span class="sd">            Forms are `preset(k, obj)` or `preset(self, k, obj)`</span>
<span class="sd">        postget: A function that is called after the value `v` for a key `k` is be `__getitem__`.</span>
<span class="sd">            The function is called with both `k` and `v` as inputs, and should output a transformed value.</span>
<span class="sd">            The intent use is to do outcoming value transformations conditioned on the key.</span>
<span class="sd">            We already have `obj_of_data` for outcoming value trans, but cannot condition it&#39;s behavior on k.</span>
<span class="sd">            For example, you may want to deserialize the bytes of a &#39;.csv&#39;, or &#39;.json&#39;, or &#39;.pickle&#39; in different ways.</span>
<span class="sd">            Forms are `obj = postget(k, data)` or `obj = postget(self, k, data)`</span>

<span class="sd">    Returns: A key and/or value transformed wrapped (or wrapper) class (or instance).</span>

<span class="sd">    &gt;&gt;&gt; def key_of_id(_id):</span>
<span class="sd">    ...     return _id.upper()</span>
<span class="sd">    &gt;&gt;&gt; def id_of_key(k):</span>
<span class="sd">    ...     return k.lower()</span>
<span class="sd">    &gt;&gt;&gt; def obj_of_data(data):</span>
<span class="sd">    ...     return data - 100</span>
<span class="sd">    &gt;&gt;&gt; def data_of_obj(obj):</span>
<span class="sd">    ...     return obj + 100</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; A = wrap_kvs(dict, name=&#39;A&#39;,</span>
<span class="sd">    ...             key_of_id=key_of_id, id_of_key=id_of_key, obj_of_data=obj_of_data, data_of_obj=data_of_obj)</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;KEY&#39;] = 1</span>
<span class="sd">    &gt;&gt;&gt; a  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 101}</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;key&#39;] = 2</span>
<span class="sd">    &gt;&gt;&gt; print(a)  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 102}</span>
<span class="sd">    &gt;&gt;&gt; a[&#39;kEy&#39;] = 3</span>
<span class="sd">    &gt;&gt;&gt; a  # repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="sd">    {&#39;key&#39;: 103}</span>
<span class="sd">    &gt;&gt;&gt; list(a)  # but from the point of view of the interface the keys are all upper case</span>
<span class="sd">    [&#39;KEY&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(a.items())  # and the values are those we put there.</span>
<span class="sd">    [(&#39;KEY&#39;, 3)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # And now this: Showing how to condition the value transform (like obj_of_data), but conditioned on key.</span>
<span class="sd">    &gt;&gt;&gt; B = wrap_kvs(dict, name=&#39;B&#39;, postget=lambda k, v: f&#39;upper {v}&#39; if k[0].isupper() else f&#39;lower {v}&#39;)</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt; b[&#39;BIG&#39;] = &#39;letters&#39;</span>
<span class="sd">    &gt;&gt;&gt; b[&#39;small&#39;] = &#39;text&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(b.items())</span>
<span class="sd">    [(&#39;BIG&#39;, &#39;upper letters&#39;), (&#39;small&#39;, &#39;lower text&#39;)]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Let&#39;s try preset and postget. We&#39;ll wrap a dict and write the same list of lists object to</span>
<span class="sd">    &gt;&gt;&gt; # keys ending with .csv, .json, and .pkl, specifying the obvious extension-dependent</span>
<span class="sd">    &gt;&gt;&gt; # serialization/deserialization we want to associate with it.</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # First, some very simple csv transformation functions</span>
<span class="sd">    &gt;&gt;&gt; to_csv = lambda LoL: &#39;\\n&#39;.join(map(&#39;,&#39;.join, map(lambda L: (x for x in L), LoL)))</span>
<span class="sd">    &gt;&gt;&gt; from_csv = lambda csv: list(map(lambda x: x.split(&#39;,&#39;), csv.split(&#39;\\n&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; LoL = [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; assert from_csv(to_csv(LoL)) == LoL</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; import json, pickle</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def preset(k, v):</span>
<span class="sd">    ...     if k.endswith(&#39;.csv&#39;):</span>
<span class="sd">    ...         return to_csv(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.json&#39;):</span>
<span class="sd">    ...         return json.dumps(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.pkl&#39;):</span>
<span class="sd">    ...         return pickle.dumps(v)</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return v  # as is</span>
<span class="sd">    ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def postget(k, v):</span>
<span class="sd">    ...     if k.endswith(&#39;.csv&#39;):</span>
<span class="sd">    ...         return from_csv(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.json&#39;):</span>
<span class="sd">    ...         return json.loads(v)</span>
<span class="sd">    ...     elif k.endswith(&#39;.pkl&#39;):</span>
<span class="sd">    ...         return pickle.loads(v)</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return v  # as is</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; mydict = wrap_kvs(dict, preset=preset, postget=postget)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; obj = [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;],[&#39;d&#39;,&#39;e&#39;,&#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d = mydict()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.csv&#39;] = obj  # store the object as csv</span>
<span class="sd">    &gt;&gt;&gt; d  # &quot;printing&quot; a dict by-passes the transformations, so we see the data in the &quot;raw&quot; format it is stored in.</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;}</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.csv&#39;]  # but if we actually ask for the data, it deserializes to our original object</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;] = obj  # store the object as json</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]]&#39;}</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;]</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;bar.json&#39;] = {&#39;a&#39;: 1, &#39;b&#39;: [1, 2], &#39;c&#39;: &#39;normal json&#39;}  # let&#39;s write a normal json instead.</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;{&quot;a&quot;: 1, &quot;b&quot;: [1, 2], &quot;c&quot;: &quot;normal json&quot;}&#39;}</span>
<span class="sd">    &gt;&gt;&gt; del d[&#39;foo.csv&#39;]</span>
<span class="sd">    &gt;&gt;&gt; del d[&#39;bar.json&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.pkl&#39;] = obj  # &#39;save&#39; obj as pickle</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;foo.pkl&#39;]</span>
<span class="sd">    [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>

<span class="sd">    # TODO: Add tests for outcoming_key_methods etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># kwargs = dict(</span>
    <span class="c1">#     locals(), wrapper=wrapper or Store, name=store.__qualname__ + &quot;Wrapped&quot;</span>
    <span class="c1"># )</span>
    <span class="c1"># If name is not explicitly provided, use the store&#39;s qualname directly</span>
    <span class="c1"># without adding &quot;Wrapped&quot; to preserve the original class name</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span>

    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="n">wrapper</span><span class="o">=</span><span class="n">wrapper</span> <span class="ow">or</span> <span class="n">Store</span><span class="p">)</span>
    <span class="n">_handle_codecs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_store</span><span class="p">(</span><span class="n">_wrap_kvs</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_handle_codecs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Handle the key_codec and data_codec kwargs, converting them to key_of_id</span>
<span class="sd">    and obj_of_data.</span>

<span class="sd">    Warning: Mutates kwargs in place.</span>

<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;value_decoder&#39;: int, &#39;value_encoder&#39;: str}</span>
<span class="sd">    &gt;&gt;&gt; _handle_codecs(kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert kwargs[&#39;obj_of_data&#39;] == int</span>
<span class="sd">    &gt;&gt;&gt; assert kwargs[&#39;data_of_obj&#39;] == str</span>
<span class="sd">    &gt;&gt;&gt; from types import SimpleNamespace</span>
<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;key_codec&#39;: SimpleNamespace(decoder=int, encoder=str)}</span>
<span class="sd">    &gt;&gt;&gt; _handle_codecs(kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert kwargs[&#39;key_of_id&#39;] == int</span>
<span class="sd">    &gt;&gt;&gt; assert kwargs[&#39;id_of_key&#39;] == str</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">key_codec</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key_codec&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both key_codec and key_of_id&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_codec</span><span class="o">.</span><span class="n">decoder</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id_of_key&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both key_codec and id_of_key&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;id_of_key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_codec</span><span class="o">.</span><span class="n">encoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_codec&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">value_codec</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;value_codec&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_of_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both value_codec and obj_of_data&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;obj_of_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_codec</span><span class="o">.</span><span class="n">decoder</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_of_obj&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both value_codec and data_of_obj&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data_of_obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_codec</span><span class="o">.</span><span class="n">encoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;value_codec&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">key_decoder</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key_decoder&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both key_decoder and key_of_id&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_of_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_decoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_decoder&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">key_encoder</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;key_encoder&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id_of_key&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both key_encoder and id_of_key&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;id_of_key&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_encoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;key_encoder&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">value_decoder</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;value_decoder&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;obj_of_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both value_decoder and obj_of_data&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;obj_of_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_decoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;value_decoder&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">value_encoder</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;value_encoder&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;data_of_obj&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both value_encoder and data_of_obj&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data_of_obj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_encoder</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;value_encoder&quot;</span><span class="p">]</span>


<span class="c1"># TODO: Below is more general and clean, but breaks tests. Fix tests and use this.</span>
<span class="c1"># def _handle_codecs(kwargs: dict):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Handle the key_codec, data_codec, key_decoder, key_encoder, value_decoder, and value_encoder</span>
<span class="c1">#     kwargs, converting them to key_of_id, obj_of_data, id_of_key, and data_of_obj respectively.</span>

<span class="c1">#     Warning: Mutates kwargs in place.</span>

<span class="c1">#     &gt;&gt;&gt; kwargs = {&#39;value_decoder&#39;: int, &#39;value_encoder&#39;: str}</span>
<span class="c1">#     &gt;&gt;&gt; _handle_codecs(kwargs)</span>
<span class="c1">#     &gt;&gt;&gt; assert kwargs[&#39;obj_of_data&#39;] == int</span>
<span class="c1">#     &gt;&gt;&gt; assert kwargs[&#39;data_of_obj&#39;] == str</span>
<span class="c1">#     &gt;&gt;&gt; from types import SimpleNamespace</span>
<span class="c1">#     &gt;&gt;&gt; kwargs = {&#39;key_codec&#39;: SimpleNamespace(decoder=int, encoder=str)}</span>
<span class="c1">#     &gt;&gt;&gt; _handle_codecs(kwargs)</span>
<span class="c1">#     &gt;&gt;&gt; assert kwargs[&#39;key_of_id&#39;] == int</span>
<span class="c1">#     &gt;&gt;&gt; assert kwargs[&#39;id_of_key&#39;] == str</span>

<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     from operator import attrgetter</span>

<span class="c1">#     def handle_replacements(source_key, target_keys_and_extractors):</span>
<span class="c1">#         for target_key, extractor in target_keys_and_extractors.items():</span>
<span class="c1">#             if target_key in kwargs:</span>
<span class="c1">#                 raise ValueError(f&#39;Cannot specify both {source_key} and {target_key}&#39;)</span>
<span class="c1">#             kwargs[target_key] = extractor(kwargs[source_key])</span>

<span class="c1">#     replacements = {</span>
<span class="c1">#         &#39;key_codec&#39;: {&#39;key_of_id&#39;: attrgetter(&#39;decoder&#39;), &#39;id_of_key&#39;: attrgetter(&#39;encoder&#39;)},</span>
<span class="c1">#         &#39;value_codec&#39;: {&#39;obj_of_data&#39;: attrgetter(&#39;decoder&#39;), &#39;data_of_obj&#39;: attrgetter(&#39;encoder&#39;)},</span>
<span class="c1">#         &#39;key_decoder&#39;: {&#39;key_of_id&#39;: lambda x: x},</span>
<span class="c1">#         &#39;key_encoder&#39;: {&#39;id_of_key&#39;: lambda x: x},</span>
<span class="c1">#         &#39;value_decoder&#39;: {&#39;obj_of_data&#39;: lambda x: x},</span>
<span class="c1">#         &#39;value_encoder&#39;: {&#39;data_of_obj&#39;: lambda x: x},</span>
<span class="c1">#     }</span>

<span class="c1">#     for source_key, write_instructions in replacements.items():</span>
<span class="c1">#         if source_key in kwargs:</span>
<span class="c1">#             handle_replacements(source_key, write_instructions)</span>
<span class="c1">#             del kwargs[source_key]</span>


<div class="viewcode-block" id="add_decoder">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_decoder">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_decoder</span><span class="p">(</span><span class="n">store_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a decoder layer to a store.</span>

<span class="sd">    Note: This is a convenience function for ``wrap_kvs(..., obj_of_data=decoder)``.</span>

<span class="sd">    &gt;&gt;&gt; s = {&#39;a&#39;: &quot;42&quot;}</span>
<span class="sd">    &gt;&gt;&gt; ss = add_decoder(s, decoder=int)</span>
<span class="sd">    &gt;&gt;&gt; ss[&#39;a&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    If there&#39;s only one callable argument, it is assumed to be the decoder:</span>

<span class="sd">    &gt;&gt;&gt; wrapper = add_decoder(int)</span>
<span class="sd">    &gt;&gt;&gt; S = wrapper(dict)</span>
<span class="sd">    &gt;&gt;&gt; sss = S({&#39;a&#39;: &quot;42&quot;})</span>
<span class="sd">    &gt;&gt;&gt; dict(sss) == {&#39;a&#39;: 42}</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">decoder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">store_cls</span><span class="p">):</span>
            <span class="c1"># assume the first argument is the decoder and return a wrapper using it</span>
            <span class="k">return</span> <span class="n">add_decoder</span><span class="p">(</span><span class="n">decoder</span><span class="o">=</span><span class="n">store_cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If the decoder keyword is not given, the first argument must be the &quot;</span>
                <span class="s2">&quot;(callable) decoder&quot;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="n">decoder</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>



<div class="viewcode-block" id="FirstArgIsMapping">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.FirstArgIsMapping">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FirstArgIsMapping</span><span class="p">(</span><span class="n">LiteralVal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Literal class to mark a function as being one where the first argument is</span>
<span class="sd">    a mapping (store). This is intended to be used in wrappers such as ``wrap_kvs``</span>
<span class="sd">    to indicate when the first argument of a transformer function ``trans`` like</span>
<span class="sd">    ``key_of_id``, ``preset``, etc. is the store itself, therefore should be applied as</span>
<span class="sd">    ``trans(store, ...)`` instead of ``trans(...)``.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>


    <span class="c1"># TODO: Use this for it&#39;s intent!</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_kvs</span><span class="p">(</span>
    <span class="n">store_cls</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO: Remove when safe</span>
    <span class="n">key_of_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">id_of_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">obj_of_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">data_of_obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">preset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">postget</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="vm">__module__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">outcoming_key_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">outcoming_value_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">ingoing_key_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">ingoing_value_methods</span><span class="o">=</span><span class="p">(),</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_key_of_id&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">outcoming_key_methods</span><span class="p">):</span>
        <span class="n">_wrap_outcoming</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_obj_of_data&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">outcoming_value_methods</span><span class="p">):</span>
        <span class="n">_wrap_outcoming</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_id_of_key&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">ingoing_key_methods</span><span class="p">):</span>
        <span class="n">_wrap_ingoing</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">id_of_key</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;_data_of_obj&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ensure_set</span><span class="p">(</span><span class="n">ingoing_value_methods</span><span class="p">):</span>
        <span class="n">_wrap_ingoing</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="p">)</span>

    <span class="c1"># TODO: postget and preset uses num_of_args. Not robust:</span>
    <span class="c1">#  Should only count args with no defaults or partial won&#39;t be able to be used to make postget/preset funcs</span>
    <span class="c1"># TODO: Extract postget and preset patterns?</span>
    <span class="k">if</span> <span class="n">postget</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_of_args</span><span class="p">(</span><span class="n">postget</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A postget function needs to have (key, value) or (self, key, value) arguments&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">postget</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postget</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postget</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

    <span class="k">if</span> <span class="n">preset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">num_of_args</span><span class="p">(</span><span class="n">preset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A preset function needs to have (key, value) or (self, key, value) arguments&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_has_unbound_self</span><span class="p">(</span><span class="n">preset</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">preset</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">preset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

        <span class="n">store_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>

    <span class="k">if</span> <span class="vm">__module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">store_cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="vm">__module__</span>

    <span class="k">return</span> <span class="n">store_cls</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kv_wrap_outcoming_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform &#39;out-coming&#39; keys, that is, the keys you see when you ask for them,</span>
<span class="sd">    say, through __iter__(), keys(), or first element of the items() pairs.</span>

<span class="sd">    Use this when you wouldn&#39;t use the keys in their original format,</span>
<span class="sd">    or when you want to extract information from it.</span>

<span class="sd">    Warning: If you haven&#39;t also wrapped incoming keys with a corresponding inverse transformation,</span>
<span class="sd">    you won&#39;t be able to use the outcoming keys to fetch data.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.outcoming_keys(lambda x: x[5:])(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S({&#39;root/foo&#39;: 10, &#39;root/bar&#39;: &#39;xo&#39;})</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>

<span class="sd">    # TODO: Asymmetric key trans breaks getting items (therefore items()). Resolve (remove items() for asym keys?)</span>
<span class="sd">    # &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    # [(&#39;foo&#39;, 10), (&#39;bar&#39;, &#39;xo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_kr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">key_of_id</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kv_wrap_ingoing_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform &#39;in-going&#39; keys, that is, the keys you see when you ask for them,</span>
<span class="sd">    say, through __iter__(), keys(), or first element of the items() pairs.</span>

<span class="sd">    Use this when your context holds objects themselves holding key information, but you don&#39;t want to</span>
<span class="sd">    (because you shouldn&#39;t) &#39;manually&#39; extract that information and construct the key manually every time you need</span>
<span class="sd">    to write something or fetch some existing data.</span>

<span class="sd">    Warning: If you haven&#39;t also wrapped outcoming keys with a corresponding inverse transformation,</span>
<span class="sd">    you won&#39;t be able to use the incoming keys to fetch data.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.ingoing_keys(lambda x: &#39;root/&#39; + x)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;foo&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = &#39;xo&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s)</span>
<span class="sd">    [&#39;root/foo&#39;, &#39;root/bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.keys())</span>
<span class="sd">    [&#39;root/foo&#39;, &#39;root/bar&#39;]</span>

<span class="sd">    # TODO: Asymmetric key trans breaks getting items (therefore items()). Resolve (remove items() for asym keys?)</span>
<span class="sd">    # &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    # [(&#39;root/foo&#39;, 10), (&#39;root/bar&#39;, &#39;xo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_kw&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kv_wrap_outcoming_vals</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform &#39;out-coming&#39; values, that is, the values you see when you ask for them,</span>
<span class="sd">    say, through the values() or the second element of items() pairs.</span>
<span class="sd">    This can be seen as adding a de-serialization layer: trans_func being the de-serialization function.</span>

<span class="sd">    For example, say your store gives you values of the bytes type, but you want to use text, or gives you text,</span>
<span class="sd">    but you want it to be interpreted as a JSON formatted text and get a dict instead. Both of these are</span>
<span class="sd">    de-serialization layers, or out-coming value transformations.</span>

<span class="sd">    Warning: If it matters, make sure you also wrapped with a corresponding inverse serialization.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.outcoming_vals(lambda x: x * 2)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S(foo=10, bar=&#39;xo&#39;)</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [20, &#39;xoxo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;foo&#39;, 20), (&#39;bar&#39;, &#39;xoxo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_vr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_kv_wrap_ingoing_vals</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform &#39;in-going&#39; values, that is, the values at the level of the store&#39;s interface are transformed</span>
<span class="sd">    to a different value before writing to the wrapped store.</span>
<span class="sd">    This can be seen as adding a serialization layer: trans_func being the serialization function.</span>

<span class="sd">    For example, say you have a list of audio samples, and you want to save these in a WAV format.</span>

<span class="sd">    Warning: If it matters, make sure you also wrapped with a corresponding inverse de-serialization.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; S = kv_wrap.ingoing_vals(lambda x: x * 2)(UserDict)</span>
<span class="sd">    &gt;&gt;&gt; s = S()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;foo&#39;] = 10</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = &#39;xo&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s.values())</span>
<span class="sd">    [20, &#39;xoxo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(s.items())</span>
<span class="sd">    [(&#39;foo&#39;, 20), (&#39;bar&#39;, &#39;xoxo&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_vw&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ingoing_vals_wrt_to_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_vwk&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_outcoming_vals_wrt_to_keys</span><span class="p">(</span><span class="n">trans_func</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_vrk&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">postget</span><span class="o">=</span><span class="n">trans_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="mk_trans_obj">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.mk_trans_obj">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mk_trans_obj</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience method to quickly make a trans_obj (just an object holding some trans functions&quot;&quot;&quot;</span>
    <span class="c1"># TODO: Could make this more flexible (assuming here only staticmethods) and validate inputs...</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;TransObj&quot;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()})()</span></div>



<span class="n">_kv_wrap_trans_names</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;_key_of_id&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_id_of_key&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_obj_of_data&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_data_of_obj&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_preset&quot;</span><span class="p">,</span>
    <span class="s2">&quot;_postget&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SimpleDelegator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="si">=}</span><span class="s2"> is not callable&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="add_aliases">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_aliases">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_aliases</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">aliases</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function that wraps the object instance and adds aliases.</span>

<span class="sd">    See also, and not to be confused with ``insert_aliases``, which adds aliases to</span>
<span class="sd">    dunder mapping methods (like ``__iter__``, ``__getitem__``) etc.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">aliases</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="n">SimpleDelegator</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">alias</span> <span class="ow">in</span> <span class="n">aliases</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">alias</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_obj</span></div>



<div class="viewcode-block" id="kv_wrap">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.kv_wrap">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kv_wrap</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that makes a wrapper (a decorator) that will get the wrappers from</span>
<span class="sd">    methods of the input object.</span>

<span class="sd">    :param trans_obj: An object that contains (as attributes) the collection of</span>
<span class="sd">        transformation functions. The attribute names that are used, natively, to make</span>
<span class="sd">        the wrapper are ``_key_of_id``, ``_id_of_key``, ``_obj_of_data``,</span>
<span class="sd">        ``_data_of_obj``, ``_preset``, and ``_postget``.</span>

<span class="sd">    If your ``trans_obj`` uses different names for these functions, you can use the</span>
<span class="sd">    ``add_aliases`` function. We&#39;ll demo the use of ``add_aliases`` here:</span>

<span class="sd">    &gt;&gt;&gt; from dol import kv_wrap, add_aliases, Pipe</span>
<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class SeparatorTrans:</span>
<span class="sd">    ...     def __init__(self, sep: str):</span>
<span class="sd">    ...         self.sep = sep</span>
<span class="sd">    ...     def string_to_tuple(self, string: str):</span>
<span class="sd">    ...         return tuple(string.split(self.sep))</span>
<span class="sd">    ...     def tuple_to_string(self, tup: tuple):</span>
<span class="sd">    ...         return self.sep.join(tup)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; _add_aliases = partial(</span>
<span class="sd">    ...     add_aliases, _key_of_id=&#39;string_to_tuple&#39;, _id_of_key=&#39;tuple_to_string&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; mk_sep_trans = Pipe(SeparatorTrans, _add_aliases, kv_wrap)</span>
<span class="sd">    &gt;&gt;&gt; sep_trans = mk_sep_trans(&#39;/&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = sep_trans({&#39;a/b/c&#39;: 1, &#39;d/e&#39;: 2})</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;d&#39;, &#39;e&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;d&#39;, &#39;e&#39;]</span>
<span class="sd">    2</span>

<span class="sd">    ``kv_wrap`` also has convenience attributes:</span>
<span class="sd">        ``outcoming_keys``, ``ingoing_keys``, ``outcoming_vals``, ``ingoing_vals``,</span>
<span class="sd">        and ``val_reads_wrt_to_keys``</span>
<span class="sd">    which will only add a single specific wrapper (specified as a function),</span>
<span class="sd">    when that&#39;s what you need.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">key_of_id</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_key_of_id&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">id_of_key</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_id_of_key&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">obj_of_data</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_obj_of_data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">data_of_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_data_of_obj&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">preset</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_preset&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">postget</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trans_obj</span><span class="p">,</span> <span class="s2">&quot;_postget&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">name</span>
            <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__qualname__&quot;</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;_kr&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span>
            <span class="n">o</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">key_of_id</span><span class="o">=</span><span class="n">key_of_id</span><span class="p">,</span>
            <span class="n">id_of_key</span><span class="o">=</span><span class="n">id_of_key</span><span class="p">,</span>
            <span class="n">obj_of_data</span><span class="o">=</span><span class="n">obj_of_data</span><span class="p">,</span>
            <span class="n">data_of_obj</span><span class="o">=</span><span class="n">data_of_obj</span><span class="p">,</span>
            <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">,</span>
            <span class="n">postget</span><span class="o">=</span><span class="n">postget</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<span class="n">kv_wrap</span><span class="o">.</span><span class="n">mk_trans_obj</span> <span class="o">=</span> <span class="n">mk_trans_obj</span>  <span class="c1"># to have a trans_obj maker handy</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_keys</span> <span class="o">=</span> <span class="n">_kv_wrap_outcoming_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_keys</span> <span class="o">=</span> <span class="n">_kv_wrap_ingoing_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_vals</span> <span class="o">=</span> <span class="n">_kv_wrap_outcoming_vals</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_vals</span> <span class="o">=</span> <span class="n">_kv_wrap_ingoing_vals</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">ingoing_vals_wrt_to_keys</span> <span class="o">=</span> <span class="n">_ingoing_vals_wrt_to_keys</span>
<span class="n">kv_wrap</span><span class="o">.</span><span class="n">outcoming_vals_wrt_to_keys</span> <span class="o">=</span> <span class="n">_outcoming_vals_wrt_to_keys</span>


<div class="viewcode-block" id="mk_wrapper">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.mk_wrapper">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mk_wrapper</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    You have a wrapper class and you want to make a wrapper out of it,</span>
<span class="sd">    that is, a decorator factory with which you can make wrappers, like this:</span>
<span class="sd">    ```</span>
<span class="sd">    wrapper = mk_wrapper(wrap_cls)</span>
<span class="sd">    ```</span>
<span class="sd">    that you can then use to transform stores like thiis:</span>
<span class="sd">    ```</span>
<span class="sd">    MyStore = wrapper(**wrapper_kwargs)(StoreYouWantToTransform)</span>
<span class="sd">    ```</span>

<span class="sd">    :param wrap_cls:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; class RelPath:</span>
<span class="sd">    ...     def __init__(self, root):</span>
<span class="sd">    ...         self.root = root</span>
<span class="sd">    ...         self._root_length = len(root)</span>
<span class="sd">    ...     def _key_of_id(self, _id):</span>
<span class="sd">    ...         return _id[self._root_length:]</span>
<span class="sd">    ...     def _id_of_key(self, k):</span>
<span class="sd">    ...         return self.root + k</span>
<span class="sd">    &gt;&gt;&gt; relpath_wrap = mk_wrapper(RelPath)</span>
<span class="sd">    &gt;&gt;&gt; RelDict = relpath_wrap(root=&#39;foo/&#39;)(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = RelDict()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = 42</span>
<span class="sd">    &gt;&gt;&gt; assert list(s) == [&#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;bar&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; assert str(s) == &quot;{&#39;foo/bar&#39;: 42}&quot;  # reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kv_wrap</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">wrapper</span></div>



<div class="viewcode-block" id="add_wrapper_method">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_wrapper_method">[docs]</a>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_wrapper_method</span><span class="p">(</span><span class="n">wrap_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="s2">&quot;wrapper&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator that adds a wrapper method (itself a decorator) to a wrapping class</span>
<span class="sd">    Clear?</span>
<span class="sd">    See `mk_wrapper` function and doctest example if not.</span>

<span class="sd">    What `add_wrapper_method` does is just to add a `&quot;wrapper&quot;` method</span>
<span class="sd">    (or another name if you ask for it) to `wrap_cls`, so that you can use that</span>
<span class="sd">    class for it&#39;s purpose of transforming stores more conveniently.</span>

<span class="sd">    :param wrap_cls: The wrapper class (the definitioin of the transformation.</span>
<span class="sd">        If None, the functiion will make a decorator to decorate wrap_cls later</span>
<span class="sd">    :param method_name: The method name you want to use (default is &#39;wrapper&#39;)</span>

<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @add_wrapper_method</span>
<span class="sd">    ... class RelPath:</span>
<span class="sd">    ...     def __init__(self, root):</span>
<span class="sd">    ...         self.root = root</span>
<span class="sd">    ...         self._root_length = len(root)</span>
<span class="sd">    ...     def _key_of_id(self, _id):</span>
<span class="sd">    ...         return _id[self._root_length:]</span>
<span class="sd">    ...     def _id_of_key(self, k):</span>
<span class="sd">    ...         return self.root + k</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; RelDict = RelPath.wrapper(root=&#39;foo/&#39;)(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = RelDict()</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;bar&#39;] = 42</span>
<span class="sd">    &gt;&gt;&gt; assert list(s) == [&#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;bar&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; assert str(s) == &quot;{&#39;foo/bar&#39;: 42}&quot;  # reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">mk_wrapper</span><span class="p">(</span><span class="n">wrap_cls</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">wrap_cls</span></div>



<span class="c1">########################################################################################################################</span>
<span class="c1"># Aliasing</span>

<span class="n">_method_name_for</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;write&quot;</span><span class="p">:</span> <span class="s2">&quot;__setitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read&quot;</span><span class="p">:</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;delete&quot;</span><span class="p">:</span> <span class="s2">&quot;__delitem__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;list&quot;</span><span class="p">:</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">,</span>
    <span class="s2">&quot;count&quot;</span><span class="p">:</span> <span class="s2">&quot;__len__&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_conditional_data_trans</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">data_trans</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">data_trans</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>


<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">conditional_data_trans</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">data_trans</span><span class="p">):</span>
    <span class="n">_data_trans</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">_conditional_data_trans</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span> <span class="n">data_trans</span><span class="o">=</span><span class="n">data_trans</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">data_trans</span><span class="p">,</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="n">_data_trans</span><span class="p">))</span>


<div class="viewcode-block" id="add_path_get">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_path_get">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_path_get</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make nested stores accessible through key paths.</span>
<span class="sd">    In a way &quot;flatten the nested keys access&quot;.</span>
<span class="sd">    By default, the path object will be a tuple (e.g. ``(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)``, but you can</span>
<span class="sd">    make it whatever you want, and/or use `dol.paths.KeyPath` to map to and from</span>
<span class="sd">    forms like ``&#39;a.b.c&#39;``, ``&#39;a/b/c&#39;``, etc.</span>

<span class="sd">    (Warning: ``path_type`` only effects the first level.</span>
<span class="sd">    That is, it doesn&#39;t work recursively.</span>
<span class="sd">    See issue: https://github.com/i2mint/dol/issues/10.)</span>

<span class="sd">    Say you have some nested stores.</span>
<span class="sd">    You know... like a `ZipFileReader` store whose values are `ZipReader`s,</span>
<span class="sd">    whose values are bytes of the zipped files</span>
<span class="sd">    (and you can go on... whose (json) values are...).</span>

<span class="sd">    For our example, let&#39;s take a nested dict instead:</span>

<span class="sd">    &gt;&gt;&gt; s = {&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}}</span>

<span class="sd">    Well, you can access any node of this nested tree of stores like this:</span>

<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    And that&#39;s fine. But maybe you&#39;d like to do it this way instead:</span>

<span class="sd">    &gt;&gt;&gt; s = add_path_get(s)</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    You might also want to access 42 with `a.b.c` or `a/b/c` etc.</span>
<span class="sd">    To do that you can use `dol.paths.KeyPath` in combination with</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store (class or instance) you&#39;re wrapping.</span>
<span class="sd">            If not specified, the function will return a decorator.</span>
<span class="sd">        name: The name to give the class (not applicable to instance wrapping)</span>
<span class="sd">        path_type: The type that paths are expressed as. Needs to be an Iterable type.</span>
<span class="sd">            By default, a tuple.</span>
<span class="sd">            This is used to decide whether the key should be taken as a &quot;normal&quot;</span>
<span class="sd">            key of the store,</span>
<span class="sd">            or should be used to iterate through, recursively getting values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A wrapped store (class or instance), or a store wrapping decorator</span>
<span class="sd">        (if store is not specified)</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        ``KeyPath`` in :doc:`paths`</span>

<span class="sd">    Wrapping an instance</span>

<span class="sd">    &gt;&gt;&gt; s = add_path_get({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;]</span>
<span class="sd">    {&#39;b&#39;: {&#39;c&#39;: 42}}</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">    {&#39;c&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    Wrapping a class</span>

<span class="sd">    &gt;&gt;&gt; S = add_path_get(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;] == {&#39;c&#39;: 42};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == 42</span>

<span class="sd">    Using add_path_get as a decorator</span>

<span class="sd">    &gt;&gt;&gt; @add_path_get</span>
<span class="sd">    ... class S(dict):</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;] == s[&#39;a&#39;][&#39;b&#39;] == {&#39;c&#39;: 42};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;] == 42</span>

<span class="sd">    A different kind of path?</span>
<span class="sd">    You can choose a different path_type, but sometimes (say both keys and key paths are strings)</span>
<span class="sd">    You need to involve more tools. Like dol.paths.KeyPath...</span>

<span class="sd">    &gt;&gt;&gt; from dol.paths import KeyPath</span>
<span class="sd">    &gt;&gt;&gt; from dol.trans import kv_wrap</span>
<span class="sd">    &gt;&gt;&gt; SS = kv_wrap(KeyPath(path_sep=&#39;.&#39;))(S)</span>
<span class="sd">    &gt;&gt;&gt; s = SS({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a.b&#39;] == s[&#39;a&#39;][&#39;b&#39;];</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a.b.c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">+</span> <span class="s2">&quot;WithPathGet&quot;</span>

    <span class="c1"># TODO: This is not the best way to handle this. Investigate another way. ######################</span>
    <span class="n">global_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">global_names</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;That name is already in use&quot;</span><span class="p">)</span>
    <span class="c1"># TODO: ########################################################################################</span>

    <span class="n">store_cls</span> <span class="o">=</span> <span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">store_cls</span><span class="o">.</span><span class="n">_path_type</span> <span class="o">=</span> <span class="n">path_type</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_type</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">store</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># do things normally if the key is not a _path_type</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__getitem__</span> <span class="o">=</span> <span class="fm">__getitem__</span>

    <span class="k">return</span> <span class="n">store_cls</span></div>



<span class="c1"># TODO: Should we keep add_path_get, or add &quot;read_only&quot; flag to add_path_access?</span>
<span class="c1"># TODO: See https://github.com/i2mint/dol/issues/10</span>
<div class="viewcode-block" id="add_path_access">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_path_access">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_path_access</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make nested stores (read/write) accessible through key paths (iterable of keys).</span>

<span class="sd">    Like ``add_path_get``, but with write and delete accessible through key paths.</span>

<span class="sd">    In a way &quot;flatten the nested keys access&quot;.</span>
<span class="sd">    (Warning: ``path_type`` only effects the first level.</span>
<span class="sd">    That is, it doesn&#39;t work recursively.</span>
<span class="sd">    See issue: https://github.com/i2mint/dol/issues/10.)</span>

<span class="sd">    By default, the path object will be a tuple (e.g. ``(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)``, but you can</span>
<span class="sd">    make it whatever you want, and/or use `dol.paths.KeyPath` to map to and from</span>
<span class="sd">    forms like ``&#39;a.b.c&#39;``, ``&#39;a/b/c&#39;``, etc.</span>

<span class="sd">    Say you have some nested stores.</span>
<span class="sd">    You know... like a `ZipFileReader` store whose values are `ZipReader`s,</span>
<span class="sd">    whose values are bytes of the zipped files</span>
<span class="sd">    (and you can go on... whose (json) values are...).</span>

<span class="sd">    For our example, let&#39;s take a nested dict instead:</span>

<span class="sd">    &gt;&gt;&gt; s = {&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}}</span>

<span class="sd">    Well, you can access any node of this nested tree of stores like this:</span>

<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    And that&#39;s fine. But maybe you&#39;d like to do it this way instead:</span>

<span class="sd">    &gt;&gt;&gt; s = add_path_access(s)</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    So far, this is what ``add_path_get`` does. With ``add_path_access`` though you</span>
<span class="sd">    can also write and delete that way too:</span>

<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] = 3.14</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    3.14</span>
<span class="sd">    &gt;&gt;&gt; del s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;a&#39;: {&#39;b&#39;: {}}}</span>

<span class="sd">    You might also want to access 42 with `a.b.c` or `a/b/c` etc.</span>
<span class="sd">    To do that you can use `dol.paths.KeyPath` in combination with</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store (class or instance) you&#39;re wrapping.</span>
<span class="sd">            If not specified, the function will return a decorator.</span>
<span class="sd">        name: The name to give the class (not applicable to instance wrapping)</span>
<span class="sd">        path_type: The type that paths are expressed as. Needs to be an Iterable type.</span>
<span class="sd">            By default, a tuple.</span>
<span class="sd">            This is used to decide whether the key should be taken as a &quot;normal&quot;</span>
<span class="sd">            key of the store,</span>
<span class="sd">            or should be used to iterate through, recursively getting values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A wrapped store (class or instance), or a store wrapping decorator</span>
<span class="sd">        (if store is not specified)</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        ``KeyPath`` in :doc:`paths`</span>

<span class="sd">    Wrapping a class</span>

<span class="sd">    &gt;&gt;&gt; S = add_path_access(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;] == {&#39;c&#39;: 42};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] = 3.14</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    3.14</span>
<span class="sd">    &gt;&gt;&gt; del s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;a&#39;: {&#39;b&#39;: {}}}</span>

<span class="sd">    Using add_path_get as a decorator</span>

<span class="sd">    &gt;&gt;&gt; @add_path_access</span>
<span class="sd">    ... class S(dict):</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt; s = S(a={&#39;b&#39;: {&#39;c&#39;: 42}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;] == s[&#39;a&#39;][&#39;b&#39;] == {&#39;c&#39;: 42};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;] == 42</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] = 3.14</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    3.14</span>
<span class="sd">    &gt;&gt;&gt; del s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;a&#39;: {&#39;b&#39;: {}}}</span>

<span class="sd">    A different kind of path?</span>
<span class="sd">    You can choose a different path_type, but sometimes (say both keys and key paths are strings)</span>
<span class="sd">    You need to involve more tools. Like dol.paths.KeyPath...</span>

<span class="sd">    &gt;&gt;&gt; from dol.paths import KeyPath</span>
<span class="sd">    &gt;&gt;&gt; from dol.trans import kv_wrap</span>
<span class="sd">    &gt;&gt;&gt; SS = kv_wrap(KeyPath(path_sep=&#39;.&#39;))(S)</span>
<span class="sd">    &gt;&gt;&gt; s = SS({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a&#39;] == {&#39;b&#39;: {&#39;c&#39;: 42}};</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a.b&#39;] == s[&#39;a&#39;][&#39;b&#39;];</span>
<span class="sd">    &gt;&gt;&gt; assert s[&#39;a.b.c&#39;] == s[&#39;a&#39;][&#39;b&#39;][&#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a.b.c&#39;] = 3.14</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 3.14}}}</span>
<span class="sd">    &gt;&gt;&gt; del s[&#39;a.b.c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;a&#39;: {&#39;b&#39;: {}}}</span>

<span class="sd">    Note: The add_path_access doesn&#39;t carry on to values.</span>

<span class="sd">    &gt;&gt;&gt; s = add_path_access({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; # but</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;][&#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    KeyError: (&#39;b&#39;, &#39;c&#39;)</span>

<span class="sd">    That said,</span>

<span class="sd">    &gt;&gt;&gt; add_path_access(s[&#39;a&#39;])[&#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    The reason why we don&#39;t do this automatically is that it may not always be desirable.</span>
<span class="sd">    If one wanted to though, one could use ``wrap_kvs(obj_of_data=...)`` to wrap</span>
<span class="sd">    specific values with ``add_path_access``.</span>
<span class="sd">    For example, if you wanted to wrap all mappings recursively, you could:</span>

<span class="sd">    &gt;&gt;&gt; from typing import Mapping</span>
<span class="sd">    &gt;&gt;&gt; from dol.util import instance_checker</span>
<span class="sd">    &gt;&gt;&gt; add_path_access_if_mapping = conditional_data_trans(</span>
<span class="sd">    ...     condition=instance_checker(Mapping), data_trans=add_path_access</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; s = add_path_access_if_mapping({&#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}}})</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; # But now this works:</span>
<span class="sd">    &gt;&gt;&gt; s[&#39;a&#39;][&#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    42</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">store_cls</span> <span class="o">=</span> <span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">store_cls</span> <span class="o">=</span> <span class="n">add_path_get</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">path_type</span><span class="o">=</span><span class="n">path_type</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_type</span><span class="p">):</span>
            <span class="o">*</span><span class="n">path_head</span><span class="p">,</span> <span class="n">last_key</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">penultimate_level</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">path_head</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">penultimate_level</span><span class="p">[</span><span class="n">last_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># do things normally if the key is not a _path_type</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_type</span><span class="p">):</span>
            <span class="o">*</span><span class="n">path_head</span><span class="p">,</span> <span class="n">last_key</span> <span class="o">=</span> <span class="n">k</span>
            <span class="n">penultimate_level</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">path_head</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">penultimate_level</span><span class="p">[</span><span class="n">last_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># do things normally if the key is not a _path_type</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store_cls</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__setitem__</span> <span class="o">=</span> <span class="fm">__setitem__</span>
    <span class="n">store_cls</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="fm">__delitem__</span>

    <span class="k">return</span> <span class="n">store_cls</span></div>



<div class="viewcode-block" id="flatten">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.flatten">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cache_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten a nested store.</span>

<span class="sd">    Say you have a store that has three levels (or more), that is, that you can always</span>
<span class="sd">    ask for the value ``store[a][b][c]`` if ``a`` is a valid key of ``store``,</span>
<span class="sd">    ``b`` is a valid key of ``store[a]`` and ``c`` is a valid key of ``store[a][b]``.</span>

<span class="sd">    What ``flattened_store = flatten(store, levels=3)`` will give you is the ability</span>
<span class="sd">    to access the ``store[a][b][c]`` as ``store[a, b, c]``, while still being able</span>
<span class="sd">    to access these stores &quot;normally&quot;.</span>

<span class="sd">    If that&#39;s all you need, you can just use the ``add_get_path`` wrapper for this.</span>

<span class="sd">    Why would you use ``flatten``? Because ``add_get_path(store)`` would still only</span>
<span class="sd">    give you the ``KvReader`` point of view of the root ``store``.</span>
<span class="sd">    If you ``list(store)``, you&#39;d only get the first level keys,</span>
<span class="sd">    or if you ask if ``(a, b, c)`` is in the store, it will tell you it&#39;s not</span>
<span class="sd">    (though you can access data with such a key.</span>

<span class="sd">    Instead, a flattened store will consider that the keys are those ``(a, b, c)``</span>
<span class="sd">    key paths.</span>

<span class="sd">    Further, when flattening a store, you can ask for the view to cache the keys,</span>
<span class="sd">    specifying ``cache_keys=True`` or give it an explicit place to cache or</span>
<span class="sd">    factory to make a cache (see ``cached_keys`` wrapper for more details).</span>
<span class="sd">    Though caching keys is not the default it&#39;s highly recommended to do so in most</span>
<span class="sd">    cases. The only reason it is not the default is because if you have millions of</span>
<span class="sd">    keys, but little memory, that&#39;s not what you might want.</span>

<span class="sd">    Note: Flattening just provides a wrapper giving you a &quot;flattened view&quot;. It doesn&#39;t</span>
<span class="sd">    change the store itself, or it&#39;s contents.</span>

<span class="sd">    :param store: The store instance or class to be wrapped</span>
<span class="sd">    :param levels: The number of nested levels to flatten</span>
<span class="sd">    :param cache_keys: Whether to cache the keys, or a cache factory or instance.</span>

<span class="sd">    &gt;&gt;&gt; from dol import flatten</span>
<span class="sd">    &gt;&gt;&gt; d = {</span>
<span class="sd">    ...     &#39;a&#39;: {&#39;b&#39;: {&#39;c&#39;: 42}},</span>
<span class="sd">    ...     &#39;aa&#39;: {&#39;bb&#39;: {&#39;cc&#39;: &#39;dragon_con&#39;}}</span>
<span class="sd">    ... }</span>

<span class="sd">    You can get a flattened view of an instance:</span>

<span class="sd">    &gt;&gt;&gt; m = flatten(d, levels=3, cache_keys=True)</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...         list(m.items())</span>
<span class="sd">    ...         == [</span>
<span class="sd">    ...             ((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), 42),</span>
<span class="sd">    ...             ((&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;), &#39;dragon_con&#39;)</span>
<span class="sd">    ...         ]</span>
<span class="sd">    ... )</span>

<span class="sd">    You can make a flattener and apply it to an instance (or a class):</span>

<span class="sd">    &gt;&gt;&gt; my_flattener = flatten(levels=2)</span>
<span class="sd">    &gt;&gt;&gt; m = my_flattener(d)</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...         list(m.items())</span>
<span class="sd">    ...         == [</span>
<span class="sd">    ...             ((&#39;a&#39;, &#39;b&#39;), {&#39;c&#39;: 42}),</span>
<span class="sd">    ...             ((&#39;aa&#39;, &#39;bb&#39;), {&#39;cc&#39;: &#39;dragon_con&#39;})</span>
<span class="sd">    ...         ]</span>
<span class="sd">    ... )</span>

<span class="sd">    Finally, you can wrap a class itself.</span>

<span class="sd">    &gt;&gt;&gt; @flatten(levels=1)</span>
<span class="sd">    ... class MyFlatDict(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; m = MyFlatDict(d)</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...         list(m.items())</span>
<span class="sd">    ...         == [</span>
<span class="sd">    ...             ((&#39;a&#39;,), {&#39;b&#39;: {&#39;c&#39;: 42}}),</span>
<span class="sd">    ...             ((&#39;aa&#39;,), {&#39;bb&#39;: {&#39;cc&#39;: &#39;dragon_con&#39;}})</span>
<span class="sd">    ...         ]</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_wrap_store</span><span class="p">(</span><span class="n">_flatten</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span></div>

    <span class="c1">#</span>
    <span class="c1"># arguments = {k: v for k, v in locals().items() if k != &quot;arguments&quot;}</span>
    <span class="c1"># store = arguments.pop(&quot;store&quot;)</span>
    <span class="c1">#</span>
    <span class="c1"># class_trans = partial(_flatten, **arguments)</span>
    <span class="c1"># return Store.wrap(store, class_trans=class_trans)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_flatten</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">levels</span><span class="p">,</span> <span class="n">cache_keys</span><span class="p">):</span>
    <span class="n">store</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="n">levels</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">leveled_paths_walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">)</span>

    <span class="n">store</span><span class="o">.</span><span class="fm">__iter__</span> <span class="o">=</span> <span class="fm">__iter__</span>

    <span class="k">if</span> <span class="n">cache_keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cache_keys</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">cache_keys</span> <span class="o">=</span> <span class="nb">list</span>
        <span class="k">return</span> <span class="n">add_path_get</span><span class="p">(</span><span class="n">cached_keys</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="n">cache_keys</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="n">i</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                    <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="n">store</span><span class="o">.</span><span class="fm">__len__</span> <span class="o">=</span> <span class="fm">__len__</span>
        <span class="n">store</span><span class="o">.</span><span class="fm">__contains__</span> <span class="o">=</span> <span class="fm">__contains__</span>

        <span class="c1"># TODO: This adds read access to all levels, not limited to levels</span>
        <span class="k">return</span> <span class="n">add_path_get</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>


<div class="viewcode-block" id="mk_level_walk_filt">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.mk_level_walk_filt">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mk_level_walk_filt</span><span class="p">(</span><span class="n">levels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a ``walk_filt`` function for ``kv_walk`` based on some level logic.</span>
<span class="sd">    If ``levels`` is an integer, will consider it as the max path length,</span>
<span class="sd">    if not it will just assert that ``levels`` is callable, and return it</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;levels must be a callable or an integer: </span><span class="si">{</span><span class="n">levels</span><span class="si">=}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">levels</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">leveled_paths_walk</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">levels</span><span class="p">):</span>
    <span class="k">yield from</span> <span class="n">kv_walk</span><span class="p">(</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">leaf_yield</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">p</span><span class="p">,</span> <span class="n">walk_filt</span><span class="o">=</span><span class="n">mk_level_walk_filt</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_alias</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">))</span>


<div class="viewcode-block" id="insert_aliases">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.insert_aliases">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">insert_aliases</span><span class="p">(</span>
    <span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert method aliases of CRUD operations of a store (class or instance).</span>
<span class="sd">    If store is a class, you&#39;ll get a copy of the class with those methods added.</span>
<span class="sd">    If store is an instance, the methods will be added in place (no copy will be made).</span>

<span class="sd">    Note: If an operation (write, read, delete, list, count) is not specified, no alias will be created for</span>
<span class="sd">    that operation.</span>

<span class="sd">    IMPORTANT NOTE: The signatures of the methods the aliases will point to will not change.</span>
<span class="sd">    We say this because, you can call the write method &quot;dump&quot;, but you&#39;ll have to use it as</span>
<span class="sd">    `store.dump(key, val)`, not `store.dump(val, key)`, which is the signature you&#39;re probably used to</span>
<span class="sd">    (it&#39;s the one used by json.dump or pickle.dump for example). If you want that familiar interface,</span>
<span class="sd">    using the insert_load_dump_aliases function.</span>

<span class="sd">    See also (and not to be confused with): ``add_aliases``</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store to extend with aliases.</span>
<span class="sd">        write: Desired method name for __setitem__</span>
<span class="sd">        read: Desired method name for __getitem__</span>
<span class="sd">        delete: Desired method name for __delitem__</span>
<span class="sd">        list: Desired method name for __iter__</span>
<span class="sd">        count: Desired method name for __len__</span>

<span class="sd">    Returns: A store with the desired aliases.</span>

<span class="sd">    &gt;&gt;&gt; # Example of extending a class</span>
<span class="sd">    &gt;&gt;&gt; mydict = insert_aliases(dict, write=&#39;dump&#39;, read=&#39;load&#39;, delete=&#39;rm&#39;, list=&#39;peek&#39;, count=&#39;size&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s = mydict(true=&#39;love&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.dump(&#39;friends&#39;, &#39;forever&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt; s.load(&#39;true&#39;)</span>
<span class="sd">    &#39;love&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(s.peek())</span>
<span class="sd">    [&#39;true&#39;, &#39;friends&#39;]</span>
<span class="sd">    &gt;&gt;&gt; s.size()</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; s.rm(&#39;true&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example of extending an instance</span>
<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; s = UserDict(true=&#39;love&#39;)  # make (and instance) of a UserDict (can&#39;t modify a dict instance)</span>
<span class="sd">    &gt;&gt;&gt; # make aliases of note that you don&#39;t need</span>
<span class="sd">    &gt;&gt;&gt; s = insert_aliases(s, write=&#39;put&#39;, read=&#39;retrieve&#39;, count=&#39;num_of_items&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.put(&#39;friends&#39;, &#39;forever&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="sd">    &gt;&gt;&gt; s.retrieve(&#39;true&#39;)</span>
<span class="sd">    &#39;love&#39;</span>
<span class="sd">    &gt;&gt;&gt; s.num_of_items()</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">,</span> <span class="p">(</span><span class="n">store</span><span class="p">,),</span> <span class="p">{})</span>
    <span class="k">for</span> <span class="n">alias</span><span class="p">,</span> <span class="n">method_name</span> <span class="ow">in</span> <span class="n">_method_name_for</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">_insert_alias</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">alias</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">store</span></div>



<div class="viewcode-block" id="insert_load_dump_aliases">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.insert_load_dump_aliases">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">insert_load_dump_aliases</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert load and dump methods, with familiar dump(obj, location) signature.</span>

<span class="sd">    Args:</span>
<span class="sd">        store: The store to extend with aliases.</span>
<span class="sd">        delete: Desired method name for __delitem__</span>
<span class="sd">        list: Desired method name for __iter__</span>
<span class="sd">        count: Desired method name for __len__</span>

<span class="sd">    Returns: A store with the desired aliases.</span>

<span class="sd">    &gt;&gt;&gt; mydict = insert_load_dump_aliases(dict)</span>
<span class="sd">    &gt;&gt;&gt; s = mydict()</span>
<span class="sd">    &gt;&gt;&gt; s.dump(obj=&#39;love&#39;, key=&#39;true&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    {&#39;true&#39;: &#39;love&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">store</span> <span class="o">=</span> <span class="n">insert_aliases</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="s2">&quot;load&quot;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">dump</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">store</span><span class="o">.</span><span class="n">dump</span> <span class="o">=</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">dump</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">store</span></div>



<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>

<span class="n">FuncInput</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;FuncInput&quot;</span><span class="p">)</span>
<span class="n">FuncOutput</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;FuncOutput&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="constant_output">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.constant_output">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">constant_output</span><span class="p">(</span><span class="n">return_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function that returns a constant value no matter what the inputs are.</span>
<span class="sd">    Is meant to be used with functools.partial to create custom versions.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; always_true = partial(constant_output, True)</span>
<span class="sd">    &gt;&gt;&gt; always_true(&#39;regardless&#39;, &#39;of&#39;, the=&#39;input&#39;, will=&#39;return True&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">return_val</span></div>



<span class="nd">@double_up_as_factory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">condition_function_call</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncInput</span><span class="p">],</span> <span class="n">FuncOutput</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncInput</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">constant_output</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
    <span class="n">callback_if_condition_not_met</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncInput</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">constant_output</span><span class="p">,</span> <span class="kc">None</span>
    <span class="p">),</span>
<span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapped_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">callback_if_condition_not_met</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapped_func</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">MutableMapping</span>

<span class="n">Key</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">Val</span> <span class="o">=</span> <span class="n">Any</span>
<span class="n">SetitemCondition</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Key</span><span class="p">,</span> <span class="n">Val</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>

<span class="c1"># @store_decorator</span>
<span class="c1"># def only_allow_writes_that_obey_condition(*,</span>
<span class="c1">#                                           write_condition: SetitemCondition,</span>
<span class="c1">#                                           msg=&#39;Write arguments did not match condition.&#39;):</span>
<span class="c1">#     def _only_allow_writes_that_obey_condition(store: MutableMapping):</span>
<span class="c1">#         pass</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">dol.util</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">has_enabled_clear_method</span><span class="p">,</span>
    <span class="n">inject_method</span><span class="p">,</span>
    <span class="n">_delete_keys_one_by_one</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">InjectionValidator</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>


<div class="viewcode-block" id="ensure_clear_method">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.ensure_clear_method">[docs]</a>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ensure_clear_method</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">clear_method</span><span class="o">=</span><span class="n">_delete_keys_one_by_one</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If obj doesn&#39;t have an enabled clear method, will add one (a slow one that runs through keys and deletes them&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_enabled_clear_method</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
        <span class="n">inject_method</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">clear_method</span><span class="p">,</span> <span class="s2">&quot;clear&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">store</span></div>



<div class="viewcode-block" id="add_store_method">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_store_method">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_store_method</span><span class="p">(</span>
    <span class="n">store</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">method_func</span><span class="p">,</span>
    <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">validator</span><span class="p">:</span> <span class="n">InjectionValidator</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add methods to store classes or instances</span>

<span class="sd">    :param store: A store type or instance</span>
<span class="sd">    :param method_func: The function of the method to be added</span>
<span class="sd">    :param method_name: The name of the store attribute this function should be written to</span>
<span class="sd">    :param validator: An optional validator. If not None, ``validator(store, method_func)`` will be called.</span>
<span class="sd">        If it doesn&#39;t return True, a ``SetattrNotAllowed`` will be raised.</span>
<span class="sd">        Note that ``validator`` can also raise its own exception.</span>
<span class="sd">    :return: A store with the added (or modified) method</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_name</span> <span class="ow">or</span> <span class="n">method_func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">if</span> <span class="n">validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">validator</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">method_func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SetattrNotAllowed</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method is not allowed to be set (according to </span><span class="si">{</span><span class="n">validator</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">method_func</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="p">())</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">StoreWithAddedMethods</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nb">setattr</span><span class="p">(</span><span class="n">StoreWithAddedMethods</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method_func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">StoreWithAddedMethods</span></div>



<div class="viewcode-block" id="MapInvertabilityError">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.MapInvertabilityError">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MapInvertabilityError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;To be used to indicate that a mapping isn&#39;t, or wouldn&#39;t be, invertible&quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="CachedInvertibleTrans">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.CachedInvertibleTrans">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CachedInvertibleTrans</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; t = CachedInvertibleTrans(lambda x: x[1])</span>
<span class="sd">    &gt;&gt;&gt; t.ingress(&#39;ab&#39;)</span>
<span class="sd">    &#39;b&#39;</span>
<span class="sd">    &gt;&gt;&gt; t.ingress((1, 2))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; t.egress(&#39;b&#39;)</span>
<span class="sd">    &#39;ab&#39;</span>
<span class="sd">    &gt;&gt;&gt; t.egress(2)</span>
<span class="sd">    (1, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trans_func</span> <span class="o">=</span> <span class="n">trans_func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ingress_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">egress_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ingress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ingress_map</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trans_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ingress_map</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">egress_map</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">MapInvertabilityError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;egress_map (the inverse map) already had key: </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">egress_map</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ingress_map</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">egress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">egress_map</span><span class="p">[</span><span class="n">y</span><span class="p">]</span></div>



<div class="viewcode-block" id="assert_min_num_of_args">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.assert_min_num_of_args">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">assert_min_num_of_args</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">num_of_args</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assert that a function can be a store method.</span>
<span class="sd">    That is, it should have a signature that takes the store as the first argument</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_of_args</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Function </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> doesn&#39;t have at least </span><span class="si">{</span><span class="n">num_of_args</span><span class="si">}</span><span class="s2"> arguments&quot;</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Encountered error checking if </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> can be a store method. &quot;</span>
            <span class="s2">&quot;Will return True, to not disrupt process, but you may want to check on &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;this : </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="add_missing_key_handling">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.add_missing_key_handling">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_missing_key_handling</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">missing_key_callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Overrides the ``__missing__`` method of a store with a custom callback.</span>

<span class="sd">    The callback must have two arguments: the store and the key.</span>

<span class="sd">    In the following example, we endow a store to return a sub-store when a key is</span>
<span class="sd">    missing. This substore will contain only keys that start with that missing key.</span>
<span class="sd">    This is useful, for example, to get &quot;subfolder filtering&quot; on a store.</span>

<span class="sd">    &gt;&gt;&gt; def prefix_filter(store, prefix: str):</span>
<span class="sd">    ...     &#39;&#39;&#39;Filter the store to have only keys that start with prefix&#39;&#39;&#39;</span>
<span class="sd">    ...     from dol import filt_iter</span>
<span class="sd">    ...     return filt_iter(store, filt=lambda x: x.startswith(prefix))</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; @add_missing_key_handling(missing_key_callback=prefix_filter)</span>
<span class="sd">    ... class D(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = D({&#39;a/b&#39;: 1, &#39;a/c&#39;: 2, &#39;d/e&#39;: 3, &#39;f&#39;: 4})</span>
<span class="sd">    &gt;&gt;&gt; sorted(s)</span>
<span class="sd">    [&#39;a/b&#39;, &#39;a/c&#39;, &#39;d/e&#39;, &#39;f&#39;]</span>
<span class="sd">    &gt;&gt;&gt; &#39;a/&#39; not in s</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # yet</span>
<span class="sd">    &gt;&gt;&gt; v = s[&#39;a/&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert dict(v) == {&#39;a/b&#39;: 1, &#39;a/c&#39;: 2}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">assert_min_num_of_args</span><span class="p">(</span><span class="n">missing_key_callback</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="p">())</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">StoreWithMissingKeyCallaback</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">StoreWithMissingKeyCallaback</span><span class="o">.</span><span class="fm">__missing__</span> <span class="o">=</span> <span class="n">missing_key_callback</span>
    <span class="k">return</span> <span class="n">StoreWithMissingKeyCallaback</span></div>



<span class="n">EncodedType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;EncodedType&quot;</span><span class="p">)</span>
<span class="n">DecodedType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;DecodedType&quot;</span><span class="p">)</span>


<span class="c1"># TODO: Want a way to specify Encoded type and Decoded type</span>
<div class="viewcode-block" id="Codec">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.Codec">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Codec</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">DecodedType</span><span class="p">,</span> <span class="n">EncodedType</span><span class="p">]):</span>
    <span class="n">encoder</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">DecodedType</span><span class="p">],</span> <span class="n">EncodedType</span><span class="p">]</span>
    <span class="n">decoder</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">EncodedType</span><span class="p">],</span> <span class="n">DecodedType</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compose_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">encoder</span><span class="o">=</span><span class="n">Pipe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">encoder</span><span class="p">),</span>
            <span class="n">decoder</span><span class="o">=</span><span class="n">Pipe</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">decoder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Codec.invert">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.Codec.invert">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a codec that is the inverse of this one.</span>
<span class="sd">        That is, encoder and decoder will be swapped.&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">encoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">,</span> <span class="n">decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">)</span></div>


    <span class="c1"># operators</span>
    <span class="fm">__add__</span> <span class="o">=</span> <span class="n">compose_with</span>
    <span class="fm">__invert__</span> <span class="o">=</span> <span class="n">invert</span></div>



<span class="n">_CodecT</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">DecodedType</span><span class="p">,</span> <span class="n">EncodedType</span><span class="p">],</span> <span class="n">Codec</span><span class="p">[</span><span class="n">DecodedType</span><span class="p">,</span> <span class="n">EncodedType</span><span class="p">])</span>


<div class="viewcode-block" id="ValueCodec">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.ValueCodec">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ValueCodec</span><span class="p">(</span><span class="o">*</span><span class="n">_CodecT</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">)</span></div>



<div class="viewcode-block" id="KeyCodec">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.KeyCodec">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">KeyCodec</span><span class="p">(</span><span class="o">*</span><span class="n">_CodecT</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">,</span> <span class="n">key_of_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">)</span></div>



<div class="viewcode-block" id="KeyValueCodec">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.KeyValueCodec">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">KeyValueCodec</span><span class="p">(</span><span class="o">*</span><span class="n">_CodecT</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">,</span> <span class="n">postget</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">)</span></div>



<span class="c1"># Note: An affix is a morpheme that is attached to a word stem to form a new word or</span>
<span class="c1"># word form. Affixes include prefixes, suffixes, infixes, and circumfixes.</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_affix_encoder</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Affix a prefix and suffix to a string</span>
<span class="sd">    &gt;&gt;&gt; _affix_encoder(&#39;name&#39;, prefix=&#39;/folder/&#39;, suffix=&#39;.txt&#39;)</span>
<span class="sd">    &#39;/folder/name.txt&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">string</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_affix_decoder</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove prefix and suffix from string</span>
<span class="sd">    &gt;&gt;&gt; _affix_decoder(&#39;/folder/name.txt&#39;, prefix=&#39;/folder/&#39;, suffix=&#39;.txt&#39;)</span>
<span class="sd">    &#39;name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>  <span class="c1"># if suffix is empty, end_idx should be None</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="p">:</span> <span class="n">end_idx</span><span class="p">]</span>


<div class="viewcode-block" id="affix_key_codec">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.affix_key_codec">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">affix_key_codec</span><span class="p">(</span><span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A factory that creates a key codec that affixes a prefix and suffix to the key</span>

<span class="sd">    &gt;&gt;&gt; codec = affix_key_codec(prefix=&#39;/folder/&#39;, suffix=&#39;.txt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; codec.encoder(&#39;name&#39;)</span>
<span class="sd">    &#39;/folder/name.txt&#39;</span>
<span class="sd">    &gt;&gt;&gt; codec.decoder(&#39;/folder/name.txt&#39;)</span>
<span class="sd">    &#39;name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">KeyCodec</span><span class="p">(</span>
        <span class="n">encoder</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">_affix_encoder</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">),</span>
        <span class="n">decoder</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span><span class="n">_affix_decoder</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">),</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="redirect_getattr_to_getitem">
<a class="viewcode-back" href="../../module_docs/dol/trans.html#dol.trans.redirect_getattr_to_getitem">[docs]</a>
<span class="nd">@store_decorator</span>
<span class="k">def</span><span class="w"> </span><span class="nf">redirect_getattr_to_getitem</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keys_have_priority_over_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A mapping decorator that redirects attribute access to __getitem__.</span>

<span class="sd">    Warning: This decorator will make your class un-pickleable.</span>

<span class="sd">    :param keys_have_priority_over_attributes: If True, keys will have priority over existing attributes.</span>

<span class="sd">    &gt;&gt;&gt; @redirect_getattr_to_getitem</span>
<span class="sd">    ... class MyDict(dict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; d = MyDict(a=1, b=2)</span>
<span class="sd">    &gt;&gt;&gt; d.a</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; d.b</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; list(d)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">RidirectGetattrToGetitem</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A class that redirects attribute access to __getitem__&quot;&quot;&quot;</span>

        <span class="n">_keys_have_priority_over_attributes</span> <span class="o">=</span> <span class="n">keys_have_priority_over_attributes</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keys_have_priority_over_attributes</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="c1"># if attr not in self, or if it is in the class, then do normal getattr</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">RidirectGetattrToGetitem</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>