

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.caching &mdash; dol 0.3.30 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=56e9068c"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="dol.dig" href="dig.html" />
    <link rel="prev" title="dol.base" href="base.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">dol.base</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">dol.caching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.ApplyToInstance"><code class="docutils literal notranslate"><span class="pre">ApplyToInstance</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.ApplyToInstance.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">ApplyToInstance.resolve_at_definition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.ApplyToInstance.resolve_at_runtime"><code class="docutils literal notranslate"><span class="pre">ApplyToInstance.resolve_at_runtime()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.ApplyToMethodName"><code class="docutils literal notranslate"><span class="pre">ApplyToMethodName</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.ApplyToMethodName.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">ApplyToMethodName.resolve_at_definition()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.CachedMethod"><code class="docutils literal notranslate"><span class="pre">CachedMethod</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.CachedProperty"><code class="docutils literal notranslate"><span class="pre">CachedProperty</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.CompositeKey"><code class="docutils literal notranslate"><span class="pre">CompositeKey</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.CompositeKey.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">CompositeKey.resolve_at_definition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.CompositeKey.resolve_at_runtime"><code class="docutils literal notranslate"><span class="pre">CompositeKey.resolve_at_runtime()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.ExplicitKey"><code class="docutils literal notranslate"><span class="pre">ExplicitKey</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.ExplicitKey.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">ExplicitKey.resolve_at_definition()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.FromMethodArgs"><code class="docutils literal notranslate"><span class="pre">FromMethodArgs</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.FromMethodArgs.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">FromMethodArgs.resolve_at_definition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.FromMethodArgs.resolve_at_runtime"><code class="docutils literal notranslate"><span class="pre">FromMethodArgs.resolve_at_runtime()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.HashableDict"><code class="docutils literal notranslate"><span class="pre">HashableDict</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.InstanceProp"><code class="docutils literal notranslate"><span class="pre">InstanceProp</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.InstanceProp.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">InstanceProp.resolve_at_definition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.InstanceProp.resolve_at_runtime"><code class="docutils literal notranslate"><span class="pre">InstanceProp.resolve_at_runtime()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.KeyStrategy"><code class="docutils literal notranslate"><span class="pre">KeyStrategy</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.KeyStrategy.resolve_at_definition"><code class="docutils literal notranslate"><span class="pre">KeyStrategy.resolve_at_definition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#dol.caching.KeyStrategy.resolve_at_runtime"><code class="docutils literal notranslate"><span class="pre">KeyStrategy.resolve_at_runtime()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.WriteBackChainMap"><code class="docutils literal notranslate"><span class="pre">WriteBackChainMap</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.add_extension"><code class="docutils literal notranslate"><span class="pre">add_extension()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.cache_property_method"><code class="docutils literal notranslate"><span class="pre">cache_property_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.cache_this"><code class="docutils literal notranslate"><span class="pre">cache_this()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.cache_vals"><code class="docutils literal notranslate"><span class="pre">cache_vals()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.cached_method"><code class="docutils literal notranslate"><span class="pre">cached_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.ensure_clear_to_kv_store"><code class="docutils literal notranslate"><span class="pre">ensure_clear_to_kv_store()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.get_cache"><code class="docutils literal notranslate"><span class="pre">get_cache()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.identity"><code class="docutils literal notranslate"><span class="pre">identity()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.is_a_cache"><code class="docutils literal notranslate"><span class="pre">is_a_cache()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.lru_cache_method"><code class="docutils literal notranslate"><span class="pre">lru_cache_method()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.mk_cached_store"><code class="docutils literal notranslate"><span class="pre">mk_cached_store()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.mk_memoizer"><code class="docutils literal notranslate"><span class="pre">mk_memoizer()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.mk_sourced_store"><code class="docutils literal notranslate"><span class="pre">mk_sourced_store()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.mk_write_cached_store"><code class="docutils literal notranslate"><span class="pre">mk_write_cached_store()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.register_key_strategy"><code class="docutils literal notranslate"><span class="pre">register_key_strategy()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.store_cached"><code class="docutils literal notranslate"><span class="pre">store_cached()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#dol.caching.store_cached_with_single_key"><code class="docutils literal notranslate"><span class="pre">store_cached_with_single_key()</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="kv_codecs.html">dol.kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/new_store_wrap.html">dol.scrap.new_store_wrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_appendable.html">dol.tests.test_appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_caching.html">dol.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_dol_tools.html">dol.tests.test_dol_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_filesys.html">dol.tests.test_filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_kv_codecs.html">dol.tests.test_kv_codecs</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_paths.html">dol.tests.test_paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_trans.html">dol.tests.test_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/utils_for_tests.html">dol.tests.utils_for_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">dol.caching</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/module_docs/dol/caching.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-dol.caching">
<span id="dol-caching"></span><h1>dol.caching<a class="headerlink" href="#module-dol.caching" title="Link to this heading"></a></h1>
<p>Tools to add caching layers to stores and methods.</p>
<p>This module provides comprehensive caching functionality for Python applications,
offering flexible and powerful caching solutions for both data stores and method calls.</p>
<p>Main Use Cases:
- Property caching: Cache expensive computations that only need to be run once
- Method caching: Cache method results based on arguments, with smart key generation
- Store caching: Add caching layers to data stores for improved performance
- Custom caching strategies: Flexible key generation and cache storage options</p>
<p>Key Tools:</p>
<dl class="simple">
<dt>cache_this:</dt><dd><p>The main decorator for caching properties and methods. Automatically detects
whether to use property or method caching based on function signature.
Supports custom cache storage, key functions, parameter ignoring, and
serialization hooks.</p>
</dd>
<dt>CachedProperty:</dt><dd><p>A descriptor for caching property values with flexible cache storage and
key generation strategies.</p>
</dd>
<dt>CachedMethod:</dt><dd><p>A descriptor for caching method results based on arguments, with support
for parameter filtering and custom key functions.</p>
</dd>
<dt>KeyStrategy Protocol:</dt><dd><p>Extensible system for defining how cache keys are generated, including
strategies for explicit keys, instance properties, method arguments, and
composite keys.</p>
</dd>
<dt>Store Decorators:</dt><dd><p>Tools like cache_vals, mk_sourced_store, and store_cached for adding
caching layers to data stores.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Basic property caching:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">expensive_computation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">))</span>
</pre></div>
</div>
<p>Method caching with argument-based keys:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Calculator</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="p">{})</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>
</div>
<p>Custom cache storage and key functions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">DataProcessor</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="s1">&#39;cache&#39;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="k">else</span> <span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.ApplyToInstance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">ApplyToInstance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#ApplyToInstance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ApplyToInstance" title="Link to this definition"></a></dt>
<dd><p>Apply a function to the instance to generate the key.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.ApplyToInstance.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#ApplyToInstance.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ApplyToInstance.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Cannot resolve at definition time, need the instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.ApplyToInstance.resolve_at_runtime">
<span class="sig-name descname"><span class="pre">resolve_at_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#ApplyToInstance.resolve_at_runtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ApplyToInstance.resolve_at_runtime" title="Link to this definition"></a></dt>
<dd><p>Apply the function to the instance at runtime.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.ApplyToMethodName">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">ApplyToMethodName</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#ApplyToMethodName"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ApplyToMethodName" title="Link to this definition"></a></dt>
<dd><p>Apply a function to the method name to generate the key.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strategy</span> <span class="o">=</span> <span class="n">ApplyToMethodName</span><span class="p">(</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.cache&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strategy</span><span class="o">.</span><span class="n">resolve_at_definition</span><span class="p">(</span><span class="s2">&quot;my_method&quot;</span><span class="p">)</span>
<span class="go">&#39;my_method.cache&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.ApplyToMethodName.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#ApplyToMethodName.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ApplyToMethodName.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Apply the function to the method name at definition time.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.CachedMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">CachedMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">func:</span> <span class="pre">~collections.abc.Callable,</span> <span class="pre">cache:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">~collections.abc.MutableMapping[~dol.caching.KT,</span> <span class="pre">~dol.caching.VT]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">key:</span> <span class="pre">~collections.abc.Callable</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">*,</span> <span class="pre">ignore:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">list[str]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">allow_none_keys:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">lock_factory:</span> <span class="pre">~collections.abc.Callable</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'_thread.RLock'&gt;,</span> <span class="pre">pre_cache:</span> <span class="pre">bool</span> <span class="pre">|</span> <span class="pre">~collections.abc.MutableMapping</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">serialize:</span> <span class="pre">~collections.abc.Callable[[~typing.Any],</span> <span class="pre">~typing.Any]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">deserialize:</span> <span class="pre">~collections.abc.Callable[[~typing.Any],</span> <span class="pre">~typing.Any]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#CachedMethod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.CachedMethod" title="Link to this definition"></a></dt>
<dd><p>Descriptor that caches the result of method calls based on their arguments.</p>
<p>Similar to CachedProperty but handles methods with arguments, caching results
based on unique combinations of arguments (excluding self).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.CachedProperty">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">CachedProperty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">func:</span> <span class="pre">~collections.abc.Callable[[~typing.Any],</span> <span class="pre">~dol.caching.VT],</span> <span class="pre">cache:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">~collections.abc.MutableMapping[~dol.caching.KT,</span> <span class="pre">~dol.caching.VT]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">key:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">~collections.abc.Callable</span> <span class="pre">|</span> <span class="pre">~dol.caching.KeyStrategy</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">*,</span> <span class="pre">allow_none_keys:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">lock_factory:</span> <span class="pre">~collections.abc.Callable</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'_thread.RLock'&gt;,</span> <span class="pre">pre_cache:</span> <span class="pre">bool</span> <span class="pre">|</span> <span class="pre">~collections.abc.MutableMapping</span> <span class="pre">=</span> <span class="pre">False,</span> <span class="pre">serialize:</span> <span class="pre">~collections.abc.Callable[[~typing.Any],</span> <span class="pre">~typing.Any]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">deserialize:</span> <span class="pre">~collections.abc.Callable[[~typing.Any],</span> <span class="pre">~typing.Any]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#CachedProperty"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.CachedProperty" title="Link to this definition"></a></dt>
<dd><p>Descriptor that caches the result of the first call to a method.</p>
<p>It generalizes the builtin functools.cached_property class, enabling the user to
specify a cache object and a key to store the cache value.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.CompositeKey">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">CompositeKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">strategies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'_'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#CompositeKey"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.CompositeKey" title="Link to this definition"></a></dt>
<dd><p>Combine multiple key strategies into a single composite key.</p>
<p>Useful for creating keys that depend on both instance properties and method arguments.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.CompositeKey.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#CompositeKey.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.CompositeKey.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Try to resolve all strategies at definition time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.CompositeKey.resolve_at_runtime">
<span class="sig-name descname"><span class="pre">resolve_at_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#CompositeKey.resolve_at_runtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.CompositeKey.resolve_at_runtime" title="Link to this definition"></a></dt>
<dd><p>Resolve all strategies at runtime and combine them.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.ExplicitKey">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">ExplicitKey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#ExplicitKey"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ExplicitKey" title="Link to this definition"></a></dt>
<dd><p>Use an explicitly provided key value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">strategy</span> <span class="o">=</span> <span class="n">ExplicitKey</span><span class="p">(</span><span class="s2">&quot;my_key&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">strategy</span><span class="o">.</span><span class="n">resolve_at_definition</span><span class="p">(</span><span class="s2">&quot;method_name&quot;</span><span class="p">)</span>
<span class="go">&#39;my_key&#39;</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.ExplicitKey.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#ExplicitKey.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ExplicitKey.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Return the explicit key value at definition time.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.FromMethodArgs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">FromMethodArgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#FromMethodArgs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.FromMethodArgs" title="Link to this definition"></a></dt>
<dd><p>Apply a function to method arguments to generate the key.</p>
<p>The function receives (self, <a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs) and should return a cache key.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.FromMethodArgs.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#FromMethodArgs.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.FromMethodArgs.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Cannot resolve at definition time, need the arguments.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.FromMethodArgs.resolve_at_runtime">
<span class="sig-name descname"><span class="pre">resolve_at_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#FromMethodArgs.resolve_at_runtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.FromMethodArgs.resolve_at_runtime" title="Link to this definition"></a></dt>
<dd><p>Apply the function to the instance and method arguments at runtime.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.HashableDict">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">HashableDict</span></span><a class="reference internal" href="../../_modules/dol/caching.html#HashableDict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.HashableDict" title="Link to this definition"></a></dt>
<dd><p>Just a dict, but hashable</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.InstanceProp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">InstanceProp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prop_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#InstanceProp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.InstanceProp" title="Link to this definition"></a></dt>
<dd><p>Get a key from an instance property.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.InstanceProp.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#InstanceProp.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.InstanceProp.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Cannot resolve at definition time, need the instance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.InstanceProp.resolve_at_runtime">
<span class="sig-name descname"><span class="pre">resolve_at_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#InstanceProp.resolve_at_runtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.InstanceProp.resolve_at_runtime" title="Link to this definition"></a></dt>
<dd><p>Get the property value from the instance at runtime.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.KeyStrategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">KeyStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#KeyStrategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.KeyStrategy" title="Link to this definition"></a></dt>
<dd><p>Protocol defining how a key strategy should behave.</p>
<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.KeyStrategy.resolve_at_definition">
<span class="sig-name descname"><span class="pre">resolve_at_definition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#KeyStrategy.resolve_at_definition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.KeyStrategy.resolve_at_definition" title="Link to this definition"></a></dt>
<dd><p>Attempt to resolve the key at class definition time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>method_name</strong> – The name of the method being decorated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resolved key or None if it can’t be resolved at definition time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="dol.caching.KeyStrategy.resolve_at_runtime">
<span class="sig-name descname"><span class="pre">resolve_at_runtime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">instance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Any</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#KeyStrategy.resolve_at_runtime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.KeyStrategy.resolve_at_runtime" title="Link to this definition"></a></dt>
<dd><p>Resolve the key at runtime.
By default, this will call resolve_at_definition on method_name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>instance</strong> – The instance the property is being accessed on.</p></li>
<li><p><strong>method_name</strong> – The name of the method being decorated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resolved key.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="dol.caching.WriteBackChainMap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">WriteBackChainMap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">maps</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#WriteBackChainMap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.WriteBackChainMap" title="Link to this definition"></a></dt>
<dd><p>A collections.ChainMap that also ‘writes back’ when a key is found.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.caching</span><span class="w"> </span><span class="kn">import</span> <span class="n">WriteBackChainMap</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">WriteBackChainMap</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">33</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="mi">444</span><span class="p">})</span>
</pre></div>
</div>
<p>In a <code class="docutils literal notranslate"><span class="pre">ChainMap</span></code>, when you ask for the value for a key, each mapping in the
sequence is checked for, and the first mapping found that contains it will be
the one determining the value.</p>
<p>So here if you look for <cite>b</cite>, though the first mapping will give you the value,
though the second mapping also contains a <cite>b</cite> with a different value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>if you ask for <cite>c</cite>, it’s the second mapping that will give you the value:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="go">33</span>
</pre></div>
</div>
<p>But unlike with the builtin <code class="docutils literal notranslate"><span class="pre">ChainMap</span></code>, something else is going to happen here:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">WriteBackChainMap({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 33}, {&#39;b&#39;: 22, &#39;c&#39;: 33}, {&#39;d&#39;: 444})</span>
</pre></div>
</div>
<p>See that now the first mapping also has the <code class="docutils literal notranslate"><span class="pre">('c',</span> <span class="pre">33)</span></code> key-value pair:</p>
<p>That is what we call “write back”.</p>
<p>When a key is found in a mapping, all previous mappings (which by definition of
<code class="docutils literal notranslate"><span class="pre">ChainMap</span></code> did not have a value for that key) will be revisited and that key-value
pair will be written in it.</p>
<p>As in with <code class="docutils literal notranslate"><span class="pre">ChainMap</span></code>, all writes will be carried out in the first mapping,
and only the first mapping:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">WriteBackChainMap({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 33, &#39;e&#39;: 5}, {&#39;b&#39;: 22, &#39;c&#39;: 33}, {&#39;d&#39;: 444})</span>
</pre></div>
</div>
<p>Example use cases:</p>
<ul class="simple">
<li><p>You’re working with a local and a remote source of data. You’d like to list the</p></li>
</ul>
<p>keys available in both, and use the local item if it’s available, and if it’s not,
you want it to be sourced from remote, but written in local for quicker access
next time.</p>
<ul class="simple">
<li><p>You have several sources to look for configuration values: a sequence of</p></li>
</ul>
<p>configuration files/folders to look through (like a unix search path for command
resolution) and environment variables.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.add_extension">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">add_extension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#add_extension"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.add_extension" title="Link to this definition"></a></dt>
<dd><p>Add an extension to a name.</p>
<p>If name is None, return a partial function that will add the extension to a
name when called.</p>
<p>add_extension is a useful helper for making key functions, namely for cache_this.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add_extension</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">)</span>
<span class="go">&#39;file.txt&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_txt_ext</span> <span class="o">=</span> <span class="n">add_extension</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">add_txt_ext</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">)</span>
<span class="go">&#39;file.txt&#39;</span>
</pre></div>
</div>
<p>Note: If you want to add an extension to a name that already has an extension,
you can do that, but it will add the extension to the end of the name,
not replace the existing extension.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add_txt_ext</span><span class="p">(</span><span class="s1">&#39;file.txt&#39;</span><span class="p">)</span>
<span class="go">&#39;file.txt.txt&#39;</span>
</pre></div>
</div>
<p>Also, bare in mind that if ext starts with the system’s extension separator,
(os.path.extsep), it will be removed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">add_extension</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">add_extension</span><span class="p">(</span><span class="s1">&#39;txt&#39;</span><span class="p">,</span> <span class="s1">&#39;file&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;file.txt&#39;</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.cache_property_method">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">cache_property_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method_name:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_decorator:</span> <span class="pre">~collections.abc.Callable</span> <span class="pre">=</span> <span class="pre">&lt;function</span> <span class="pre">cache_this&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#cache_property_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.cache_property_method" title="Link to this definition"></a></dt>
<dd><p>Converts a method of a class into a CachedProperty.</p>
<p>Essentially, it does what <cite>A.method = cache_this(A.method)</cite> would do, taking care of
the <cite>__set_name__</cite> problem that you’d run into doing it that way.
Note that here, you need to say <cite>cache_property_method(A, ‘method’)</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cls</strong> (<em>type</em>) – The class containing the method.</p></li>
<li><p><strong>method_name</strong> (<em>str</em>) – The name of the method to convert to a cached property.</p></li>
<li><p><strong>cache_decorator</strong> (<em>Callable</em>) – The decorator to use to cache the method. Defaults to
<cite>cache_this</cite>. One frequent use case would be to use <cite>functools.partial</cite> to
fix the cache and key parameters of <cite>cache_this</cite> and inject that.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@cache_property_method</span><span class="p">([</span><span class="s1">&#39;normal_method&#39;</span><span class="p">,</span> <span class="s1">&#39;property_method&#39;</span><span class="p">])</span>
<span class="gp">... </span><span class="k">class</span><span class="w"> </span><span class="nc">TestClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">normal_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;normal_method called&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nd">@property</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">property_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;property_method called&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">TestClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">normal_method</span>
<span class="go">normal_method called</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">normal_method</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">property_method</span>
<span class="go">property_method called</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">property_method</span>
<span class="go">2</span>
</pre></div>
</div>
<p>You can also use it like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">TestClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">normal_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;normal_method called&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nd">@property</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">property_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;property_method called&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache_property_method</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">TestClass</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="s1">&#39;normal_method&#39;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s1">&#39;property_method&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">],</span>
<span class="gp">... </span><span class="p">)</span>  
<span class="go">&lt;class ...TestClass&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">TestClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">normal_method</span>
<span class="go">normal_method called</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">normal_method</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">property_method</span>
<span class="go">property_method called</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">property_method</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.cache_this">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">cache_this</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">VT</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">MutableMapping</span><span class="p"><span class="pre">[</span></span><span class="pre">KT</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">VT</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">KT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">KT</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_cache</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">MutableMapping</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_property</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">serialize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deserialize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#cache_this"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.cache_this" title="Link to this definition"></a></dt>
<dd><p>Unified caching decorator for properties and methods with persistent storage support.</p>
<p><cite>cache_this</cite> extends the capabilities of Python’s built-in <cite>functools.cached_property</cite>
and <cite>functools.lru_cache</cite> by providing:</p>
<ul class="simple">
<li><p><strong>Persistent caching</strong>: Store cached values in files, databases, or any MutableMapping</p></li>
<li><p><strong>Flexible cache backends</strong>: Use instance attributes, external stores, or cache factories</p></li>
<li><p><strong>Smart key generation</strong>: Automatic argument-based keys for methods with parameter filtering</p></li>
<li><p><strong>Serialization support</strong>: Custom serialize/deserialize functions for complex data</p></li>
<li><p><strong>Auto-detection</strong>: Automatically chooses property vs method caching based on signature</p></li>
<li><p><strong>No LRU eviction</strong>: Unlike lru_cache, values persist until explicitly removed</p></li>
</ul>
<p>Unlike functools.cached_property (properties only) and lru_cache (memory-only with eviction),
cache_this provides a unified interface for both use cases with persistent storage options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – The function to be decorated (usually left empty).</p></li>
<li><p><strong>cache</strong> – <p>The cache storage. Can be:
- A MutableMapping instance (shared across instances)
- A string naming an instance attribute containing a MutableMapping
- A callable taking (instance) and returning a MutableMapping</p>
<blockquote>
<div><p>This enables instance-specific caching, e.g.:
cache=lambda self: Files(f’/cache/{self.user_id}/’)</p>
</div></blockquote>
</p></li>
<li><p><strong>key</strong> – For properties: the key to store the cache value, can be a callable
that will be applied to the method name to make a key, or an explicit string.
For methods: a callable that takes (self, <a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs) and returns a cache key.</p></li>
<li><p><strong>pre_cache</strong> – Default is False. If True, adds an in-memory cache to the method
to (also) cache the results in memory. If a MutableMapping is given, it will be
used as the pre-cache.
This is useful when you want a persistent cache but also want to speed up
access to the method in the same session.</p></li>
<li><p><strong>as_property</strong> – If True, force use of CachedProperty. If False, force use of
CachedMethod. If None (default), auto-detect based on function signature.</p></li>
<li><p><strong>ignore</strong> – Parameter name(s) to exclude from cache key computation.
Can be a string (single parameter) or list of strings (multiple parameters).
Commonly used to ignore ‘self’ or parameters like ‘verbose’ that don’t
affect the result.</p></li>
<li><p><strong>serialize</strong> – Optional function to serialize values before caching.
Example: serialize=pickle.dumps for binary file storage</p></li>
<li><p><strong>deserialize</strong> – Optional function to deserialize cached values.
Example: deserialize=pickle.loads</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The decorated function.</p>
</dd>
</dl>
<p>## Comprehensive Example</p>
<p>Here’s a complete example showcasing all major features of cache_this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">DataProcessor</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_id</span><span class="o">=</span><span class="s2">&quot;user123&quot;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">user_id</span> <span class="o">=</span> <span class="n">user_id</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">memory_cache</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># In-memory cache</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span> <span class="o">=</span> <span class="p">{}</span>   <span class="c1"># Track function calls for demo</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># 1. Basic property caching (like functools.cached_property)</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">basic_property</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span><span class="w">        </span><span class="sd">&#39;&#39;&#39;Cached in instance.__dict__ by default&#39;&#39;&#39;</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="s1">&#39;basic_property&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;basic_property&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;computed_value_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="s1">&#39;basic_property&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># 2. Property with custom cache and key</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="s1">&#39;memory_cache&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;custom_prop_key&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">custom_cached_property</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span><span class="w">        </span><span class="sd">&#39;&#39;&#39;Cached in instance.memory_cache with custom key&#39;&#39;&#39;</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="s1">&#39;custom_cached_property&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;custom_cached_property&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;custom_value_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="s1">&#39;custom_cached_property&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># 3. Method caching with argument-based keys</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="s1">&#39;memory_cache&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">compute_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;fast&#39;</span><span class="p">):</span>
<span class="gp">... </span><span class="w">        </span><span class="sd">&#39;&#39;&#39;Cached based on arguments (x, y, mode)&#39;&#39;&#39;</span>
<span class="gp">... </span>        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;compute_result&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fast&#39;</span> <span class="k">else</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># 4. Method caching with ignored parameters</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="s1">&#39;memory_cache&#39;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;verbose&#39;</span><span class="p">,</span> <span class="s1">&#39;debug&#39;</span><span class="p">})</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span><span class="w">        </span><span class="sd">&#39;&#39;&#39;Cache ignores verbose and debug parameters&#39;&#39;&#39;</span>
<span class="gp">... </span>        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;process_data&#39;</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">algorithm</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">algorithm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">algorithm</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="k">else</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="c1"># 5. Instance-specific cache factory</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="p">{</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s1">_cache&#39;</span><span class="p">:</span> <span class="p">{}}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">user_id</span><span class="si">}</span><span class="s1">_cache&#39;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">user_specific_computation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span><span class="w">        </span><span class="sd">&#39;&#39;&#39;Each instance gets its own cache based on user_id&#39;&#39;&#39;</span>
<span class="gp">... </span>        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;user_specific_computation&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">value</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Now let’s test all the features:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">processor</span> <span class="o">=</span> <span class="n">DataProcessor</span><span class="p">(</span><span class="s2">&quot;alice&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test basic property caching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">basic_property</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">basic_property</span>  <span class="c1"># Should use cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result1</span> <span class="o">==</span> <span class="n">result2</span> <span class="o">==</span> <span class="s2">&quot;computed_value_1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">&#39;basic_property&#39;</span> <span class="ow">in</span> <span class="n">processor</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># Cached in instance dict</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test custom cache and key</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">custom_cached_property</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">custom_cached_property</span>  <span class="c1"># Should use cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result1</span> <span class="o">==</span> <span class="n">result2</span> <span class="o">==</span> <span class="s2">&quot;custom_value_1&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">&#39;custom_prop_key&#39;</span> <span class="ow">in</span> <span class="n">processor</span><span class="o">.</span><span class="n">memory_cache</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test method caching with arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">compute_result</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;fast&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">compute_result</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;fast&#39;</span><span class="p">)</span>  <span class="c1"># Should use cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result3</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">compute_result</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;slow&#39;</span><span class="p">)</span>  <span class="c1"># Different args, new computation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result1</span> <span class="o">==</span> <span class="n">result2</span> <span class="o">==</span> <span class="mi">24</span>  <span class="c1"># 3 * 4 * 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result3</span> <span class="o">==</span> <span class="mi">36</span>  <span class="c1"># 3 * 4 * 3</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test parameter ignoring</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_data</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Processing [1, 2, 3] with default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_data</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># Should use same cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result3</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">process_data</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>     <span class="c1"># Should use same cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result1</span> <span class="o">==</span> <span class="n">result2</span> <span class="o">==</span> <span class="n">result3</span> <span class="o">==</span> <span class="mi">12</span>  <span class="c1"># sum([1,2,3]) * 2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test instance-specific caching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result1</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">user_specific_computation</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result2</span> <span class="o">=</span> <span class="n">processor</span><span class="o">.</span><span class="n">user_specific_computation</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Should use cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result1</span> <span class="o">==</span> <span class="n">result2</span> <span class="o">==</span> <span class="mi">25</span>  <span class="c1"># 5 ** 2</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Different instance should have separate cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processor2</span> <span class="o">=</span> <span class="n">DataProcessor</span><span class="p">(</span><span class="s2">&quot;bob&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result3</span> <span class="o">=</span> <span class="n">processor2</span><span class="o">.</span><span class="n">user_specific_computation</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># Fresh computation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">result3</span> <span class="o">==</span> <span class="mi">25</span>
</pre></div>
</div>
<p>Used with no arguments, <cite>cache_this</cite> will cache just as the builtin
<cite>cached_property</cite> does – in the instance’s <cite>__dict__</cite> attribute.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">SameAsCachedProperty</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In SameAsCachedProperty.foo...&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SameAsCachedProperty</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># the cache is empty</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>  <span class="c1"># when we access foo, it&#39;s computed and returned...</span>
<span class="go">In SameAsCachedProperty.foo...</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>  <span class="c1"># ... but also cached</span>
<span class="go">{&#39;foo&#39;: 42}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>  <span class="c1"># so that the next time we access foo, it&#39;s returned from the cache.</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Not that if you specify <cite>cache=False</cite>, you get a property that is computed
every time it’s accessed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">NoCache</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In NoCache.foo...&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">NoCache</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In NoCache.foo...</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In NoCache.foo...</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Specify the cache as a dictionary that lives outside the instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">external_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">CacheWithExternalMapping</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="n">external_cache</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In CacheWithExternalMapping.foo...&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">CacheWithExternalMapping</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">external_cache</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In CacheWithExternalMapping.foo...</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">external_cache</span>
<span class="go">{&#39;foo&#39;: 42}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Specify the cache as an attribute of the instance, and an explicit key:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">WithCacheInInstanceAttribute</span><span class="p">:</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">my_cache</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nd">@cache_this</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="s1">&#39;my_cache&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;key_for_foo&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In WithCacheInInstanceAttribute.foo...&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">WithCacheInInstanceAttribute</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">my_cache</span>
<span class="go">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In WithCacheInInstanceAttribute.foo...</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">my_cache</span>
<span class="go">{&#39;key_for_foo&#39;: 42}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Now let’s see a more involved example that exhibits how <cite>cache_this</cite> would be used
in real life. Note two things in the example below.</p>
<p>First, that we use <cite>functools.partial</cite> to fix the parameters of our <cite>cache_this</cite>.
This enables us to reuse the same <cite>cache_this</cite> in multiple places without all
the verbosity. We fix that the cache is the attribute <cite>cache</cite> of the instance,
and that the key is a function that will be computed from the name of the method
adding a <cite>‘.pkl’</cite> extension to it.</p>
<p>Secondly, we use the <cite>ValueCodecs</cite> from <cite>dol</cite> to provide a pickle codec for storying
values. The backend store used here is a dictionary, so we don’t really need a
codec to store values, but in real life you would use a persistent storage that
would require a codec, such as files or a database.</p>
<p>Thirdly, we’ll use a <cite>pre_cache</cite> to store the values in a different cache “before”
(setting and getting) them in the main cache.
This is useful, for instance, when you want to persist the values (in the main
cache), but keep them in memory for faster access in the same session
(the pre-cache, a dict() instance usually). It can also be used to store and
use things locally (pre-cache) while sharing them with others by storing them in
a remote store (main cache).</p>
<p>Finally, we’ll use a dict that logs any setting and getting of values to show
how the caches are being used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol</span><span class="w"> </span><span class="kn">import</span> <span class="n">cache_this</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol</span><span class="w"> </span><span class="kn">import</span> <span class="n">ValueCodecs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">UserDict</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">LoggedCache</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;cache&#39;</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: setting </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;In </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: getting value of </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">CacheA</span><span class="p">(</span><span class="n">LoggedCache</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CacheA&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">CacheB</span><span class="p">(</span><span class="n">LoggedCache</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CacheB&#39;</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache_with_pickle</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">cache_this</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">cache</span><span class="o">=</span><span class="s1">&#39;cache&#39;</span><span class="p">,</span>  <span class="c1"># the cache can be found on the instance attribute `cache`</span>
<span class="gp">... </span>    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">,</span>  <span class="c1"># the key is the method name with a &#39;.pkl&#39; extension</span>
<span class="gp">... </span>    <span class="n">pre_cache</span><span class="o">=</span><span class="n">CacheB</span><span class="p">(),</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">PickleCached</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend_store_factory</span><span class="o">=</span><span class="n">CacheA</span><span class="p">):</span>
<span class="gp">... </span>        <span class="c1"># usually this would be a mapping interface to persistent storage:</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_backend_store</span> <span class="o">=</span> <span class="n">backend_store_factory</span><span class="p">()</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="n">ValueCodecs</span><span class="o">.</span><span class="n">default</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backend_store</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="nd">@cache_with_pickle</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;In PickleCached.foo...&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="mi">42</span>
<span class="gp">...</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">PickleCached</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="go">[]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In CacheA: getting value of foo.pkl</span>
<span class="go">In CacheA: getting value of foo.pkl</span>
<span class="go">In PickleCached.foo...</span>
<span class="go">In CacheA: setting foo.pkl to b&#39;\x80\x04K*.&#39;</span>
<span class="go">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">foo</span>
<span class="go">In CacheA: getting value of foo.pkl</span>
<span class="go">In CacheB: setting foo.pkl to 42</span>
<span class="go">42</span>
</pre></div>
</div>
<p>As usual, it’s because the cache now holds something that has to do with <cite>foo</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
<span class="go">[&#39;foo.pkl&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># == [&#39;foo.pkl&#39;]</span>
</pre></div>
</div>
<p>The value of <cite>‘foo.pkl’</cite> is indeed <cite>42</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="s1">&#39;foo.pkl&#39;</span><span class="p">]</span>
<span class="go">In CacheA: getting value of foo.pkl</span>
<span class="go">42</span>
</pre></div>
</div>
<p>But note that the actual way it’s stored in the <cite>_backend_store</cite> is as pickle bytes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">_backend_store</span><span class="p">[</span><span class="s1">&#39;foo.pkl&#39;</span><span class="p">]</span>
<span class="go">In CacheA: getting value of foo.pkl</span>
<span class="go">b&#39;\x80\x04K*.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># == b&#39;\x80\x04K*.&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.cache_vals">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">cache_vals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache=&lt;class</span> <span class="pre">'dict'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__module__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__name__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__qualname__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__doc__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__annotations__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__defaults__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__kwdefaults__=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#cache_vals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.cache_vals" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The class of the store you want to cache</p></li>
<li><p><strong>cache</strong> – The store you want to use to cache. Anything with a __setitem__(k, v) and a __getitem__(k).
By default, it will use a dict</p></li>
</ul>
</dd>
</dl>
<p>Returns: A subclass of the input store, but with caching (to the cache store)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.caching</span><span class="w"> </span><span class="kn">import</span> <span class="n">cache_vals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">SlowDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sleep_s</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sleep_s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">SlowDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>  <span class="c1"># Wow! Takes a long time to get &#39;a&#39;</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CachedSlowDict</span> <span class="o">=</span> <span class="n">cache_vals</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="n">SlowDict</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">CachedSlowDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: []</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This will take a LONG time because it&#39;s the first time we ask for &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This will take very little time because we have &#39;a&#39; in the cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But we don&#39;t have &#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But now we have &#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># and we can do things normally (like put stuff in the store)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>  <span class="c1"># if we ask for it again though, it will take time (the first time)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Of course, we could write &#39;d&#39; in the cache as well, to get it quicker,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but that&#39;s another story: The story of write caches!</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And by the way, your &quot;cache wrapped&quot; store hold a pointer to the cache it&#39;s using,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so you can take a peep there if needed:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_cache</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;d&#39;: 4}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.cached_method">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">cached_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#cached_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.cached_method" title="Link to this definition"></a></dt>
<dd><p>A decorator to cache the result of a method, ignoring the first argument (usually <cite>self</cite>).</p>
<p>This decorator uses <cite>functools.lru_cache</cite> to cache the method result based on the arguments passed
to the method, excluding the first argument (typically <cite>self</cite>). This allows methods of a class to
be cached while ignoring the instance (<cite>self</cite>) in the cache key.</p>
<p>Parameters:
- func (callable, optional): The method to be decorated. If not provided, a partially applied decorator</p>
<blockquote>
<div><p>will be returned for later application.</p>
</div></blockquote>
<ul class="simple">
<li><p>maxsize (int, optional): The maximum size of the cache. Defaults to 128.</p></li>
<li><p>typed (bool, optional): If True, cache entries will be different based on argument types, such as
distinguishing between <cite>1</cite> and <cite>1.0</cite>. Defaults to False.</p></li>
</ul>
<p>Returns:
- callable: A wrapped function with LRU caching applied, ignoring the first argument (<cite>self</cite>).</p>
<p>Example:
&gt;&gt;&gt; class MyClass:
…     &#64;cached_method(maxsize=2, typed=True)
…     def add(self, x, y):
…         print(f”Computing {x} + {y}”)
…         return x + y
…
&gt;&gt;&gt; obj = MyClass()
&gt;&gt;&gt; obj.add(1, 2)
Computing 1 + 2
3
&gt;&gt;&gt; obj.add(1, 2)  # Cached result, no recomputation
3
&gt;&gt;&gt; obj.add(1.0, 2.0)  # Different types, recomputation occurs
Computing 1.0 + 2.0
3.0</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.ensure_clear_to_kv_store">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">ensure_clear_to_kv_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#ensure_clear_to_kv_store"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.ensure_clear_to_kv_store" title="Link to this definition"></a></dt>
<dd><p>Ensures the store has a working clear method.</p>
<p>If the store doesn’t have a clear method or has the disabled version,
adds a proper implementation that safely removes all items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>store</strong> – A Store class or instance</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The same store with guaranteed clear functionality</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">NoClearing</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">clear</span> <span class="o">=</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">NoClearing</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">ensure_clear_to_kv_store</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.get_cache">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">get_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cache</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#get_cache"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.get_cache" title="Link to this definition"></a></dt>
<dd><p>Convenience function to get a cache (whether it’s already an instance, or needs to be validated).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_cache</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>  <span class="c1"># Return existing cache instance</span>
<span class="go">{&#39;a&#39;: 1}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_cache</span><span class="p">(</span><span class="nb">dict</span><span class="p">)()</span>  <span class="c1"># Return result of calling cache factory</span>
<span class="go">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.identity">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">identity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">T</span></span></span><a class="reference internal" href="../../_modules/dol/caching.html#identity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.identity" title="Link to this definition"></a></dt>
<dd><p>Identity function that returns its input unchanged.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.is_a_cache">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">is_a_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#is_a_cache"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.is_a_cache" title="Link to this definition"></a></dt>
<dd><p>Check if an object implements the cache interface.</p>
<p>A cache object must have __contains__, __getitem__, and __setitem__ methods.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">is_a_cache</span><span class="p">({})</span>  <span class="c1"># dict is a valid cache</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_a_cache</span><span class="p">([])</span>  <span class="c1"># list has these methods but for indexed access</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_a_cache</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">)</span>  <span class="c1"># string is not (immutable)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.lru_cache_method">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">lru_cache_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">128</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">typed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#lru_cache_method"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.lru_cache_method" title="Link to this definition"></a></dt>
<dd><p>A decorator to cache the result of a method, ignoring the first argument
(usually <cite>self</cite>).</p>
<p>This decorator uses <cite>functools.lru_cache</cite> to cache the method result based on the arguments passed
to the method, excluding the first argument (typically <cite>self</cite>). This allows methods of a class to
be cached while ignoring the instance (<cite>self</cite>) in the cache key.</p>
<p>Parameters:
- func (callable, optional): The method to be decorated. If not provided, a partially applied decorator</p>
<blockquote>
<div><p>will be returned for later application.</p>
</div></blockquote>
<ul class="simple">
<li><p>maxsize (int, optional): The maximum size of the cache. Defaults to 128.</p></li>
<li><p>typed (bool, optional): If True, cache entries will be different based on argument types, such as
distinguishing between <cite>1</cite> and <cite>1.0</cite>. Defaults to False.</p></li>
</ul>
<p>Returns:
- callable: A wrapped function with LRU caching applied, ignoring the first argument (<cite>self</cite>).</p>
<p>Example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@lru_cache_method</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Computing 1 + 2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Cached result, no recomputation</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Like <cite>lru_cache</cite>, you can specify the <cite>maxsize</cite> and <cite>typed</cite> parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyOtherClass</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nd">@lru_cache_method</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyOtherClass</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">Computing 1 + 2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Cached result, no recomputation</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>  <span class="c1"># Different types, recomputation occurs</span>
<span class="go">Computing 1.0 + 2.0</span>
<span class="go">3.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.mk_cached_store">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">mk_cached_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache=&lt;class</span> <span class="pre">'dict'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__module__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__name__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__qualname__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__doc__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__annotations__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__defaults__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__kwdefaults__=None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.caching.mk_cached_store" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The class of the store you want to cache</p></li>
<li><p><strong>cache</strong> – The store you want to use to cache. Anything with a __setitem__(k, v) and a __getitem__(k).
By default, it will use a dict</p></li>
</ul>
</dd>
</dl>
<p>Returns: A subclass of the input store, but with caching (to the cache store)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.caching</span><span class="w"> </span><span class="kn">import</span> <span class="n">cache_vals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">SlowDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sleep_s</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sleep_s</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">SlowDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>  <span class="c1"># Wow! Takes a long time to get &#39;a&#39;</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">CachedSlowDict</span> <span class="o">=</span> <span class="n">cache_vals</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="n">SlowDict</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">CachedSlowDict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: []</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This will take a LONG time because it&#39;s the first time we ask for &#39;a&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># This will take very little time because we have &#39;a&#39; in the cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But we don&#39;t have &#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But now we have &#39;b&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># and we can do things normally (like put stuff in the store)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">]</span>  <span class="c1"># if we ask for it again though, it will take time (the first time)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">cache: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">store: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="go">cache: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Of course, we could write &#39;d&#39; in the cache as well, to get it quicker,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but that&#39;s another story: The story of write caches!</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And by the way, your &quot;cache wrapped&quot; store hold a pointer to the cache it&#39;s using,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># so you can take a peep there if needed:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_cache</span>
<span class="go">{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;d&#39;: 4}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.mk_memoizer">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">mk_memoizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cache</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#mk_memoizer"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.mk_memoizer" title="Link to this definition"></a></dt>
<dd><p>Make a memoizer that caches the output of a getter function in a cache.</p>
<p>Note: This is a specialized memoizer for getter functions/methods, i.e.
functions/methods that have the signature (instance, key) and return a value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cache</strong> – The cache to use. Must have __getitem__ and __setitem__ methods.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A memoizer that caches the output of the function in the cache.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@mk_memoizer</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">getter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;getting value for </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">getting value for 2...</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">getter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">20</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.mk_sourced_store">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">mk_sourced_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_source_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__module__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__name__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__qualname__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__doc__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__annotations__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__defaults__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__kwdefaults__</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#mk_sourced_store"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.mk_sourced_store" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The class of the store you want to cache</p></li>
<li><p><strong>cache</strong> – The store you want to use to cache. Anything with a __setitem__(k, v) and a __getitem__(k).
By default, it will use a dict</p></li>
<li><p><strong>return_source_data</strong></p></li>
</ul>
</dd>
</dl>
<p>Returns: A subclass of the input store, but with caching (to the cache store)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The class of the store you’re talking to. This store acts as the cache</p></li>
<li><p><strong>source</strong> – The store that is used to populate the store (cache) when a key is missing there.</p></li>
<li><p><strong>return_source_data</strong> – If True, will return <code class="docutils literal notranslate"><span class="pre">source[k]</span></code> as is. This should be used only if <code class="docutils literal notranslate"><span class="pre">store[k]</span></code> would return the same.
If False, will first write to cache (<code class="docutils literal notranslate"><span class="pre">store[k]</span> <span class="pre">=</span> <span class="pre">source[k]</span></code>) then return <code class="docutils literal notranslate"><span class="pre">store[k]</span></code>.
The latter introduces a performance hit (we write and then read again from the cache),
but ensures consistency (and is useful if the writing or the reading to/from store
transforms the data in some way.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A decorated store</p>
</dd>
</dl>
<p>Here are two stores pretending to be local and remote data stores respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.caching</span><span class="w"> </span><span class="kn">import</span> <span class="n">mk_sourced_store</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Local</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;looking for </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> in Local&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Remote</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;looking for </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> in Remote&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s make a remote store with two elements in it, and a local store class that asks the remote store for stuff
if it can’t find it locally.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">remote</span> <span class="o">=</span> <span class="n">Remote</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;hello&#39;</span><span class="p">:</span> <span class="s1">&#39;world&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SourcedLocal</span> <span class="o">=</span> <span class="n">mk_sourced_store</span><span class="p">(</span><span class="n">Local</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">remote</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SourcedLocal</span><span class="p">({</span><span class="s1">&#39;some&#39;</span><span class="p">:</span> <span class="s1">&#39;local stuff&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># the local store has one key</span>
<span class="go">[&#39;some&#39;]</span>
</pre></div>
</div>
<p># but if we ask for a key that is in the remote store, it provides it</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span>
<span class="go">looking for foo in Local</span>
<span class="go">looking for foo in Remote</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;some&#39;, &#39;foo&#39;]</span>
</pre></div>
</div>
<p>See that next time we ask for the ‘foo’ key, the local store provides it:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span>
<span class="go">looking for foo in Local</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span>
<span class="go">looking for hello in Local</span>
<span class="go">looking for hello in Remote</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;some&#39;, &#39;foo&#39;, &#39;hello&#39;]</span>
</pre></div>
</div>
<p>We can still add stuff (locally)…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;something&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;else&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;some&#39;, &#39;foo&#39;, &#39;hello&#39;, &#39;something&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.mk_write_cached_store">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">mk_write_cached_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_cache=&lt;class</span> <span class="pre">'dict'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flush_cache_condition=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__module__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__name__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__qualname__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__doc__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__annotations__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__defaults__=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">__kwdefaults__=None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#mk_write_cached_store"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.mk_write_cached_store" title="Link to this definition"></a></dt>
<dd><p>Wrap a write cache around a store.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>w_cache</strong> – The store to (write) cache to</p></li>
<li><p><strong>flush_cache_condition</strong> – The condition to apply to the cache
to decide whether it’s contents should be flushed or not</p></li>
</ul>
</dd>
</dl>
<p>A <code class="docutils literal notranslate"><span class="pre">w_cache</span></code> must have a clear method (that clears the cache’s contents).
If you know what you’re doing and want to add one to your input kv store,
you can do so by calling <code class="docutils literal notranslate"><span class="pre">ensure_clear_to_kv_store(store)</span></code>
– this will add a <code class="docutils literal notranslate"><span class="pre">clear</span></code> method inplace AND return the resulting store as well.</p>
<p>We didn’t add this automatically because the first thing <code class="docutils literal notranslate"><span class="pre">mk_write_cached_store</span></code> will do is call clear,
to remove all the contents of the store.
You don’t want to do this unwittingly and delete a bunch of precious data!!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.caching</span><span class="w"> </span><span class="kn">import</span> <span class="n">mk_write_cached_store</span><span class="p">,</span> <span class="n">ensure_clear_to_kv_store</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">dol.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">Store</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">print_state</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;store: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2"> ----- store._w_cache: </span><span class="si">{</span><span class="n">store</span><span class="o">.</span><span class="n">_w_cache</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyStore</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyCachedStore</span> <span class="o">=</span> <span class="n">mk_write_cached_store</span><span class="p">(</span><span class="n">MyStore</span><span class="p">,</span> <span class="n">w_cache</span><span class="o">=</span><span class="p">{})</span>  <span class="c1"># wrap MyStore with a (dict) write cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">MyCachedStore</span><span class="p">()</span>  <span class="c1"># make a MyCachedStore instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># print the contents (both store and cache), see that it&#39;s empty</span>
<span class="go">store: {} ----- store._w_cache: {}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span>  <span class="c1"># write &#39;world&#39; in &#39;hello&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># see that it hasn&#39;t been written</span>
<span class="go">store: {} ----- store._w_cache: {&#39;hello&#39;: &#39;world&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;ding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;dong&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">store: {} ----- store._w_cache: {&#39;hello&#39;: &#39;world&#39;, &#39;ding&#39;: &#39;dong&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">flush_cache</span><span class="p">()</span>  <span class="c1"># manually flush the cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># note that store._w_cache is empty, but store has the data now</span>
<span class="go">store: {&#39;hello&#39;: &#39;world&#39;, &#39;ding&#39;: &#39;dong&#39;} ----- store._w_cache: {}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But you usually want to use the store as a context manager</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyCachedStore</span> <span class="o">=</span> <span class="n">mk_write_cached_store</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MyStore</span><span class="p">,</span> <span class="n">w_cache</span><span class="o">=</span><span class="p">{},</span>
<span class="gp">... </span>    <span class="n">flush_cache_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">the_persistent_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">MyCachedStore</span><span class="p">(</span><span class="n">the_persistent_dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===&gt; Before writing data:&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">s</span><span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;world&#39;</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===&gt; Before exiting the with block:&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">===&gt; Before writing data:</span>
<span class="go">store: {} ----- store._w_cache: {}</span>
<span class="go">===&gt; Before exiting the with block:</span>
<span class="go">store: {} ----- store._w_cache: {&#39;hello&#39;: &#39;world&#39;}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;===&gt; After exiting the with block:&quot;</span><span class="p">);</span> <span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># Note that the cache store flushed!</span>
<span class="go">===&gt; After exiting the with block:</span>
<span class="go">store: {&#39;hello&#39;: &#39;world&#39;} ----- store._w_cache: {}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of auto-flushing when there&#39;s at least two elements</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">MyStore</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyCachedStore</span> <span class="o">=</span> <span class="n">mk_write_cached_store</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">MyStore</span><span class="p">,</span> <span class="n">w_cache</span><span class="o">=</span><span class="p">{},</span>
<span class="gp">... </span>    <span class="n">flush_cache_condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">w_cache</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">w_cache</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">MyCachedStore</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">10</span>
<span class="gp">... </span>        <span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">store: {} ----- store._w_cache: {0: 0}</span>
<span class="go">store: {} ----- store._w_cache: {0: 0, 1: 10}</span>
<span class="go">store: {0: 0, 1: 10, 2: 20} ----- store._w_cache: {}</span>
<span class="go">store: {0: 0, 1: 10, 2: 20} ----- store._w_cache: {3: 30}</span>
<span class="go">store: {0: 0, 1: 10, 2: 20} ----- store._w_cache: {3: 30, 4: 40}</span>
<span class="go">store: {0: 0, 1: 10, 2: 20, 3: 30, 4: 40, 5: 50} ----- store._w_cache: {}</span>
<span class="go">store: {0: 0, 1: 10, 2: 20, 3: 30, 4: 40, 5: 50} ----- store._w_cache: {6: 60}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># There was still something left in the cache before exiting the with block. But now...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">print_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">store: {0: 0, 1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60} ----- store._w_cache: {}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.register_key_strategy">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">register_key_strategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#register_key_strategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.register_key_strategy" title="Link to this definition"></a></dt>
<dd><p>Register a class as a KeyStrategy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.store_cached">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">store_cached</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#store_cached"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.store_cached" title="Link to this definition"></a></dt>
<dd><p>Function output memorizer but using a specific (usually persisting) store as it’s
memory and a key_func to compute the key under which to store the output.</p>
<p>The key can be
- a single value under which the output should be stored, regardless of the input.
- a key function that is called on the inputs to create a hash under which the function’s output should be stored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The key-value store to use for caching. Must support __getitem__ and __setitem__.</p></li>
<li><p><strong>key_func</strong> – The key function that is called on the input of the function to create the key value.</p></li>
</ul>
</dd>
</dl>
<p>Note: Union[Callable, Any] is equivalent to just Any, but reveals the two cases of a key more clearly.
Note: No, Union[Callable, Hashable] is not better. For one, general store keys are not restricted to hashable keys.
Note: No, they shouldn’t.</p>
<p>See Also: store_cached_with_single_key (for a version where the cache store key doesn’t depend on function’s args)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: Our doc test will use dict as the store, but to make the functionality useful beyond existing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># RAM-memorizer, you should use actual &quot;persisting&quot; stores that store in local files, or DBs, etc.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@store_cached</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">args</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">my_data</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pretend this is a long computation&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># note the print below (because the function is called</span>
<span class="go">Pretend this is a long computation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># note there&#39;s no print (because the function is NOT called)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="n">tt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_data</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># but different inputs will trigger the actual function again</span>
<span class="go">Pretend this is a long computation</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_data</span><span class="o">.</span><span class="n">_cache</span>
<span class="go">{(1, 2): 3, (3, 4): 7}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dol.caching.store_cached_with_single_key">
<span class="sig-prename descclassname"><span class="pre">dol.caching.</span></span><span class="sig-name descname"><span class="pre">store_cached_with_single_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/caching.html#store_cached_with_single_key"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#dol.caching.store_cached_with_single_key" title="Link to this definition"></a></dt>
<dd><p>Function output memorizer but using a specific store and key as its memory.</p>
<p>Use in situations where you have a argument-less function or bound method that computes some data whose dependencies
are static enough that there’s enough advantage to make the data refresh explicit (by deleting the cache entry)
instead of making it implicit (recomputing/refetching the data every time).</p>
<p>The key should be a single value under which the output should be stored, regardless of the input.</p>
<p>Note: The wrapped function comes with a empty_cache attribute, which when called, empties the cache (i.e. removes
the key from the store)</p>
<p>Note: The wrapped function has a hidden <cite>_cache</cite> attribute pointing to the store in case you need to peep into it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The cache. The key-value store to use for caching. Must support __getitem__ and __setitem__.</p></li>
<li><p><strong>key</strong> – The store key under which to store the output of the function.</p></li>
</ul>
</dd>
</dl>
<p>Note: Union[Callable, Any] is equivalent to just Any, but reveals the two cases of a key more clearly.
Note: No, Union[Callable, Hashable] is not better. For one, general store keys are not restricted to hashable keys.
Note: No, they shouldn’t.</p>
<p>See Also: store_cached (for a version whose keys are computed from the wrapped function’s input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: Our doc test will use dict as the store, but to make the functionality useful beyond existing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># RAM-memorizer, you should use actual &quot;persisting&quot; stores that store in local files, or DBs, etc.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">store</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@store_cached_with_single_key</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;whatevs&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span><span class="w"> </span><span class="nf">my_data</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Pretend this is a long computation&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">()</span>  <span class="c1"># note the print below (because the function is called</span>
<span class="go">Pretend this is a long computation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">()</span>  <span class="c1"># note there&#39;s no print (because the function is NOT called)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="n">tt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_data</span><span class="o">.</span><span class="n">_cache</span>  <span class="c1"># peep in the cache</span>
<span class="go">{&#39;whatevs&#39;: [1, 2, 3]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># let&#39;s empty the cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_data</span><span class="o">.</span><span class="n">empty_cache_entry</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="s1">&#39;whatevs&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_data</span><span class="o">.</span><span class="n">_cache</span>  <span class="c1"># see that the cache entry is gone.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">()</span>  <span class="c1"># so when you call the function again, it prints again!d</span>
<span class="go">Pretend this is a long computation</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="base.html" class="btn btn-neutral float-left" title="dol.base" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="dig.html" class="btn btn-neutral float-right" title="dol.dig" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>