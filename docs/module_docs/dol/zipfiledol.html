<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.zipfiledol &mdash; dol 0.1.136 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="dol.util" href="util.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">dol.util</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">dol.zipfiledol</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/module_docs/dol/zipfiledol.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-dol.zipfiledol">
<span id="dol-zipfiledol"></span><h1>dol.zipfiledol<a class="headerlink" href="#module-dol.zipfiledol" title="Permalink to this headline">¶</a></h1>
<p>Data object layers and other utils to work with zip files.</p>
<dl class="py exception">
<dt id="dol.zipfiledol.EmptyZipError">
<em class="property">exception </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">EmptyZipError</code><a class="reference internal" href="../../_modules/dol/zipfiledol.html#EmptyZipError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.EmptyZipError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.FileStreamsOfZip">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">FileStreamsOfZip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_file</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">open_kws</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#FileStreamsOfZip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.FileStreamsOfZip" title="Permalink to this definition">¶</a></dt>
<dd><p>Like FilesOfZip, but object returns are file streams instead.
So you use it like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">FileStreamsOfZip</span><span class="p">(</span><span class="n">rootdir</span><span class="p">)</span>
<span class="k">with</span> <span class="n">z</span><span class="p">[</span><span class="n">relpath</span><span class="p">]</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="o">...</span>  <span class="c1"># do stuff with fp, like fp.readlines() or such...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.FilesOfZip">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">FilesOfZip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_file</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">open_kws</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#FilesOfZip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.FilesOfZip" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.FlatZipFilesReader">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">FlatZipFilesReader</code><span class="sig-paren">(</span><em class="sig-param">rootdir</em>, <em class="sig-param">subpath='.+\\.zip'</em>, <em class="sig-param">pattern_for_field=None</em>, <em class="sig-param">max_levels=0</em>, <em class="sig-param">zip_reader=&lt;class 'dol.zipfiledol.ZipReader'&gt;</em>, <em class="sig-param">**zip_reader_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#FlatZipFilesReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.FlatZipFilesReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the union of the contents of multiple zip files.
A local file reader whose keys are the zip filepaths of the rootdir and values are
corresponding ZipReaders.</p>
<p>Example use case:</p>
<p>A remote data provider creates snapshots of whatever changed (modified files and new
ones…) since the last snapshot, dumping snapshot zip files in a specic
accessible location.</p>
<p>You make <cite>remote</cite> and <cite>local</cite> stores and can update your local. Then you can perform
syncing actions such as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">missing_keys</span> <span class="o">=</span> <span class="n">remote</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">local</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="n">local</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">remote</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">missing_keys</span><span class="p">})</span>  <span class="c1"># downloads missing snapshots</span>
</pre></div>
</div>
<p>The data will look something like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dump_folder</span><span class="o">/</span>
   <span class="mf">2021_09_11.</span><span class="n">zip</span>
   <span class="mf">2021_09_12.</span><span class="n">zip</span>
   <span class="mf">2021_09_13.</span><span class="n">zip</span>
   <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>both on remote and local.</p>
<p>What should then local do to use this data?
Unzip and merge?</p>
<p>Well, one solution, provided through FlatZipFilesReader, is to not unzip at all,
but instead, give you a store that provides you a view “as if you unzipped and
merged”.</p>
</dd></dl>

<dl class="py exception">
<dt id="dol.zipfiledol.OverwriteNotAllowed">
<em class="property">exception </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">OverwriteNotAllowed</code><a class="reference internal" href="../../_modules/dol/zipfiledol.html#OverwriteNotAllowed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.OverwriteNotAllowed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipFileStreamsReader">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipFileStreamsReader</code><span class="sig-paren">(</span><em class="sig-param">rootdir</em>, <em class="sig-param">subpath='.+\\.zip'</em>, <em class="sig-param">pattern_for_field=None</em>, <em class="sig-param">max_levels=0</em>, <em class="sig-param">*</em>, <em class="sig-param">zip_reader=&lt;class 'dol.zipfiledol.FileStreamsOfZip'&gt;</em>, <em class="sig-param">**zip_reader_kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#dol.zipfiledol.ZipFileStreamsReader" title="Permalink to this definition">¶</a></dt>
<dd><p>Like ZipFilesReader, but objects returned are file streams instead.</p>
</dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipFilesReader">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipFilesReader</code><span class="sig-paren">(</span><em class="sig-param">rootdir</em>, <em class="sig-param">subpath='.+\\.zip'</em>, <em class="sig-param">pattern_for_field=None</em>, <em class="sig-param">max_levels=0</em>, <em class="sig-param">zip_reader=&lt;class 'dol.zipfiledol.ZipReader'&gt;</em>, <em class="sig-param">**zip_reader_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#ZipFilesReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.ZipFilesReader" title="Permalink to this definition">¶</a></dt>
<dd><p>A local file reader whose keys are the zip filepaths of the rootdir and values are
corresponding ZipReaders.</p>
</dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipFilesReaderAndBytesWriter">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipFilesReaderAndBytesWriter</code><span class="sig-paren">(</span><em class="sig-param">rootdir</em>, <em class="sig-param">subpath='.+\\.zip'</em>, <em class="sig-param">pattern_for_field=None</em>, <em class="sig-param">max_levels=0</em>, <em class="sig-param">zip_reader=&lt;class 'dol.zipfiledol.ZipReader'&gt;</em>, <em class="sig-param">**zip_reader_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#ZipFilesReaderAndBytesWriter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.ZipFilesReaderAndBytesWriter" title="Permalink to this definition">¶</a></dt>
<dd><p>Like ZipFilesReader, but the ability to write bytes (assumed to be valid bytes of
the zip format) to a key</p>
</dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipInfoReader">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipInfoReader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_file</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">open_kws</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">file_info_filt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#ZipInfoReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.ZipInfoReader" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipReader">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipReader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_file</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">open_kws</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">file_info_filt</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#ZipReader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.ZipReader" title="Permalink to this definition">¶</a></dt>
<dd><p>A KvReader to read the contents of a zip file.
Provides a KV perspective of <a class="reference external" href="https://docs.python.org/3/library/zipfile.html">https://docs.python.org/3/library/zipfile.html</a></p>
<p><code class="docutils literal notranslate"><span class="pre">ZipReader</span></code> has two value categories: Directories and Files.
Both categories are distinguishable by the keys, through the “ends with slash” convention.</p>
<p>When a file, the value return is bytes, as usual.</p>
<p>When a directory, the value returned is a <code class="docutils literal notranslate"><span class="pre">ZipReader</span></code> itself, with all params the same,
except for the <code class="docutils literal notranslate"><span class="pre">prefix</span></code></p>
<blockquote>
<div><p>which serves <cite>to specify the subfolder (that is, ``prefix`</cite> acts as a filter).</p>
</div></blockquote>
<p>Note: If you get data zipped by a mac, you might get some junk along with it.
Namely <cite>__MACOSX</cite> folders <cite>.DS_Store</cite> files. I won’t rant about it, since others have.
But you might find it useful to remove them from view. One choice is to use
<cite>dol.trans.filt_iter</cite>
to get a filtered view of the zips contents. In most cases, this should do the job:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># applied to store instance or class:</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">filt_iter</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__MACOSX&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;.DS_Store&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)(</span><span class="n">store</span><span class="p">)</span>
</pre></div>
</div>
<p>Another option is just to remove these from the zip file once and for all. In unix-like systems:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">zip</span> <span class="o">-</span><span class="n">d</span> <span class="n">filename</span><span class="o">.</span><span class="n">zip</span> <span class="n">__MACOSX</span><span class="o">/</span>\<span class="o">*</span>
<span class="nb">zip</span> <span class="o">-</span><span class="n">d</span> <span class="n">filename</span><span class="o">.</span><span class="n">zip</span> \<span class="o">*/.</span><span class="n">DS_Store</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># &gt;&gt;&gt; s = ZipReader(&#39;/path/to/some_zip_file.zip&#39;)</span>
<span class="c1"># &gt;&gt;&gt; len(s)</span>
<span class="c1"># 53432</span>
<span class="c1"># &gt;&gt;&gt; list(s)[:3]  # the first 3 elements (well... their keys)</span>
<span class="c1"># [&#39;odir/&#39;, &#39;odir/app/&#39;, &#39;odir/app/data/&#39;]</span>
<span class="c1"># &gt;&gt;&gt; list(s)[-3:]  # the last 3 elements (well... their keys)</span>
<span class="c1"># [&#39;odir/app/data/audio/d/1574287049078391/m/Ctor.json&#39;,</span>
<span class="c1">#  &#39;odir/app/data/audio/d/1574287049078391/m/intensity.json&#39;,</span>
<span class="c1">#  &#39;odir/app/data/run/status.json&#39;]</span>
<span class="c1"># &gt;&gt;&gt; # getting a file (note that by default, you get bytes, so need to decode)</span>
<span class="c1"># &gt;&gt;&gt; s[&#39;odir/app/data/run/status.json&#39;].decode()</span>
<span class="c1"># b&#39;{&quot;test_phase_number&quot;: 9, &quot;test_phase&quot;: &quot;TestActions.IGNORE_TEST&quot;, &quot;session_id&quot;: 0}&#39;</span>
<span class="c1"># &gt;&gt;&gt; # when you ask for the contents for a key that&#39;s a directory,</span>
<span class="c1"># &gt;&gt;&gt; # you get a ZipReader filtered for that prefix:</span>
<span class="c1"># &gt;&gt;&gt; s[&#39;odir/app/data/audio/&#39;]</span>
<span class="c1"># ZipReader(&#39;/path/to/some_zip_file.zip&#39;, &#39;odir/app/data/audio/&#39;, {}, &lt;function</span>
<span class="n">take_everything</span> <span class="n">at</span> <span class="mh">0x1538999e0</span><span class="o">&gt;</span><span class="p">)</span>
<span class="c1"># &gt;&gt;&gt; # Often, you only want files (not directories)</span>
<span class="c1"># &gt;&gt;&gt; # You can filter directories out using the file_info_filt argument</span>
<span class="c1"># &gt;&gt;&gt; s = ZipReader(&#39;/path/to/some_zip_file.zip&#39;, file_info_filt=ZipReader.FILES_ONLY)</span>
<span class="c1"># &gt;&gt;&gt; len(s)  # compare to the 53432 above, that contained dirs too</span>
<span class="c1"># 53280</span>
<span class="c1"># &gt;&gt;&gt; list(s)[:3]  # first 3 keys are all files now</span>
<span class="c1"># [&#39;odir/app/data/plc/d/1574304926795633/d/1574305026895702&#39;,</span>
<span class="c1">#  &#39;odir/app/data/plc/d/1574304926795633/d/1574305276853053&#39;,</span>
<span class="c1">#  &#39;odir/app/data/plc/d/1574304926795633/d/1574305159343326&#39;]</span>
<span class="c1"># &gt;&gt;&gt;</span>
<span class="c1"># &gt;&gt;&gt; # ZipReader.FILES_ONLY and ZipReader.DIRS_ONLY are just convenience filt functions</span>
<span class="c1"># &gt;&gt;&gt; # Really, you can provide any custom one yourself.</span>
<span class="c1"># &gt;&gt;&gt; # This filter function should take a ZipInfo object, and return True or False.</span>
<span class="c1"># &gt;&gt;&gt; # (https://docs.python.org/3/library/zipfile.html#zipfile.ZipInfo)</span>
<span class="c1"># &gt;&gt;&gt;</span>
<span class="c1"># &gt;&gt;&gt; import re</span>
<span class="c1"># &gt;&gt;&gt; p = re.compile(&#39;audio.*\.json$&#39;)</span>
<span class="c1"># &gt;&gt;&gt; my_filt_func = lambda fileinfo: bool(p.search(fileinfo.filename))</span>
<span class="c1"># &gt;&gt;&gt; s = ZipReader(&#39;/Users/twhalen/Downloads/2019_11_21.zip&#39;, file_info_filt=my_filt_func)</span>
<span class="c1"># &gt;&gt;&gt; len(s)</span>
<span class="c1"># 48</span>
<span class="c1"># &gt;&gt;&gt; list(s)[:3]</span>
<span class="c1"># [&#39;odir/app/data/audio/d/1574333557263758/m/Ctor.json&#39;,</span>
<span class="c1">#  &#39;odir/app/data/audio/d/1574333557263758/m/intensity.json&#39;,</span>
<span class="c1">#  &#39;odir/app/data/audio/d/1574288084739961/m/Ctor.json&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="dol.zipfiledol.ZipStore">
<em class="property">class </em><code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">ZipStore</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_filepath</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">allow_overwrites</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pwd</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#ZipStore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.ZipStore" title="Permalink to this definition">¶</a></dt>
<dd><p>Zip read and writing.
When you want to read zips, there’s the <cite>FilesOfZip</cite>, <cite>ZipReader</cite>, or <cite>ZipFilesReader</cite> we
know and love.</p>
<p>Sometimes though, you want to write to zips too. For this, we have <cite>ZipStore</cite>.</p>
<p>Since ZipStore can write to a zip, it’s read functionality is not going to assume static data,
and cache things, as your favorite zip readers did.
This, and the acrobatics need to disguise the weird zipfile into something more… key-value
natural,
makes for a not so efficient store, out of the box.</p>
<dl class="simple">
<dt>I advise using one of the zip readers if all you need to do is read, or subclassing or</dt><dd><p>wrapping ZipStore with caching layers if it is appropriate to you.</p>
</dd>
</dl>
<p>Let’s verify that a ZipStore can indeed write data. First, we’ll set things up!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">gettempdir</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rootdir</span> <span class="o">=</span> <span class="n">gettempdir</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># preparation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">test_zipfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rootdir</span><span class="p">,</span> <span class="s1">&#39;zipstore_test_file.zip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">)</span>
</pre></div>
</div>
<p>Okay, test_zipfile doesn’t exist (but will soon…)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">ZipStore</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">)</span>
</pre></div>
</div>
<p>See that the file still doesn’t exist (it will only be created when we start writing)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># z &quot;is&quot; empty (which makes sense?)</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Now let’s write something interesting (notice, it has to be in bytes):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>  <span class="c1"># now we have something in z</span>
<span class="go">[&#39;foo&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>  <span class="c1"># and that thing is what we put there</span>
<span class="go">b&#39;bar&#39;</span>
</pre></div>
</div>
<p>And indeed we have a zip file now:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">test_zipfile</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.file_or_folder_to_zip_file">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">file_or_folder_to_zip_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_path</span><span class="p">:</span> <span class="n">str</span></em>, <em class="sig-param"><span class="n">zip_filepath</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">allow_overwrites</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pwd</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#file_or_folder_to_zip_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.file_or_folder_to_zip_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Zip input bytes and save to a single-file zip file.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.if_i_zipped_stats">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">if_i_zipped_stats</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">bytes</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#if_i_zipped_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.if_i_zipped_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress and decompress bytes with four different methods and return a dictionary
of (size and time) stats.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;x&#39;</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;y&#39;</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># 2000 (quite compressible) bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">if_i_zipped_stats</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  
<span class="go">{&#39;uncompressed&#39;: {&#39;bytes&#39;: 2000,</span>
<span class="go">  &#39;comp_time&#39;: 0,</span>
<span class="go">  &#39;uncomp_time&#39;: 0},</span>
<span class="go"> &#39;deflated&#39;: {&#39;bytes&#39;: 137,</span>
<span class="go">  &#39;comp_time&#39;: 0.00015592575073242188,</span>
<span class="go">  &#39;uncomp_time&#39;: 0.00012612342834472656},</span>
<span class="go"> &#39;bzip2&#39;: {&#39;bytes&#39;: 221,</span>
<span class="go">  &#39;comp_time&#39;: 0.0013129711151123047,</span>
<span class="go">  &#39;uncomp_time&#39;: 0.0011119842529296875},</span>
<span class="go"> &#39;lzma&#39;: {&#39;bytes&#39;: 206,</span>
<span class="go">  &#39;comp_time&#39;: 0.0058901309967041016,</span>
<span class="go">  &#39;uncomp_time&#39;: 0.0005228519439697266}}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.mk_flatzips_store">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">mk_flatzips_store</code><span class="sig-paren">(</span><em class="sig-param">dir_of_zips</em>, <em class="sig-param">zip_pair_path_preproc=&lt;built-in function sorted&gt;</em>, <em class="sig-param">mk_store=&lt;class 'dol.zipfiledol.FlatZipFilesReader'&gt;</em>, <em class="sig-param">**extra_mk_store_kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#mk_flatzips_store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.mk_flatzips_store" title="Permalink to this definition">¶</a></dt>
<dd><p>A store so that you can work with a folder that has a bunch of zip files,
as if they’ve all been extracted in the same folder.
Note that <cite>zip_pair_path_preproc</cite> can be used to control how to resolve key conflicts
(i.e. when you get two different zip files that have a same path in their contents).
The last path encountered by <cite>zip_pair_path_preproc(zip_path_pairs)</cite> is the one that
will be used, so one should make <cite>zip_pair_path_preproc</cite> act accordingly.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.remove_mac_junk_from_zip">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">remove_mac_junk_from_zip</code><span class="sig-paren">(</span><em class="sig-param">zip_source, *, keys_to_be_removed: Union[Callable[[str], bool], Iterable[str]] = &lt;function is_a_mac_junk_path&gt;, ask_before_before_deleting=False</em><span class="sig-paren">)</span><a class="headerlink" href="#dol.zipfiledol.remove_mac_junk_from_zip" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes mac junk keys from zip</p>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.remove_some_entries_from_zip">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">remove_some_entries_from_zip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">zip_source</span></em>, <em class="sig-param"><span class="n">keys_to_be_removed</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Callable<span class="p">[</span><span class="p">[</span>str<span class="p">]</span><span class="p">, </span>bool<span class="p">]</span><span class="p">, </span>Iterable<span class="p">[</span>str<span class="p">]</span><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">ask_before_before_deleting</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#remove_some_entries_from_zip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.remove_some_entries_from_zip" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes specific keys from a zip file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zip_source</strong> – zip filepath, bytes, or whatever a <code class="docutils literal notranslate"><span class="pre">ZipStore</span></code> can take</p></li>
<li><p><strong>keys_to_be_removed</strong> – An iterable of keys or a boolean filter function</p></li>
<li><p><strong>ask_before_before_deleting</strong> – True (default) if the user should be
presented with the keys first, and asked permission to delete.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The ZipStore (in case you want to do further work with it)</p>
</dd>
</dl>
<p>Tip: If you want to delete with no questions asked, use currying:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rm_keys_without_asking</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">remove_some_entries_from_zip</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">ask_before_before_deleting</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.to_zip_file">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">to_zip_file</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>bytes<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">zip_filepath</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">allow_overwrites</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">pwd</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/zipfiledol.html#to_zip_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.to_zip_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Zip input bytes and save to a single-file zip file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b</strong> – Input bytes or string</p></li>
<li><p><strong>zip_filepath</strong> – zip filepath to save the zipped input to</p></li>
<li><p><strong>filename</strong> – The name/path of the zip entry we want to save to</p></li>
<li><p><strong>encoding</strong> – In case the input is str, the encoding to use to convert to bytes</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.to_zipped_bytes">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">to_zipped_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>bytes<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">'some_bytes'</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">8</span></em>, <em class="sig-param"><span class="n">allowZip64</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">compresslevel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">strict_timestamps</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">encoding</span><span class="o">=</span><span class="default_value">'utf-8'</span></em><span class="sig-paren">)</span> &#x2192; bytes<a class="reference internal" href="../../_modules/dol/zipfiledol.html#to_zipped_bytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.to_zipped_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Compress input bytes, returning the compressed bytes</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;x&#39;</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">+</span> <span class="sa">b</span><span class="s1">&#39;y&#39;</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># 2000 (quite compressible) bytes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">2000</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped_bytes</span> <span class="o">=</span> <span class="n">to_zipped_bytes</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: Compression details will be system dependent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">zipped_bytes</span><span class="p">)</span>  
<span class="go">137</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unzipped_bytes</span> <span class="o">=</span> <span class="n">zipped_bytes_to_bytes</span><span class="p">(</span><span class="n">zipped_bytes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unzipped_bytes</span> <span class="o">==</span> <span class="n">b</span>  <span class="c1"># verify that unzipped bytes are the same as the original</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dol.zipfiledol</span> <span class="kn">import</span> <span class="n">compression_methods</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zipped_bytes</span> <span class="o">=</span> <span class="n">to_zipped_bytes</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression_methods</span><span class="p">[</span><span class="s1">&#39;bzip2&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note: Compression details will be system dependent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">zipped_bytes</span><span class="p">)</span>  
<span class="go">221</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unzipped_bytes</span> <span class="o">=</span> <span class="n">zipped_bytes_to_bytes</span><span class="p">(</span><span class="n">zipped_bytes</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unzipped_bytes</span> <span class="o">==</span> <span class="n">b</span>  <span class="c1"># verify that unzipped bytes are the same as the original</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.zipfiledol.zipped_bytes_to_bytes">
<code class="sig-prename descclassname">dol.zipfiledol.</code><code class="sig-name descname">zipped_bytes_to_bytes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">b</span><span class="p">:</span> <span class="n">bytes</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">allowZip64</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">compresslevel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">strict_timestamps</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span> &#x2192; bytes<a class="reference internal" href="../../_modules/dol/zipfiledol.html#zipped_bytes_to_bytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.zipfiledol.zipped_bytes_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompress input bytes of a single file zip, returning the uncompressed bytes</p>
<p>See <code class="docutils literal notranslate"><span class="pre">to_zipped_bytes</span></code> for usage examples.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="util.html" class="btn btn-neutral float-left" title="dol.util" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>