<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.signatures &mdash; dol 0.1.150 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="dol.sources" href="sources.html" />
    <link rel="prev" title="dol.scrap.store_factories" href="scrap/store_factories.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/new_store_wrap.html">dol.scrap.new_store_wrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_appendable.html">dol.tests.test_appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">dol.signatures</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/module_docs/dol/signatures.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-dol.signatures">
<span id="dol-signatures"></span><h1>dol.signatures<a class="headerlink" href="#module-dol.signatures" title="Permalink to this headline">¶</a></h1>
<p>Signature calculus: Tools to make it easier to work with function’s signatures.</p>
<p>How to:</p>
<blockquote>
<div><ul class="simple">
<li><p>get names, kinds, defaults, annotations</p></li>
<li><p>make signatures flexibly</p></li>
<li><p>merge two or more signatures</p></li>
<li></li>
<li><p>give a function a specific signature (with a choice of validations)</p></li>
<li><p>get an equivalent function with a different order of arguments</p></li>
<li><p>get an equivalent function with a subset of arguments (like partial)</p></li>
<li><p>get an equivalent function but with variadic <a href="#id1"><span class="problematic" id="id2">*</span></a>args and/or <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs replaced with</p></li>
</ul>
<p>non-variadic args (tuple) and kwargs (dict)</p>
<ul class="simple">
<li><p>make an f(a) function in to a f(a, b=None) function with b ignored</p></li>
</ul>
</div></blockquote>
<p>Get names, kinds, defaults, annotations:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">names</span>
<span class="go">[&#39;z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span> <span class="o">==</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note z is not in there (only defaulted params are included)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">defaults</span>
<span class="go">{&#39;a&#39;: 1.0, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">annotations</span>
<span class="go">{&#39;a&#39;: &lt;class &#39;float&#39;&gt;, &#39;c&#39;: &lt;class &#39;int&#39;&gt;}</span>
</pre></div>
</div>
<p>Make signatures flexibly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">&lt;Sig (z, a: float = 1.0, /, b=2, *, c: int = 3)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">])</span>
<span class="go">&lt;Sig (a, b)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;x y z&#39;</span><span class="p">)</span>
<span class="go">&lt;Sig (x, y, z)&gt;</span>
</pre></div>
</div>
<p>Merge signatures.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span> <span class="k">pass</span>  <span class="c1"># note the * (keyword only) will be lost!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">Sig</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span>
<span class="go">&lt;Sig (x, a, b, y: int, z=2)&gt;</span>
</pre></div>
</div>
<p>Give a function a signature.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@Sig</span><span class="p">(</span><span class="s1">&#39;a b c&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">&lt;Sig (a, b, c)&gt;</span>
</pre></div>
</div>
<p><strong>Notes to the reader</strong></p>
<p>Both in the code and in the docs, we’ll use short hands for parameter (argument) kind.</p>
<blockquote>
<div><ul class="simple">
<li><p>PK = Parameter.POSITIONAL_OR_KEYWORD</p></li>
<li><p>VP = Parameter.VAR_POSITIONAL</p></li>
<li><p>VK = Parameter.VAR_KEYWORD</p></li>
<li><p>PO = Parameter.POSITIONAL_ONLY</p></li>
<li><p>KO = Parameter.KEYWORD_ONLY</p></li>
</ul>
</div></blockquote>
<dl class="py exception">
<dt id="dol.signatures.FuncCallNotMatchingSignature">
<em class="property">exception </em><code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">FuncCallNotMatchingSignature</code><a class="reference internal" href="../../_modules/dol/signatures.html#FuncCallNotMatchingSignature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.FuncCallNotMatchingSignature" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise when the call signature is not valid</p>
</dd></dl>

<dl class="py exception">
<dt id="dol.signatures.IncompatibleSignatures">
<em class="property">exception </em><code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">IncompatibleSignatures</code><a class="reference internal" href="../../_modules/dol/signatures.html#IncompatibleSignatures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.IncompatibleSignatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise when two signatures are not compatible.
(see <a class="reference external" href="https://github.com/i2mint/i2/issues/16">https://github.com/i2mint/i2/issues/16</a> for more information on signature
compatibility)</p>
</dd></dl>

<dl class="py class">
<dt id="dol.signatures.MissingArgValFor">
<em class="property">class </em><code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">MissingArgValFor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">argname</span><span class="p">:</span> <span class="n">str</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#MissingArgValFor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.MissingArgValFor" title="Permalink to this definition">¶</a></dt>
<dd><p>A simple class to wrap an argument name, indicating that it was missing somewhere.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">MissingArgValFor</span><span class="p">(</span><span class="s2">&quot;argname&quot;</span><span class="p">)</span>
<span class="go">MissingArgValFor(&quot;argname&quot;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="dol.signatures.P">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">P</code><a class="headerlink" href="#dol.signatures.P" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#dol.signatures.Param" title="dol.signatures.Param"><code class="xref py py-class docutils literal notranslate"><span class="pre">dol.signatures.Param</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt id="dol.signatures.Param">
<em class="property">class </em><code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">Param</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">kind=&lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;</em>, <em class="sig-param">*</em>, <em class="sig-param">default</em>, <em class="sig-param">annotation</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Param"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Param" title="Permalink to this definition">¶</a></dt>
<dd><p>A thin wrap of Parameters: Adds shorter aliases to argument kinds and
a POSITIONAL_OR_KEYWORD default to the argument kind to make it faster to make
Parameter objects</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">Param</span><span class="p">,</span> <span class="s1">&#39;some quick arg params&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
<span class="go">[&lt;Param &quot;some&quot;&gt;, &lt;Param &quot;quick&quot;&gt;, &lt;Param &quot;arg&quot;&gt;, &lt;Param &quot;params&quot;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">Param</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Signature</span><span class="p">([</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">PO</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;kw&#39;</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">KO</span><span class="p">)])</span>
<span class="go">&lt;Signature (x, /, y: int = 42, *, kw)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt id="dol.signatures.Sig">
<em class="property">class </em><code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">Sig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_annotation</span></em>, <em class="sig-param"><span class="n">__validate_parameters__</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig" title="Permalink to this definition">¶</a></dt>
<dd><p>A subclass of inspect.Signature that has a lot of extra api sugar,
such as</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>making a signature for a variety of input types (callable,</dt><dd><p>iterable of callables, parameter lists, strings, etc.)</p>
</dd>
</dl>
</li>
<li><p>has a dict-like interface</p></li>
<li><p>signature merging (with operator interfaces)</p></li>
<li><p>quick access to signature data</p></li>
<li><p>positional/keyword argument mapping.</p></li>
</ul>
</div></blockquote>
<p># Positional/Keyword argument mapping</p>
<p>In python, arguments can be positional (args) or keyword (kwargs).
… sometimes both, sometimes a single one is imposed.
… and you have variadic versions of both.
… and you can have defaults or not.
… and all these different kinds have a particular order they must be in.
It’s is mess really. The flexibility is nice – but still; a mess.</p>
<p>You only really feel the mess if you try to do some meta-programming with your
functions.
Then, methods like <cite>normalize_kind</cite> can help you out, since you can enforce, and
then assume, some stable interface to your functions.</p>
<p>Two of the base methods for dealing with positional (args) and keyword (kwargs)
inputs are:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><cite>kwargs_from_args_and_kwargs</cite>: Map some args/kwargs input to a keyword-only</dt><dd><p>expression of the inputs. This is useful if you need to do some processing
based on the argument names.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><cite>args_and_kwargs_from_kwargs</cite>: Translate a fully keyword expression of some</dt><dd><p>inputs into an (args, kwargs) pair that can be used to call the function.
(Remember, your function can have constraints, so you may need to do this.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>The usual pattern of use of these methods is to use <cite>kwargs_from_args_and_kwargs</cite>
to map all the inputs to their corresponding name, do what needs to be done with
that (example, validation, transformation, decoration…) and then map back to an
(args, kwargs) pair than can actually be used to call the function.</p>
<p>Examples of methods and functions using these:
<cite>call_forgivingly</cite>, <cite>tuple_the_args</cite>, <cite>extract_kwargs</cite>, <cite>extract_args_and_kwargs</cite>,
<cite>source_kwargs</cite>, and <cite>source_args_and_kwargs</cite>.</p>
<p># Making a signature</p>
<p>You can construct a <cite>Sig</cite> object from a callable,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">&lt;Sig (w, /, x: float = 1, y=1, *, z: int = 1)&gt;</span>
</pre></div>
</div>
<p>but also from any “ParamsAble” object. Such as…
an iterable of Parameter instances, strings, tuples, or dicts:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="s2">&quot;a&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>        <span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
<span class="gp">... </span>        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;special&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Sig (a, b: int, c=2, d: float = 1.0, *, special=0)&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="s2">&quot;a&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="s2">&quot;b&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;args&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">),</span>
<span class="gp">... </span>        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;kwargs&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Sig (a, b, *args, **kwargs)&gt;</span>
</pre></div>
</div>
<p>The parameters of a signature are like a matrix whose rows are the parameters,
and the 4 columns are their properties: name, kind, default, and annotation
(the two laste ones being optional).
You get a row view when doing <cite>Sig(…).parameters.values()</cite>,
but what if you want a column-view?
Here’s how:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">kinds</span>  
<span class="go">{&#39;w&#39;: &lt;_ParameterKind.POSITIONAL_ONLY: 0&gt;,</span>
<span class="go">&#39;x&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="go">&#39;y&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="go">&#39;z&#39;: &lt;_ParameterKind.KEYWORD_ONLY: 3&gt;}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">annotations</span>
<span class="go">{&#39;x&#39;: &lt;class &#39;float&#39;&gt;, &#39;z&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">annotations</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="vm">__annotations__</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># same as what you get in `__annotations__`</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">defaults</span>
<span class="go">{&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note that it&#39;s not the same as you get in __defaults__ though:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">s</span><span class="o">.</span><span class="n">defaults</span> <span class="o">!=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># not 3, since __kwdefaults__ has that!</span>
</pre></div>
</div>
<p>We can sum (i.e. merge) and subtract (i.e. remove arguments) Sig instances.
Also, Sig instance is callable. It has the effect of inserting it’s signature in
the input
(in <cite>__signature__</cite>, but also inserting the resulting <cite>__defaults__</cite> and
<cite>__kwdefaults__</cite>).
One of the intents is to be able to do things like:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">some_func</span><span class="p">)</span>
<span class="go">&lt;Sig (w, i, /, a, x: float = 1, y=1, j=2, b=3.14, c: int = 42, *, z: int = 1)&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span> <span class="o">-</span> <span class="s2">&quot;b&quot;</span> <span class="o">-</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@sig</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">some_func</span><span class="p">)</span>
<span class="go">&lt;Sig (w, i, x: float = 1, y=1, j=2, c: int = 42)&gt;</span>
</pre></div>
</div>
<dl class="py method">
<dt id="dol.signatures.Sig.add_params">
<code class="sig-name descname">add_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span><span class="p">:</span> <span class="n">Iterable</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.add_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.add_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new instance of Sig after merging the parameters of this signature
with a list of new parameters. The new list of parameters is automatically
sorted based on signature constraints given by kinds and default values.
See Python native signature documentation for more details.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_params</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">Param</span><span class="p">(</span><span class="s1">&#39;kwargs&#39;</span><span class="p">,</span> <span class="n">VK</span><span class="p">),</span>
<span class="gp">... </span>    <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Param</span><span class="p">(</span><span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="n">VP</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;e&#39;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">Param</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">),</span>
<span class="gp">... </span><span class="p">])</span>
<span class="go">&lt;Sig (a, f, /, b, e, *args, c, d, **kwargs)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.annotations">
<em class="property">property </em><code class="sig-name descname">annotations</code><a class="headerlink" href="#dol.signatures.Sig.annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>annotation, …} dict of annotations of the signature.
What <cite>func.__annotations__</cite> would give you.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>{arg_name</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.args_and_kwargs_from_kwargs">
<code class="sig-name descname">args_and_kwargs_from_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kwargs</span></em>, <em class="sig-param"><span class="n">apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">allow_excess</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_kind</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">args_limit</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>int<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.args_and_kwargs_from_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.args_and_kwargs_from_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract args and kwargs such that func(<a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs) can be called,
where func has instance’s signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kwargs</strong> – The {argname: argval,…} dict to process</p></li>
<li><p><strong>args_limit</strong> – <p>How “far” in the params should args (positional arguments)
be searched for.
- args_limit==0: Take the minimum number possible of args (positional</p>
<blockquote>
<div><p>arguments). Only those that are position only or before a var-positional.</p>
</div></blockquote>
<ul>
<li><dl class="simple">
<dt>args_limit is None: Take the maximum number of args (positional arguments).</dt><dd><p>The only kwargs (keyword arguments) you should have are keyword-only
and var-keyword arguments.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>args_limit positive integer: Take the args_limit first argument names</dt><dd><p>(of signature) as args, and the rest as kwargs.</p>
</dd>
</dl>
</li>
</ul>
</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">((</span><span class="n">w</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">14</span>
</pre></div>
</div>
<p>The <cite>args_limit</cite> begs explanation.
Consider the signature of <cite>def foo(w, /, x: float, y=1, *, z: int = 1): …</cite>
for instance. We could call the function with the following (args, kwargs) pairs:
- ((1,), {‘x’: 2, ‘y’: 3, ‘z’: 4})
- ((1, 2), {‘y’: 3, ‘z’: 4})
- ((1, 2, 3), {‘z’: 4})
The two other combinations (empty args or empty kwargs) are not valid
because of the / and * constraints.</p>
<p>But when asked for an (args, kwargs) pair, which of the three valid options
should be returned? This is what the <cite>args_limit</cite> argument controls.</p>
<p>If <cite>args_limit == 0</cite>, the least args (positional arguments) will be returned.
It’s the default.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
</pre></div>
</div>
<p>If <cite>args_limit is None</cite>, the least kwargs (keyword arguments) will be returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">((4, 3, 2), {&#39;z&#39;: 1})</span>
</pre></div>
</div>
<p>If <cite>args_limit</cite> is a positive integer, the first <cite>args_limit</cite> arguments
will be returned (not checking at all if this is valid!).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_limit</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">((4, 3), {&#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">args_limit</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">((4, 3, 2), {&#39;z&#39;: 1})</span>
</pre></div>
</div>
<p>Note that ‘args_limit’’s behavior is consistent with list behvior in the sense
that:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
<span class="go">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[:</span><span class="kc">None</span><span class="p">]</span>
<span class="go">(0, 1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="go">2</span>
</pre></div>
</div>
<p>By default, only the arguments that were given in the kwargs input will be
returned in the (args, kwargs) output.
If you also want to get those that have defaults (according to signature),
you need to specify it with the <cite>apply_defaults=True</cite> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="go">((4,), {&#39;x&#39;: 3})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">((4,), {&#39;x&#39;: 3, &#39;y&#39;: 1, &#39;z&#39;: 1})</span>
</pre></div>
</div>
<p>By default, all required arguments must be given.
Not doing so will lead to a <cite>TypeError</cite>.
If you want to process your arguments anyway, specify <cite>allow_partial=True</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;x&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">((4,), {})</span>
</pre></div>
</div>
<p>Specifying argument names that are not recognized by the signature will
lead to a <cite>TypeError</cite>.
If you want to avoid this (and just take from the input <cite>kwargs</cite> what ever you
can), specify this with <cite>allow_excess=True</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s1">&#39;stuff&#39;</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Got unexpected keyword arguments: extra</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s1">&#39;stuff&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">((4,), {&#39;x&#39;: 3})</span>
</pre></div>
</div>
<p>An edge case: When a <cite>VAR_POSITIONAL</cite> follows a <cite>POSITION_OR_KEYWORD</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">((1, [2, 3]), {&#39;c&#39;: 4})</span>
</pre></div>
</div>
<p>See <cite>kwargs_from_args_and_kwargs</cite> (namely for the description of the arguments.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.ch_param_attrs">
<code class="sig-name descname">ch_param_attrs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">param_attr</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">arg_new_vals</span></em>, <em class="sig-param"><span class="n">_allow_reordering</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs_new_vals</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.ch_param_attrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.ch_param_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Change a specific attribute of the params, returning a modified signature.
This is a convenience method for the modified method when we’re targetting
a fixed param attribute: ‘name’, ‘kind’, ‘default’, or ‘annotation’</p>
<p>Instead of having to do this</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">c</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">},</span> <span class="n">b</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">},</span> <span class="n">c</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">})</span>
<span class="go">&lt;Sig (A, *B, **C)&gt;</span>
</pre></div>
</div>
<p>We can simply do this</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="go">&lt;Sig (A, *B, **C)&gt;</span>
</pre></div>
</div>
<p>One quite useful thing you can do with this is to set defaults, or set defaults
where there are none. If you wrap your function with such a modified signature,
you get a “curried” version of your function (called “partial” in python).
(Note that the <cite>functools.wraps</cite> won’t deal with defaults “correctly”, but
wrapping with <cite>Sig</cite> objects takes care of that oversight!)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">special_foo</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">special_foo</span><span class="p">)</span>
<span class="go">&lt;Sig (a, b=2, c=3)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">special_foo</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1"># should be 5 + 2 * 3 == 11</span>
<span class="go">11</span>
</pre></div>
</div>
<p># TODO: Would like to make this work (reordering)
# Now, if you want to set a default for a but not b and c for example, you’ll
# get complaints:
#
# <code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">#</span> <span class="pre">ValueError:</span> <span class="pre">non-default</span> <span class="pre">argument</span> <span class="pre">follows</span> <span class="pre">default</span> <span class="pre">argument</span>
<span class="pre">#</span> <span class="pre">`</span></code>
#
# will tell you.
#
# It’s true. But if you’re fine with rearranging the argument order,
# <cite>ch_param_attrs</cite> can take care of that for you.
# You’ll have to tell it explicitly that you wish for this though, because
# it’s conservative.
#
# &gt;&gt;&gt; # Note that for time being, Sig.wraps doesn’t make a copy of the function
# &gt;&gt;&gt; #  so we need to redefine foo here&#64;
# &gt;&gt;&gt; def foo(a, b, c):
# …     return a + b * c
# &gt;&gt;&gt; wrapper = Sig(foo).ch_param_attrs(
# … ‘default’, a=10, _allow_reordering=True
# … )
# &gt;&gt;&gt; another_foo = wrapper(foo)
# &gt;&gt;&gt; Sig(another_foo)
# &lt;Sig (b, c, a=10)&gt;
# &gt;&gt;&gt; another_foo(2, 3)  # should be 10 + (2 * 3) =
# 16</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.defaults">
<em class="property">property </em><code class="sig-name descname">defaults</code><a class="headerlink" href="#dol.signatures.Sig.defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>A <code class="docutils literal notranslate"><span class="pre">{name:</span> <span class="pre">default,...}</span></code> dict of defaults (regardless of kind)</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.extract_args_and_kwargs">
<code class="sig-name descname">extract_args_and_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">_ignore_kind</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">_allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_args_limit</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.extract_args_and_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.extract_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Source the (args, kwargs) for the signature instance, ignoring excess
arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The difference with extract_kwargs is that here the output is ready to be
called by the
function whose signature we have, since the position-only arguments will be
returned as
args.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Note that though <cite>w</cite> is a position only argument, you can specify <cite>w=4</cite> as a
keyword argument too (by default):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you don’t want to allow that, you can say <cite>_ignore_kind=False</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;w&#39; parameter is positional only, but was passed as a keyword</span>
</pre></div>
</div>
<p>You can use <cite>_allow_partial</cite> that will allow you, if
set to <cite>True</cite>, to underspecify the params of a function (in view of being
completed later).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;w&#39;</span>
</pre></div>
</div>
<p>But if you specify <cite>_allow_partial=True</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, <cite>_apply_defaults=False</cite>, which will lead to only get those
arguments you input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But if you specify <cite>_apply_defaults=True</cite> non-specified non-require arguments
will be returned with their defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.extract_kwargs">
<code class="sig-name descname">extract_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">_ignore_kind</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">_allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.extract_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.extract_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method that calls kwargs_from_args_and_kwargs with defaults,
and ignore_kind=True.</p>
<p>Strict in the sense that the kwargs cannot contain any arguments that are not
valid argument names (as per the signature).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;YY&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">sig</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>What about var positional and var keywords?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">bar</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">{&#39;args&#39;: (1, 2), &#39;kwargs&#39;: {&#39;y&#39;: 3, &#39;z&#39;: 4}}</span>
</pre></div>
</div>
<p>Note that though <cite>w</cite> is a position only argument, you can specify <cite>w=11</cite> as
a keyword argument too (by default):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">22</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>If you don’t want to allow that, you can say <cite>_ignore_kind=False</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;w&#39; parameter is positional only, but was passed as a keyword</span>
</pre></div>
</div>
<p>You can use <cite>_allow_partial</cite> that will allow you, if
set to <cite>True</cite>, to underspecify the params of a function
(in view of being completed later).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;w&#39;</span>
</pre></div>
</div>
<p>But if you specify <cite>_allow_partial=True</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 3, &#39;y&#39;: 2}</span>
</pre></div>
</div>
<p>By default, <cite>_apply_defaults=False</cite>, which will lead to only get those arguments
you input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>
</pre></div>
</div>
<p>But if you specify <cite>_apply_defaults=True</cite> non-specified non-require arguments
will be returned with their defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.get_names">
<code class="sig-name descname">get_names</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">spec</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">conserve_sig_order</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">allow_excess</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.get_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.get_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a tuple of names corresponding to the given spec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spec</strong> – An integer, string, or iterable of intergers and strings</p></li>
<li><p><strong>conserve_sig_order</strong> – Whether to order according to the signature</p></li>
<li><p><strong>allow_excess</strong> – Whether to allow items in spec that are not in signature</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;a b c d e&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">(&#39;a&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="go">(&#39;b&#39;,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;, &#39;e&#39;)</span>
</pre></div>
</div>
<p>See that by default the order of the signature is conserved:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="s1">&#39;b e d&#39;</span><span class="p">)</span>
<span class="go">(&#39;b&#39;, &#39;d&#39;, &#39;e&#39;)</span>
</pre></div>
</div>
<p>But you can change that default to conserve the order of the <code class="docutils literal notranslate"><span class="pre">spec</span></code> instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">(</span><span class="s1">&#39;b e d&#39;</span><span class="p">,</span> <span class="n">conserve_sig_order</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(&#39;b&#39;, &#39;e&#39;, &#39;d&#39;)</span>
</pre></div>
</div>
<p>By default, you can’t mention names that are not in signature.
To allow this (making <code class="docutils literal notranslate"><span class="pre">spec</span></code> have “extract these” interpretation),
set <code class="docutils literal notranslate"><span class="pre">allow_excess=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">get_names</span><span class="p">([</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">],</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(&#39;a&#39;, &#39;c&#39;, &#39;e&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.has_var_keyword">
<em class="property">property </em><code class="sig-name descname">has_var_keyword</code><a class="headerlink" href="#dol.signatures.Sig.has_var_keyword" title="Permalink to this definition">¶</a></dt>
<dd><p>Use index_of_var_keyword or var_keyword_name directly when needing that
information as well. This will avoid having to check the kinds list twice.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.has_var_kinds">
<em class="property">property </em><code class="sig-name descname">has_var_kinds</code><a class="headerlink" href="#dol.signatures.Sig.has_var_kinds" title="Permalink to this definition">¶</a></dt>
<dd><p>None).has_var_kinds
False
&gt;&gt;&gt; Sig(lambda x, <a href="#id9"><span class="problematic" id="id10">*</span></a>y: None).has_var_kinds
True
&gt;&gt;&gt; Sig(lambda x, <a href="#id11"><span class="problematic" id="id12">**</span></a>y: None).has_var_kinds
True</p>
<dl class="field-list">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.has_var_positional">
<em class="property">property </em><code class="sig-name descname">has_var_positional</code><a class="headerlink" href="#dol.signatures.Sig.has_var_positional" title="Permalink to this definition">¶</a></dt>
<dd><p>Use index_of_var_positional or var_keyword_name directly when needing that
information as well. This will avoid having to check the kinds list twice.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.index_of_var_keyword">
<em class="property">property </em><code class="sig-name descname">index_of_var_keyword</code><a class="headerlink" href="#dol.signatures.Sig.index_of_var_keyword" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of a VAR_KEYWORD param kind if any, and None if not.
See also, Sig.index_of_var_positional</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_keyword</span> <span class="o">==</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_keyword</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_keyword</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>
</div>
<p>And if there’s none…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_keyword</span> <span class="ow">is</span> <span class="kc">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.index_of_var_positional">
<em class="property">property </em><code class="sig-name descname">index_of_var_positional</code><a class="headerlink" href="#dol.signatures.Sig.index_of_var_positional" title="Permalink to this definition">¶</a></dt>
<dd><p>The index of the VAR_POSITIONAL param kind if any, and None if not.
See also, Sig.index_of_var_keyword</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_positional</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">z</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index_of_var_positional</span> <span class="o">==</span> <span class="kc">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.is_call_compatible_with">
<code class="sig-name descname">is_call_compatible_with</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">other_sig</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">param_comparator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.is_call_compatible_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.is_call_compatible_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if the signature is compatible with <code class="docutils literal notranslate"><span class="pre">other_sig</span></code>. Meaning that
all valid ways to call the signature are valid for <code class="docutils literal notranslate"><span class="pre">other_sig</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.kwargs_from_args_and_kwargs">
<code class="sig-name descname">kwargs_from_args_and_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">args</span></em>, <em class="sig-param"><span class="n">kwargs</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">allow_excess</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_kind</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">debug</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.kwargs_from_args_and_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.kwargs_from_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a dict of input argument values for target signature, from args
and kwargs.</p>
<p>When you need to manage how the arguments of a function are specified,
you need to take care of
multiple cases depending on whether they were specified as positional arguments
(<cite>args</cite>) or keyword arguments (<cite>kwargs</cite>).</p>
<p>The <cite>kwargs_from_args_and_kwargs</cite> (and it’s sorta-inverse inverse,
<cite>args_and_kwargs_from_kwargs</cite>)
are there to help you manage this.</p>
<p>If you could rely on the the fact that only <cite>kwargs</cite> were given it would
reduce the complexity of your code.
This is why we have the <cite>all_pk_signature</cite> function in <cite>signatures.py</cite>.</p>
<p>We also need to have a means to make a <cite>kwargs</cite> only from the actual <cite>(*args,
**kwargs)</cite> used at runtime.
We have <cite>Signature.bind</cite> (and <cite>bind_partial</cite>) for that.</p>
<p>But these methods will fail if there is extra stuff in the <cite>kwargs</cite>.
Yet sometimes we’d like to have a <cite>dict</cite> that services several functions that
will extract their needs from it.</p>
<p>That’s where  <cite>Sig.extract_kwargs(*args, **kwargs)</cite> is needed.
:param args: The args the function will be called with.
:param kwargs: The kwargs the function will be called with.
:param apply_defaults: (bool) Whether to apply signature defaults to the
non-specified argument names
:param allow_partial: (bool) True iff you want to allow partial signature
fulfillment.
:param allow_excess: (bool) Set to True iff you want to allow extra kwargs
items to be ignored.
:param ignore_kind: (bool) Set to True iff you want to ignore the position and
keyword only kinds,</p>
<blockquote>
<div><p>in order to be able to accept args and kwargs in such a way that there can
be cross-over
(args that are supposed to be keyword only, and kwargs that are supposed
to be positional only)</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An {argname: argval, …} dict</p>
</dd>
</dl>
<p>See also the sorta-inverse of this function: args_and_kwargs_from_kwargs</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;YY&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">((</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="s2">&quot;you&quot;</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="s2">&quot;zoo&quot;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">((</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="s2">&quot;you&quot;</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="s2">&quot;zoo&quot;</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="s2">&quot;you&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="s2">&quot;zoo&quot;</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>By default, <cite>apply_defaults=False</cite>, which will lead to only get those
arguments you input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">})</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>But if you specify <cite>apply_defaults=True</cite> non-specified non-require arguments
will be returned with their defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">},</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;YY&#39;, &#39;z&#39;: &#39;ZZ&#39;}</span>
</pre></div>
</div>
<p>By default, <cite>ignore_excess=False</cite>, so specifying kwargs that are not in the
signature will lead to an exception.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="s2">&quot;not_in_sig&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">Got unexpected keyword arguments: not_in_sig</span>
</pre></div>
</div>
<p>Specifying <cite>allow_excess=True</cite> will ignore such excess fields of kwargs.
This is useful when you want to source several functions from a same dict.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="s2">&quot;not_in_sig&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>On the other side of <cite>ignore_excess</cite> you have <cite>allow_partial</cite> that will allow
you, if
set to <cite>True</cite>, to underspecify the params of a function (in view of being
completed later).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;w&#39;</span>
</pre></div>
</div>
<p>But if you specify <cite>allow_partial=True</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">22</span><span class="p">},</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>That’s a lot of control (eight combinations total), but not everything is
controllable here:
Position only and keyword only kinds need to be respected:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{})</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">too many positional arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;w&#39; parameter is positional only, but was passed as a keyword</span>
</pre></div>
</div>
<p>But if you want to ignore the kind of parameter, just say so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.merge_with_sig">
<code class="sig-name descname">merge_with_sig</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">ch_to_all_pk</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">default_conflict_method</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'strict'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.merge_with_sig"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.merge_with_sig" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a signature obtained by merging self signature with another signature.
Insofar as it can, given the kind precedence rules, the arguments of self will
appear first.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig</strong> – The signature to merge with.</p></li>
<li><p><strong>ch_to_all_pk</strong> – Whether to change all kinds of both signatures to PK (</p></li>
</ul>
</dd>
</dl>
<p>POSITIONAL_OR_KEYWORD)
:return:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Sig (a=None, *, b=1, c=2)&gt;</span>
</pre></div>
</div>
<p>Observe where the new arguments <code class="docutils literal notranslate"><span class="pre">d</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code> are placed,
according to whether they have defaults and what their kind is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">([</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">])</span>
<span class="go">&lt;Sig (d, e, a=None, *, b=1, c=2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">([</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="go">&lt;Sig (d, a=None, e=4, *, b=1, c=2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">([</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">)])</span>
<span class="go">&lt;Sig (d, a=None, *, b=1, c=2, e=4)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">4</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&lt;Sig (a=None, *, d, b=1, c=2, e=4)&gt;</span>
</pre></div>
</div>
<p>If the kind of the params is not important, but order is, you can specify
<code class="docutils literal notranslate"><span class="pre">ch_to_all_pk=True</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">([</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">],</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;Sig (d, e, a=None, b=1, c=2)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">([(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)],</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;Sig (a=None, b=1, c=2, d=3, e=4)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.modified">
<code class="sig-name descname">modified</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">_allow_reordering</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">changes_for_name</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.modified"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.modified" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a modified (new) signature object.</p>
<p>Note: This function doesn’t modify the signature, but creates a modified copy
of the signature.</p>
<p>IMPORTANT WARNING: This is an advanced feature. Avoid wrapping a function with
a modified signature, as this may not have the intended effect.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span>
<span class="go">&lt;Sig (pka, *vpa, koa, **vka)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="p">[</span><span class="s1">&#39;pka&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">PK</span>
</pre></div>
</div>
<dl class="simple">
<dt>Let’s make a signature that is the same as sig, except that</dt><dd><ul class="simple">
<li><p><cite>poa</cite> is given a PO (POSITIONAL_ONLY) kind insteadk of PK</p></li>
<li><p><cite>koa</cite> is given a default of None</p></li>
<li><p>the signature is given a return_annotation of str</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">pka</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PO</span><span class="p">},</span>
<span class="gp">... </span>    <span class="n">koa</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
<span class="gp">... </span>    <span class="n">return_annotation</span><span class="o">=</span><span class="nb">str</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_sig</span>
<span class="go">&lt;Sig (pka, /, *vpa, koa=None, **vka) -&gt; str&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">new_sig</span><span class="o">.</span><span class="n">kinds</span><span class="p">[</span><span class="s1">&#39;pka&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">PO</span>  <span class="c1"># now pos is of the PO kind!</span>
</pre></div>
</div>
<p>Here’s an example of changing signature parameters in bulk.
Here we change all kinds to be the friendly PK kind.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PK</span><span class="p">}</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">})</span>
<span class="go">&lt;Sig (pka, vpa, koa, vka)&gt;</span>
</pre></div>
</div>
<p>Repetition of the above: This gives you a signature with all PK kinds.
If you wrap a function with it, it will look like it has all PK kinds.
But that doesn’t mean you can actually use thenm as such.
You’ll need to modify (decorate further) your function further to reflect
its new signature.</p>
<p>On the other hand, if you decorate a function with a sig that adds or modifies
defaults, these defaults will actually be used (unlike with <cite>functools.wraps</cite>).</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.n_required">
<em class="property">property </em><code class="sig-name descname">n_required</code><a class="headerlink" href="#dol.signatures.Sig.n_required" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of required arguments.
A required argument is one that doesn’t have a default, nor is VAR_POSITIONAL
(<a href="#id13"><span class="problematic" id="id14">*</span></a>args) or VAR_KEYWORD (<a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs).
Note: Sometimes a minimum number of arguments in VAR_POSITIONAL and
VAR_KEYWORD are in fact required,
but we can’t see this from the signature, so we can’t tell you about that! You
do the math.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a00</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">,</span> <span class="o">*</span><span class="n">a23</span><span class="p">,</span> <span class="n">a34</span><span class="p">,</span> <span class="n">a35</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a36</span><span class="o">=</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">a47</span><span class="p">:</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">n_required</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.names_for_kind">
<code class="sig-name descname">names_for_kind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">kind</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.names_for_kind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.names_for_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the arg names tuple for a given kind.
Note, if you need to do this several times, or for several kinds, use
<code class="docutils literal notranslate"><span class="pre">names_of_kind</span></code> property (a tuple) instead: It groups all names of kinds once,
and caches the result.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.params">
<em class="property">property </em><code class="sig-name descname">params</code><a class="headerlink" href="#dol.signatures.Sig.params" title="Permalink to this definition">¶</a></dt>
<dd><p>Just list(self.parameters.values()), because that’s often what we want.
Why a Sig.params property when we already have a Sig.parameters property?</p>
<p>Well, as much as is boggles my mind, it so happens that the Signature.parameters
is a name-&gt;Parameter mapping, but the Signature argument <cite>parameters</cite>,
though baring the same name,
is expected to be a list of Parameter instances.</p>
<p>So Sig.params is there to restore semantic consistence sanity.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.required_names">
<em class="property">property </em><code class="sig-name descname">required_names</code><a class="headerlink" href="#dol.signatures.Sig.required_names" title="Permalink to this definition">¶</a></dt>
<dd><p>A tuple of required names, preserving the original signature order.</p>
<p>A required name is that must be given in a function call, that is, the name of a
paramater that doesn’t have a default, and is not a variadic.</p>
<p>That lost one is a frequent gotcha, so oo not fall in that gotcha that easily,
we provide a property that contains what we need.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a00</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">a11</span><span class="p">,</span> <span class="n">a12</span><span class="p">,</span> <span class="o">*</span><span class="n">a23</span><span class="p">,</span> <span class="n">a34</span><span class="p">,</span> <span class="n">a35</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">a36</span><span class="o">=</span><span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">a47</span><span class="p">:</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">required_names</span>
<span class="go">(&#39;a00&#39;, &#39;a11&#39;, &#39;a12&#39;, &#39;a34&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.sig_or_default">
<em class="property">classmethod </em><code class="sig-name descname">sig_or_default</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">default_signature=&lt;Signature (*no_sig_args</em>, <em class="sig-param">**no_sig_kwargs)&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.sig_or_default"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.sig_or_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Sig instance, or a default signature if there was a ValueError
trying to construct it.</p>
<p>For example, <cite>time.time</cite> doesn’t have a signature</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">has_signature</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>But we can tell <cite>Sig</cite> to give it the default one:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_default</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">))</span>
<span class="go">&#39;(*no_sig_args, **no_sig_kwargs)&#39;</span>
</pre></div>
</div>
<p>That’s the default signature, which should work for most purposes.
You can also specify what the default should be though.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fake_signature</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">time_takes_no_arguments</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_default</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">fake_signature</span><span class="p">))</span>
<span class="go">&#39;(*time_takes_no_arguments)&#39;</span>
</pre></div>
</div>
<p>Careful though. If you assign a signature to a function that is not aligned
with that actually functioning of the function, bad things will happen.
In this case, the actual signature of time is the empty signature:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_default</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="o">...</span><span class="p">)))</span>
<span class="go">&#39;()&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.sig_or_none">
<em class="property">classmethod </em><code class="sig-name descname">sig_or_none</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.sig_or_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.sig_or_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Sig instance, or None if there was a ValueError trying to
construct it.
One use case is to be able to tell if an object has a signature or not.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">robust_has_signature</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">robust_has_signature</span><span class="p">(</span><span class="n">robust_has_signature</span><span class="p">)</span>  <span class="c1"># an easy case</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">robust_has_signature</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># another easy one: This time, a type/class (which is callable, yes)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But here’s where it get’s interesting. <cite>print</cite>, a builtin, doesn’t have a
signature through inspect.signature.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">has_signature</span><span class="p">(</span><span class="nb">print</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>But we do get one with robust_has_signature</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">robust_has_signature</span><span class="p">(</span><span class="nb">print</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.source_args_and_kwargs">
<code class="sig-name descname">source_args_and_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">_ignore_kind</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">_allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.source_args_and_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.source_args_and_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Source the (args, kwargs) for the signature instance, ignoring excess
arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>The difference with source_kwargs is that here the output is ready to be
called by the
function whose signature we have, since the position-only arguments will be
returned as
args.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>Note that though <cite>w</cite> is a position only argument, you can specify <cite>w=4</cite> as a
keyword argument too (by default):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
</pre></div>
</div>
<p>If you don’t want to allow that, you can say <cite>_ignore_kind=False</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">w</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;w&#39; parameter is positional only, but was passed as a keyword</span>
</pre></div>
</div>
<p>You can use <cite>_allow_partial</cite> that will allow you, if
set to <cite>True</cite>, to underspecify the params of a function (in view of being
completed later).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;w&#39;</span>
</pre></div>
</div>
<p>But if you specify <cite>_allow_partial=True</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>By default, <cite>_apply_defaults=False</cite>, which will lead to only get those
arguments you input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
<p>But if you specify <cite>_apply_defaults=True</cite> non-specified non-require arguments
will be returned with their defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="mi">4</span><span class="p">,),</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.source_kwargs">
<code class="sig-name descname">source_kwargs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">_ignore_kind</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">_allow_partial</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_apply_defaults</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.source_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.source_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Source the kwargs for the signature instance, ignoring excess arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;YY&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ZZ&quot;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>Note that though <cite>w</cite> is a position only argument, you can specify <cite>w=11</cite> as a
keyword argument too (by default):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 11, &#39;x&#39;: 22}</span>
</pre></div>
</div>
<p>If you don’t want to allow that, you can say <cite>_ignore_kind=False</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">w</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">22</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">&#39;w&#39; parameter is positional only, but was passed as a keyword</span>
</pre></div>
</div>
<p>You can use <cite>_allow_partial</cite> that will allow you, if
set to <cite>True</cite>, to underspecify the params of a function (in view of being
completed later).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;w&#39;</span>
</pre></div>
</div>
<p>But if you specify <cite>_allow_partial=True</cite>…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;x&#39;: 3, &#39;y&#39;: 2}</span>
</pre></div>
</div>
<p>By default, <cite>_apply_defaults=False</cite>, which will lead to only get those
arguments you input.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>
</pre></div>
</div>
<p>But if you specify <cite>_apply_defaults=True</cite> non-specified non-require arguments
will be returned with their defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;keywords&quot;</span><span class="p">,</span> <span class="n">are</span><span class="o">=</span><span class="s2">&quot;ignored&quot;</span><span class="p">,</span> <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">{&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.to_signature_kwargs">
<code class="sig-name descname">to_signature_kwargs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.to_signature_kwargs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.to_signature_kwargs" title="Permalink to this definition">¶</a></dt>
<dd><p>The dict of keyword arguments to make this signature instance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">to_signature_kwargs</span><span class="p">()</span>  
<span class="go">{&#39;parameters&#39;:</span>
<span class="go">    [&lt;Parameter &quot;w&quot;&gt;,</span>
<span class="go">    &lt;Parameter &quot;x: float = 2&quot;&gt;,</span>
<span class="go">    &lt;Parameter &quot;y=1&quot;&gt;,</span>
<span class="go">    &lt;Parameter &quot;z: int = 0&quot;&gt;],</span>
<span class="go">&#39;return_annotation&#39;: &lt;class &#39;float&#39;&gt;}</span>
</pre></div>
</div>
<p>Note that this does NOT return:
<a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a></p>
<blockquote>
<div><p>{‘parameters’: self.parameters,
‘return_annotation’: self.return_annotation}</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">which</span> <span class="pre">would</span> <span class="pre">not</span> <span class="pre">actually</span> <span class="pre">work</span> <span class="pre">as</span> <span class="pre">keyword</span> <span class="pre">arguments</span> <span class="pre">of</span> <span class="pre">``Signature</span></code>.
Yeah, I know. Don’t ask me, ask the authors of <cite>Signature</cite>!</p>
<p>Instead, <cite>parammeters</cite> will be <code class="docutils literal notranslate"><span class="pre">list(self.parameters.values())</span></code>, which does
work.</p>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.to_simple_signature">
<code class="sig-name descname">to_simple_signature</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.to_simple_signature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.to_simple_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>A builtin <code class="docutils literal notranslate"><span class="pre">inspect.Signature</span></code> instance equivalent (i.e. without the extra
properties and methods)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span>
<span class="go">&lt;Signature (w, /, x: float = 2, y=1, *, z: int = 0)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.with_defaults">
<em class="property">property </em><code class="sig-name descname">with_defaults</code><a class="headerlink" href="#dol.signatures.Sig.with_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-signature containing only “not required” (i.e. with defaults) parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">)</span>
<span class="go">[&#39;args&#39;, &#39;x&#39;, &#39;y&#39;, &#39;kwargs&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.without_defaults">
<em class="property">property </em><code class="sig-name descname">without_defaults</code><a class="headerlink" href="#dol.signatures.Sig.without_defaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub-signature containing only “required” (i.e. without defaults) parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="dol.signatures.Sig.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span></em>, <em class="sig-param"><span class="n">ignore_incompatible_signatures</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">copy_function</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>bool<span class="p">, </span>Callable<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#Sig.wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.Sig.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives the input function the signature.</p>
<p>This is similar to the <cite>functools.wraps</cite> function, but parametrized by a
signature
(not a callable). Also, where as both write to the input func’s <cite>__signature__</cite>
attribute, here we also write to
- <cite>__defaults__</cite> and <cite>__kwdefaults__</cite>, extracting these from <cite>__signature__</cite></p>
<blockquote>
<div><p>(functools.wraps doesn’t do that at the time of writing this
(see <a class="reference external" href="https://github.com/python/cpython/pull/21379">https://github.com/python/cpython/pull/21379</a>)).</p>
</div></blockquote>
<ul class="simple">
<li><p><cite>__annotations__</cite> (also extracted from <cite>__signature__</cite>)</p></li>
<li><dl class="simple">
<dt>does not write to <cite>__module__</cite>, <cite>__name__</cite>, <cite>__qualname__</cite>, <cite>__doc__</cite></dt><dd><p>(because again, we’re basinig the injecton on a signature, not a function,
so we have no name, doc, etc…)</p>
</dd>
</dl>
</li>
</ul>
<p>WARNING: The fact that you’ve modified the signature of your function doesn’t
mean that the decorated function will work as expected (or even work at all).
See below for examples.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 0 + 1 * 2 ** 3</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span>
<span class="go">(1, 2, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="mi">8</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Now let’s create a very similar function to f, but where:
- w is not position-only
- x annot is int instead of float, and doesn’t have a default
- z’s default changes to 10</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>  <span class="c1"># see that</span>
<span class="go">&lt;Sig (w, x: int, y=2, z: int = 10)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But (unlike with functools.wraps) here we get __defaults__ and</span>
<span class="go">__kwdefault__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span>  <span class="c1"># see that x has no more default &amp; z&#39;s default is now 10</span>
<span class="go">(2, 10)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span>
<span class="gp">... </span>    <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># see that now we get a different output because using different defaults</span>
<span class="go">1024</span>
</pre></div>
</div>
<p>Remember that you are modifying the signature, not the function itself.
Signature changes in defaults will indeed change the function’s behavior.
But changes in name or kind will only be reflected in the signature, and
misalignment with the wrapped function will lead to unexpected results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># 0 + 1 * 2 ** 3</span>
<span class="go">8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># error expected!</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() takes from 1 to 3 positional arguments but 4 were given</span>
</pre></div>
</div>
<p>But if you try to remove the argument kind constraint by just changing the
signature, you’ll fail.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">w</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">**</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">g</span><span class="p">)</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() missing 1 required keyword-only argument: &#39;z&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">f() takes from 0 to 3 positional arguments but 4 were given</span>
</pre></div>
</div>
<p>TODO: Give more explanations why this is.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="dol.signatures.all_pk_signature">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">all_pk_signature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callable_or_signature</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Callable<span class="p">, </span>inspect.Signature<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#all_pk_signature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.all_pk_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes all (non-variadic) arguments to be of the PK (POSITION_OR_KEYWORD) kind.</p>
<p>Wrapping a function with the resulting signature doesn’t make that function callable
with PK kinds in itself.
It just gives it a signature without position and keyword ONLY kinds.
It should be used to wrap such a function that actually carries out the
implementation though!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">new_foo</span><span class="p">)</span>
<span class="go">&lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_pk_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="go">&lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>
</pre></div>
</div>
<p>But note that the variadic arguments <a href="#id21"><span class="problematic" id="id22">*</span></a>args and <a href="#id23"><span class="problematic" id="id24">**</span></a>kwargs remain variadic:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">all_pk_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">bar</span><span class="p">))</span>
<span class="go">&lt;Signature (*args, **kwargs)&gt;</span>
</pre></div>
</div>
<p>It works with <cite>Sig</cite> too (since Sig is a Signature), and maintains it’s other
attributes (like name).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">bar</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span>
<span class="go">&lt;Sig (*args, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;bar&#39;</span>
</pre></div>
</div>
<p>See also: <code class="docutils literal notranslate"><span class="pre">i2.wrappers.nice_kinds</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.assure_params">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">assure_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.assure_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an interable of Parameter instances from an object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<p>From a callable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[&lt;Parameter &quot;w&quot;&gt;, &lt;Parameter &quot;x: float = 1&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z: int = 1&quot;&gt;]</span>
</pre></div>
</div>
<p>From an iterable of strings, dicts, or tuples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="s2">&quot;xyz&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">(</span>
<span class="gp">... </span>            <span class="s2">&quot;b&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">),</span>  <span class="c1"># if you want an annotation without a default use Parameter.empty</span>
<span class="gp">... </span>        <span class="p">(</span>
<span class="gp">... </span>            <span class="s2">&quot;c&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">),</span>  <span class="c1"># if you just want a default, make it the second element of your tup</span>
<span class="gp">... </span>        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># all kinds are by default PK: Use dict to specify otherwise.</span>
<span class="go">[&lt;Param &quot;xyz&quot;&gt;, &lt;Param &quot;b: int&quot;&gt;, &lt;Param &quot;c=2&quot;&gt;, &lt;Param &quot;**d&quot;&gt;]</span>
</pre></div>
</div>
<p>If no input is given, an empty list is returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">()</span>  <span class="c1"># equivalent to ensure_params(None)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.call_forgivingly">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">call_forgivingly</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#call_forgivingly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.call_forgivingly" title="Permalink to this definition">¶</a></dt>
<dd><p>Call function on given args and kwargs, but only taking what the function needs
(not choking if they’re extras variables)</p>
<p>Tip: If you into trouble because your kwargs has a ‘func’ key,
(which would then clash with the <code class="docutils literal notranslate"><span class="pre">func</span></code> param of call_forgivingly), then
use <cite>_call_forgivingly</cite> instead, specifying args and kwargs as tuple and
dict.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_forgivingly</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="p">,</span>  <span class="c1"># the function you want to call</span>
<span class="gp">... </span>    <span class="s2">&quot;input for a&quot;</span><span class="p">,</span>  <span class="c1"># meant for a -- the first (and only) argument foo requires</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span>  <span class="c1"># skiping b and giving c a non-default value</span>
<span class="gp">... </span>    <span class="n">intruder</span><span class="o">=</span><span class="s2">&quot;argument&quot;</span><span class="p">,</span>  <span class="c1"># but wait, this argument name doesn&#39;t exist! Oh no!</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># well, as it happens, nothing bad -- the intruder argument is just ignored</span>
<span class="go">(&#39;foo&#39;, (&#39;input for a&#39;, 0, 42))</span>
</pre></div>
</div>
<p>An example of what happens when variadic kinds are involved:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">args1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_forgivingly</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">(1, (2, 3), 4, {&#39;z&#39;: 5})</span>
</pre></div>
</div>
<p># &gt;&gt;&gt; def bar(x, y=1, <a href="#id25"><span class="problematic" id="id26">**</span></a>kwargs1):
# …     return x, y, kwargs1
# &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)
# (1, 4, {‘z’: 5})</p>
<p># &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)</p>
<p># &gt;&gt;&gt; def bar(x, <a href="#id27"><span class="problematic" id="id28">*</span></a>args1, y=1):
# …     return x, args1, y
# &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)
# (1, (2, 3), {‘z’: 5})</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.call_somewhat_forgivingly">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">call_somewhat_forgivingly</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">args</span></em>, <em class="sig-param"><span class="n">kwargs</span></em>, <em class="sig-param"><span class="n">enforce_sig</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Union<span class="p">[</span>inspect.Signature<span class="p">, </span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#call_somewhat_forgivingly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.call_somewhat_forgivingly" title="Permalink to this definition">¶</a></dt>
<dd><p>Call function on given args and kwargs, but with controllable argument leniency.
By default, the function will only pick from args and kwargs what matches it’s
signature, ignoring anything else in args and kwargs.</p>
<p>But the real use of <cite>call_somewhat_forgivingly</cite> kicks in when you specify a
<cite>enforce_sig</cite>: A signature (or any object that can be resolved into a signature
through <cite>Sig(enforce_sig)</cite>) that will be used to bind the inputs, thus validating
them against the <cite>enforce_sig</cite> signature (including extra arguments, defaults,
etc.).</p>
<p><cite>call_somewhat_forgivingly</cite> helps you do this kind of thing systematically.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">{})</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, we have no <cite>enforce_sig</cite>. The real use of call_somewhat_forgivingly
is when we ask it to enforce a signature. Let’s do this by specifying a function
(no need for it to do anything: Only the signature is used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Calling <cite>f</cite> on it’s normal set of inputs (one input in this case) gives you the
same thing as <cite>f</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">{},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>If you call with an extra positional argument, it will just be ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ignored&#39;</span><span class="p">),</span> <span class="p">{},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>If you call with a <cite>b</cite> keyword-argument (which matches <cite>g</cite>’s signature,
it will also be ignored.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span>
<span class="gp">... </span><span class="n">f</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;ignored&#39;</span><span class="p">},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span>
<span class="gp">... </span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;ignored&#39;</span><span class="p">},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span>
<span class="gp">... </span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>But if you call with three positional arguments (one more than g allows),
or call with a keyword argument that is not in <cite>g</cite>’s signature, it will
raise a <cite>TypeError</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;ignored&#39;</span><span class="p">,</span> <span class="s1">&#39;does_not_fit_g_signature_anymore&#39;</span><span class="p">),</span> <span class="p">{},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">too many positional arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;this_argname&#39;</span><span class="p">:</span> <span class="s1">&#39;is not in g&#39;</span><span class="p">},</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">g</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">    </span><span class="o">...</span>
<span class="gr">TypeError</span>: <span class="n">got an unexpected keyword argument &#39;this_argname&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.ch_func_to_all_pk">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">ch_func_to_all_pk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#ch_func_to_all_pk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.ch_func_to_all_pk" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a decorated function where all arguments are of the PK kind.
(PK: Positional_or_keyword)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>func</strong> – A callable</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="go">(a, /, b, *, c=None, **kwargs)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ff</span> <span class="o">=</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">ff</span><span class="p">))</span>
<span class="go">(a, b, c=None, **kwargs)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ff</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="go">(x, y=1, *args, **kwargs)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gg</span> <span class="o">=</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">gg</span><span class="p">))</span>
<span class="go">(x, y=1, args=(), **kwargs)</span>
</pre></div>
</div>
<p># &gt;&gt;&gt; def h(x, <a href="#id29"><span class="problematic" id="id30">*</span></a>y, z):
# …     print(f”{x=}, {y=}, {z=}”)
# &gt;&gt;&gt; h(1, 2, 3, z=4)
# x=1, y=(2, 3), z=4
# &gt;&gt;&gt; hh = ch_func_to_all_pk(h)
# &gt;&gt;&gt; hh(1, (2, 3), z=4)
# x=1, y=(2, 3), z=4</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.ch_signature_to_all_pk">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">ch_signature_to_all_pk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">callable_or_signature</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Callable<span class="p">, </span>inspect.Signature<span class="p">]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.ch_signature_to_all_pk" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes all (non-variadic) arguments to be of the PK (POSITION_OR_KEYWORD) kind.</p>
<p>Wrapping a function with the resulting signature doesn’t make that function callable
with PK kinds in itself.
It just gives it a signature without position and keyword ONLY kinds.
It should be used to wrap such a function that actually carries out the
implementation though!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_foo</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">new_foo</span><span class="p">)</span>
<span class="go">&lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">all_pk_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
<span class="go">&lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>
</pre></div>
</div>
<p>But note that the variadic arguments <a href="#id31"><span class="problematic" id="id32">*</span></a>args and <a href="#id33"><span class="problematic" id="id34">**</span></a>kwargs remain variadic:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">all_pk_signature</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">bar</span><span class="p">))</span>
<span class="go">&lt;Signature (*args, **kwargs)&gt;</span>
</pre></div>
</div>
<p>It works with <cite>Sig</cite> too (since Sig is a Signature), and maintains it’s other
attributes (like name).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">bar</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span>
<span class="go">&lt;Sig (*args, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span><span class="o">.</span><span class="n">name</span>
<span class="go">&#39;bar&#39;</span>
</pre></div>
</div>
<p>See also: <code class="docutils literal notranslate"><span class="pre">i2.wrappers.nice_kinds</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.ch_variadics_to_non_variadic_kind">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">ch_variadics_to_non_variadic_kind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#ch_variadics_to_non_variadic_kind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.ch_variadics_to_non_variadic_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that will change a VAR_POSITIONAL (<a href="#id35"><span class="problematic" id="id36">*</span></a>args) argument to a tuple (args)
argument of the same name.</p>
<p>Essentially, given a <cite>func(a, *b, c, **d)</cite> function want to get a
<cite>new_func(a, b=(), c=None, d={})</cite> that has the same functionality
(in fact, calls the original <cite>func</cite> function behind the scenes), but without
where the variadic arguments <a href="#id37"><span class="problematic" id="id38">*</span></a>b and <a href="#id39"><span class="problematic" id="id40">**</span></a>d are replaced with a <cite>b</cite> expecting an
iterable (e.g. tuple/list) and <cite>d</cite> expecting a <cite>dict</cite> to contain the
desired inputs.</p>
<p>Besides this, the decorator tries to be as conservative as possible, making only
the minimum changes needed to meet the goal of getting to a variadic-less
interface. When it doubt, and error will be raised.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">bar</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">kwargs</span><span class="si">=}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;(a, *args, bar, **kwargs)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wfoo</span> <span class="o">=</span> <span class="n">ch_variadics_to_non_variadic_kind</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">wfoo</span><span class="p">))</span>
<span class="go">&#39;(a, args=(), *, bar, kwargs={})&#39;</span>
</pre></div>
</div>
<p>And now to do this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>
<span class="go">&quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>
</pre></div>
</div>
<p>We can do it like this instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wfoo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">))</span>
<span class="go">&quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>
</pre></div>
</div>
<p>Note, the outputs are the same. It’s just the way we call our function that has
changed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wfoo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wfoo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wfoo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(),</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that if there is not variadic positional arguments, the variadic keyword
will still be a keyword-only kind.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@ch_variadics_to_non_variadic_kind</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">bar</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">kwargs</span><span class="si">=}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
<span class="go">&#39;(a, bar=None, *, kwargs={})&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;a=1, bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>
</pre></div>
</div>
<p>If the function has neither variadic kinds, it will remain untouched.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ch_variadics_to_non_variadic_kind</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">==</span> <span class="n">func</span>
<span class="go">True</span>
</pre></div>
</div>
<p>If you only want the variadic positional to be handled, but leave leave any
VARIADIC_KEYWORD kinds (<a href="#id41"><span class="problematic" id="id42">**</span></a>kwargs) alone, you can do so by setting
<cite>ch_variadic_keyword_to_keyword=False</cite>.
If you’ll need to use <cite>ch_variadics_to_non_variadic_kind</cite> in such a way
repeatedly, we suggest you use <cite>functools.partial</cite> to not have to specify this
configuration repeatedly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tuple_the_args</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">ch_variadics_to_non_variadic_kind</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="kc">False</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@tuple_the_args</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">bar</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">kwargs</span><span class="si">=}</span><span class="s2">&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Sig (a, args=(), *, bar=None, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">hello</span><span class="o">=</span><span class="s2">&quot;world&quot;</span><span class="p">)</span>
<span class="go">&quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.common_and_diff_argnames">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">common_and_diff_argnames</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func1</span><span class="p">:</span> <span class="n">callable</span></em>, <em class="sig-param"><span class="n">func2</span><span class="p">:</span> <span class="n">callable</span></em><span class="sig-paren">)</span> &#x2192; dict<a class="reference internal" href="../../_modules/dol/signatures.html#common_and_diff_argnames"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.common_and_diff_argnames" title="Permalink to this definition">¶</a></dt>
<dd><p>Get list of argument names that are common to two functions, as well as the two
lists of names that are different</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func1</strong> – First function</p></li>
<li><p><strong>func2</strong> – Second function</p></li>
</ul>
</dd>
</dl>
<p>Returns: A dict with fields ‘common’, ‘func1_not_func2’, and ‘func2_not_func1’</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_and_diff_argnames</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="go">{&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;], &#39;func2_not_func1&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">common_and_diff_argnames</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
<span class="go">{&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;], &#39;func2_not_func1&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.copy_func">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">copy_func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#copy_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.copy_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy a function (not sure it works with all types of callables)</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.dict_of_attribute_signatures">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">dict_of_attribute_signatures</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cls</span><span class="p">:</span> <span class="n">type</span></em><span class="sig-paren">)</span> &#x2192; Dict<span class="p">[</span>str<span class="p">, </span>inspect.Signature<span class="p">]</span><a class="reference internal" href="../../_modules/dol/signatures.html#dict_of_attribute_signatures"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.dict_of_attribute_signatures" title="Permalink to this definition">¶</a></dt>
<dd><p>A function that extracts the signatures of all callable attributes of a class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cls</strong> – The class that holds the the <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">func)</span></code> pairs we want to extract.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dict of <code class="docutils literal notranslate"><span class="pre">(name,</span> <span class="pre">signature(func))</span></code> pairs extracted from class.</p>
</dd>
</dl>
<p>One of the intended applications is to use <code class="docutils literal notranslate"><span class="pre">dict_of_attribute_signatures</span></code> as a
decorator, like so:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@dict_of_attribute_signatures</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">names_and_signatures</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">names_and_signatures</span>
<span class="go">{&#39;foo&#39;: &lt;Signature (x: str, *, y=2) -&gt; tuple&gt;, &#39;bar&#39;: &lt;Signature (z, /) -&gt; float&gt;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.ensure_params">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">ensure_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#ensure_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.ensure_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an interable of Parameter instances from an object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<p>From a callable:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="go">[&lt;Parameter &quot;w&quot;&gt;, &lt;Parameter &quot;x: float = 1&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z: int = 1&quot;&gt;]</span>
</pre></div>
</div>
<p>From an iterable of strings, dicts, or tuples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="s2">&quot;xyz&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">(</span>
<span class="gp">... </span>            <span class="s2">&quot;b&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span>
<span class="gp">... </span>            <span class="nb">int</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">),</span>  <span class="c1"># if you want an annotation without a default use Parameter.empty</span>
<span class="gp">... </span>        <span class="p">(</span>
<span class="gp">... </span>            <span class="s2">&quot;c&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">),</span>  <span class="c1"># if you just want a default, make it the second element of your tup</span>
<span class="gp">... </span>        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># all kinds are by default PK: Use dict to specify otherwise.</span>
<span class="go">[&lt;Param &quot;xyz&quot;&gt;, &lt;Param &quot;b: int&quot;&gt;, &lt;Param &quot;c=2&quot;&gt;, &lt;Param &quot;**d&quot;&gt;]</span>
</pre></div>
</div>
<p>If no input is given, an empty list is returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ensure_params</span><span class="p">()</span>  <span class="c1"># equivalent to ensure_params(None)</span>
<span class="go">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.extract_arguments">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">extract_arguments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="default_value">'return'</span></em>, <em class="sig-param"><span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#extract_arguments"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.extract_arguments" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract arguments needed to satisfy the params of a callable, dealing with the
dirty details.</p>
<p>Returns an (param_args, param_kwargs, remaining_kwargs) tuple where
- param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by
params,
- param_kwargs are those names that are both in params and not in param_args, and
- remaining_kwargs are the remaining.</p>
<p>Intended usage: When you need to call a function <cite>func</cite> that has some
position-only arguments,
but you have a kwargs dict of arguments in your hand. You can’t just to <cite>func(
**kwargs)</cite>.
But you can (now) do
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">args,</span> <span class="pre">kwargs,</span> <span class="pre">remaining</span> <span class="pre">=</span> <span class="pre">extract_arguments(kwargs,</span> <span class="pre">func)</span>&#160; <span class="pre">#</span> <span class="pre">extract</span> <span class="pre">from</span> <span class="pre">kwargs</span>
<span class="pre">what</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">for</span> <span class="pre">func</span>
<span class="pre">#</span> <span class="pre">...</span> <span class="pre">check</span> <span class="pre">if</span> <span class="pre">remaing</span> <span class="pre">is</span> <span class="pre">empty</span> <span class="pre">(or</span> <span class="pre">not,</span> <span class="pre">depending</span> <span class="pre">on</span> <span class="pre">your</span> <span class="pre">paranoia),</span> <span class="pre">and</span> <span class="pre">then</span>
<span class="pre">call</span> <span class="pre">the</span> <span class="pre">func:</span>
<span class="pre">func(*args,</span> <span class="pre">**kwargs)</span>
<span class="pre">`</span></code>
(And if you doing that a lot: Do put it in a decorator!)</p>
<p>See Also: extract_arguments.without_remainding</p>
<p>The most frequent case you’ll encounter is when there’s no POSITION_ONLY args,
your param_args will be empty
and you param_kwargs will contain all the arguments that match params,
in the order of these params.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>But sometimes you do have POSITION_ONLY arguments.
What extract_arguments will do for you is return the value of these as the first
element of
the triple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>Note above how we get <cite>(1, 2, 3)</cite>, the order defined by the func’s signature,
instead of <cite>(2, 1, 3)</cite>, the order defined by the kwargs.
So it’s the params (e.g. function signature) that determine the order, not kwargs.
When using to call a function, this is especially crucial if we use POSITION_ONLY
arguments.</p>
<p>See also that the third output, the remaining_kwargs, as <cite>{‘extra’: ‘stuff’}</cite> since
it was not in the params of the function.
Even if you include a VAR_KEYWORD kind of argument in the function, it won’t change
this behavior.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>This is because we don’t want to assume that all the kwargs can actually be
included in a call to the function behind the params.
Instead, the user can chose whether to include the remainder by doing a:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">param_kwargs.update(remaining_kwargs)</span>
<span class="pre">`</span></code>
et voilà.</p>
<p>That said, we do understand that it may be a common pattern, so we’ll do that
extra step for you
if you specify <cite>include_all_when_var_keywords_in_params=True</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>
</pre></div>
</div>
<p>If you’re expecting no remainder you might want to just get the args and kwargs (
not this third
expected-to-be-empty remainder). You have two ways to do that, specifying:</p>
<blockquote>
<div><p><cite>what_to_do_with_remainding=’ignore’</cite>, which will just return the (args,
kwargs) pair
<cite>what_to_do_with_remainding=’assert_empty’</cite>, which will do the same, but first
assert the remainder is empty</p>
</div></blockquote>
<p>We suggest to use <cite>functools.partial</cite> to configure the <cite>argument_argument</cite> you need.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">extract_arguments</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s2">&quot;assert_empty&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>And what happens if the kwargs doesn’t contain all the POSITION_ONLY arguments?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s2">&quot;is a kw arg&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="s2">&quot;is not an arg at all&quot;</span><span class="p">)</span>
<span class="go">((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>
</pre></div>
</div>
<p>A few more examples…</p>
<p>Let’s call <cite>extract_arguments</cite> with params being not a function,
but, a Signature instance, a mapping whose values are Parameter instances,
or an iterable of Parameter instances…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_map</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_iterable</span> <span class="o">=</span> <span class="n">param_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_iterable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Edge case:
No params specified? No problem. You’ll just get empty args and kwargs. Everything
in the remainder</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Specifies what PO arguments should be extracted.
Could be a callable, Signature, iterable of Parameters…</p></li>
<li><p><strong>what_to_do_with_remainding</strong> – ‘return’ (default): function will return <cite>param_args</cite>, <cite>param_kwargs</cite>,
<cite>remaining_kwargs</cite>
‘ignore’: function will return <cite>param_args</cite>, <cite>param_kwargs</cite>
‘assert_empty’: function will assert that <cite>remaining_kwargs</cite> is empty and then
return <cite>param_args</cite>, <cite>param_kwargs</cite></p></li>
</ul>
</dd>
</dl>
<p>:param include_all_when_var_keywords_in_params=False,
:param assert_no_missing_position_only_args=False,
:param kwargs: The kwargs to extract the args from
:return: A (param_args, param_kwargs, remaining_kwargs) tuple.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.extract_arguments_asserting_no_remainder">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">extract_arguments_asserting_no_remainder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="default_value">'assert_empty'</span></em>, <em class="sig-param"><span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.extract_arguments_asserting_no_remainder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract arguments needed to satisfy the params of a callable, dealing with the
dirty details.</p>
<p>Returns an (param_args, param_kwargs, remaining_kwargs) tuple where
- param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by
params,
- param_kwargs are those names that are both in params and not in param_args, and
- remaining_kwargs are the remaining.</p>
<p>Intended usage: When you need to call a function <cite>func</cite> that has some
position-only arguments,
but you have a kwargs dict of arguments in your hand. You can’t just to <cite>func(
**kwargs)</cite>.
But you can (now) do
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">args,</span> <span class="pre">kwargs,</span> <span class="pre">remaining</span> <span class="pre">=</span> <span class="pre">extract_arguments(kwargs,</span> <span class="pre">func)</span>&#160; <span class="pre">#</span> <span class="pre">extract</span> <span class="pre">from</span> <span class="pre">kwargs</span>
<span class="pre">what</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">for</span> <span class="pre">func</span>
<span class="pre">#</span> <span class="pre">...</span> <span class="pre">check</span> <span class="pre">if</span> <span class="pre">remaing</span> <span class="pre">is</span> <span class="pre">empty</span> <span class="pre">(or</span> <span class="pre">not,</span> <span class="pre">depending</span> <span class="pre">on</span> <span class="pre">your</span> <span class="pre">paranoia),</span> <span class="pre">and</span> <span class="pre">then</span>
<span class="pre">call</span> <span class="pre">the</span> <span class="pre">func:</span>
<span class="pre">func(*args,</span> <span class="pre">**kwargs)</span>
<span class="pre">`</span></code>
(And if you doing that a lot: Do put it in a decorator!)</p>
<p>See Also: extract_arguments.without_remainding</p>
<p>The most frequent case you’ll encounter is when there’s no POSITION_ONLY args,
your param_args will be empty
and you param_kwargs will contain all the arguments that match params,
in the order of these params.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>But sometimes you do have POSITION_ONLY arguments.
What extract_arguments will do for you is return the value of these as the first
element of
the triple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>Note above how we get <cite>(1, 2, 3)</cite>, the order defined by the func’s signature,
instead of <cite>(2, 1, 3)</cite>, the order defined by the kwargs.
So it’s the params (e.g. function signature) that determine the order, not kwargs.
When using to call a function, this is especially crucial if we use POSITION_ONLY
arguments.</p>
<p>See also that the third output, the remaining_kwargs, as <cite>{‘extra’: ‘stuff’}</cite> since
it was not in the params of the function.
Even if you include a VAR_KEYWORD kind of argument in the function, it won’t change
this behavior.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>This is because we don’t want to assume that all the kwargs can actually be
included in a call to the function behind the params.
Instead, the user can chose whether to include the remainder by doing a:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">param_kwargs.update(remaining_kwargs)</span>
<span class="pre">`</span></code>
et voilà.</p>
<p>That said, we do understand that it may be a common pattern, so we’ll do that
extra step for you
if you specify <cite>include_all_when_var_keywords_in_params=True</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>
</pre></div>
</div>
<p>If you’re expecting no remainder you might want to just get the args and kwargs (
not this third
expected-to-be-empty remainder). You have two ways to do that, specifying:</p>
<blockquote>
<div><p><cite>what_to_do_with_remainding=’ignore’</cite>, which will just return the (args,
kwargs) pair
<cite>what_to_do_with_remainding=’assert_empty’</cite>, which will do the same, but first
assert the remainder is empty</p>
</div></blockquote>
<p>We suggest to use <cite>functools.partial</cite> to configure the <cite>argument_argument</cite> you need.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">extract_arguments</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s2">&quot;assert_empty&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>And what happens if the kwargs doesn’t contain all the POSITION_ONLY arguments?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s2">&quot;is a kw arg&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="s2">&quot;is not an arg at all&quot;</span><span class="p">)</span>
<span class="go">((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>
</pre></div>
</div>
<p>A few more examples…</p>
<p>Let’s call <cite>extract_arguments</cite> with params being not a function,
but, a Signature instance, a mapping whose values are Parameter instances,
or an iterable of Parameter instances…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_map</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_iterable</span> <span class="o">=</span> <span class="n">param_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_iterable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Edge case:
No params specified? No problem. You’ll just get empty args and kwargs. Everything
in the remainder</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Specifies what PO arguments should be extracted.
Could be a callable, Signature, iterable of Parameters…</p></li>
<li><p><strong>what_to_do_with_remainding</strong> – ‘return’ (default): function will return <cite>param_args</cite>, <cite>param_kwargs</cite>,
<cite>remaining_kwargs</cite>
‘ignore’: function will return <cite>param_args</cite>, <cite>param_kwargs</cite>
‘assert_empty’: function will assert that <cite>remaining_kwargs</cite> is empty and then
return <cite>param_args</cite>, <cite>param_kwargs</cite></p></li>
</ul>
</dd>
</dl>
<p>:param include_all_when_var_keywords_in_params=False,
:param assert_no_missing_position_only_args=False,
:param kwargs: The kwargs to extract the args from
:return: A (param_args, param_kwargs, remaining_kwargs) tuple.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.extract_arguments_ignoring_remainder">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">extract_arguments_ignoring_remainder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>inspect.Signature<span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="default_value">'ignore'</span></em>, <em class="sig-param"><span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.extract_arguments_ignoring_remainder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract arguments needed to satisfy the params of a callable, dealing with the
dirty details.</p>
<p>Returns an (param_args, param_kwargs, remaining_kwargs) tuple where
- param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by
params,
- param_kwargs are those names that are both in params and not in param_args, and
- remaining_kwargs are the remaining.</p>
<p>Intended usage: When you need to call a function <cite>func</cite> that has some
position-only arguments,
but you have a kwargs dict of arguments in your hand. You can’t just to <cite>func(
**kwargs)</cite>.
But you can (now) do
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">args,</span> <span class="pre">kwargs,</span> <span class="pre">remaining</span> <span class="pre">=</span> <span class="pre">extract_arguments(kwargs,</span> <span class="pre">func)</span>&#160; <span class="pre">#</span> <span class="pre">extract</span> <span class="pre">from</span> <span class="pre">kwargs</span>
<span class="pre">what</span> <span class="pre">you</span> <span class="pre">need</span> <span class="pre">for</span> <span class="pre">func</span>
<span class="pre">#</span> <span class="pre">...</span> <span class="pre">check</span> <span class="pre">if</span> <span class="pre">remaing</span> <span class="pre">is</span> <span class="pre">empty</span> <span class="pre">(or</span> <span class="pre">not,</span> <span class="pre">depending</span> <span class="pre">on</span> <span class="pre">your</span> <span class="pre">paranoia),</span> <span class="pre">and</span> <span class="pre">then</span>
<span class="pre">call</span> <span class="pre">the</span> <span class="pre">func:</span>
<span class="pre">func(*args,</span> <span class="pre">**kwargs)</span>
<span class="pre">`</span></code>
(And if you doing that a lot: Do put it in a decorator!)</p>
<p>See Also: extract_arguments.without_remainding</p>
<p>The most frequent case you’ll encounter is when there’s no POSITION_ONLY args,
your param_args will be empty
and you param_kwargs will contain all the arguments that match params,
in the order of these params.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>But sometimes you do have POSITION_ONLY arguments.
What extract_arguments will do for you is return the value of these as the first
element of
the triple.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>Note above how we get <cite>(1, 2, 3)</cite>, the order defined by the func’s signature,
instead of <cite>(2, 1, 3)</cite>, the order defined by the kwargs.
So it’s the params (e.g. function signature) that determine the order, not kwargs.
When using to call a function, this is especially crucial if we use POSITION_ONLY
arguments.</p>
<p>See also that the third output, the remaining_kwargs, as <cite>{‘extra’: ‘stuff’}</cite> since
it was not in the params of the function.
Even if you include a VAR_KEYWORD kind of argument in the function, it won’t change
this behavior.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>This is because we don’t want to assume that all the kwargs can actually be
included in a call to the function behind the params.
Instead, the user can chose whether to include the remainder by doing a:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">param_kwargs.update(remaining_kwargs)</span>
<span class="pre">`</span></code>
et voilà.</p>
<p>That said, we do understand that it may be a common pattern, so we’ll do that
extra step for you
if you specify <cite>include_all_when_var_keywords_in_params=True</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">f</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>
</pre></div>
</div>
<p>If you’re expecting no remainder you might want to just get the args and kwargs (
not this third
expected-to-be-empty remainder). You have two ways to do that, specifying:</p>
<blockquote>
<div><p><cite>what_to_do_with_remainding=’ignore’</cite>, which will just return the (args,
kwargs) pair
<cite>what_to_do_with_remainding=’assert_empty’</cite>, which will do the same, but first
assert the remainder is empty</p>
</div></blockquote>
<p>We suggest to use <cite>functools.partial</cite> to configure the <cite>argument_argument</cite> you need.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">extract_arguments</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s2">&quot;assert_empty&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">arg_extractor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="go">((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>
</pre></div>
</div>
<p>And what happens if the kwargs doesn’t contain all the POSITION_ONLY arguments?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s2">&quot;is a kw arg&quot;</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="s2">&quot;is not an arg at all&quot;</span><span class="p">)</span>
<span class="go">((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>
</pre></div>
</div>
<p>A few more examples…</p>
<p>Let’s call <cite>extract_arguments</cite> with params being not a function,
but, a Signature instance, a mapping whose values are Parameter instances,
or an iterable of Parameter instances…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="gp">... </span>    <span class="o">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_map</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_iterable</span> <span class="o">=</span> <span class="n">param_map</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">extra</span><span class="o">=</span><span class="s2">&quot;stuff&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_map</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">extract_arguments</span><span class="p">(</span><span class="n">param_iterable</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="n">extract_arguments</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Edge case:
No params specified? No problem. You’ll just get empty args and kwargs. Everything
in the remainder</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">extract_arguments</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="p">(),</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>params</strong> – Specifies what PO arguments should be extracted.
Could be a callable, Signature, iterable of Parameters…</p></li>
<li><p><strong>what_to_do_with_remainding</strong> – ‘return’ (default): function will return <cite>param_args</cite>, <cite>param_kwargs</cite>,
<cite>remaining_kwargs</cite>
‘ignore’: function will return <cite>param_args</cite>, <cite>param_kwargs</cite>
‘assert_empty’: function will assert that <cite>remaining_kwargs</cite> is empty and then
return <cite>param_args</cite>, <cite>param_kwargs</cite></p></li>
</ul>
</dd>
</dl>
<p>:param include_all_when_var_keywords_in_params=False,
:param assert_no_missing_position_only_args=False,
:param kwargs: The kwargs to extract the args from
:return: A (param_args, param_kwargs, remaining_kwargs) tuple.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.has_signature">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">has_signature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">robust</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#has_signature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.has_signature" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if an object has a signature – i.e. is callable and inspect.signature(
obj) returns something.</p>
<p>This can be used to more easily get signatures in bulk without having to write
try/catches:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span>
<span class="gp">... </span>    <span class="nb">list</span><span class="p">(</span>
<span class="gp">... </span>        <span class="nb">filter</span><span class="p">(</span>
<span class="gp">... </span>            <span class="kc">None</span><span class="p">,</span>
<span class="gp">... </span>            <span class="nb">map</span><span class="p">(</span>
<span class="gp">... </span>                <span class="n">partial</span><span class="p">(</span><span class="n">has_signature</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
<span class="gp">... </span>                <span class="p">(</span><span class="n">Sig</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">Sig</span><span class="o">.</span><span class="n">wrap</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">),</span>
<span class="gp">... </span>        <span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>If robust is set to True, <cite>has_signature</cite> will use <cite>Sig</cite> to get the signature,
so will return True in most cases.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.insert_annotations">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">insert_annotations</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span><span class="p">:</span> <span class="n">inspect.Signature</span></em>, <em class="sig-param"><span class="o">/</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">return_annotation</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">annotations</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#insert_annotations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.insert_annotations" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert annotations in a signature.
(Note: not really insert but returns a copy of input signature)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">&lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ss</span> <span class="o">=</span> <span class="n">insert_annotations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ss</span>
<span class="go">&lt;Signature (a, b: int, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">insert_annotations</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">These argument names weren&#39;t found in the signature: {&#39;e&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.is_call_compatible_with">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">is_call_compatible_with</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig1</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#dol.signatures.Sig" title="dol.signatures.Sig">dol.signatures.Sig</a></span></em>, <em class="sig-param"><span class="n">sig2</span><span class="p">:</span> <span class="n"><a class="reference internal" href="#dol.signatures.Sig" title="dol.signatures.Sig">dol.signatures.Sig</a></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">param_comparator</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>inspect.Parameter<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Comparison<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span> &#x2192; bool<a class="reference internal" href="../../_modules/dol/signatures.html#is_call_compatible_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.is_call_compatible_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if <code class="docutils literal notranslate"><span class="pre">sig1</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">sig2</span></code>. Meaning that all valid ways
to call <code class="docutils literal notranslate"><span class="pre">sig1</span></code> are valid for <code class="docutils literal notranslate"><span class="pre">sig2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig1</strong> – The main signature.</p></li>
<li><p><strong>sig2</strong> – The signature to be compared with.</p></li>
<li><p><strong>param_comparator</strong> – The function used to compare two parameters</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, b, c)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a=0)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, *, c)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, *, c)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b=0, *, c)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c=0)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_call_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.is_param_compatible_with">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">is_param_compatible_with</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p1</span><span class="p">:</span> <span class="n">inspect.Parameter</span></em>, <em class="sig-param"><span class="n">p2</span><span class="p">:</span> <span class="n">inspect.Parameter</span></em>, <em class="sig-param"><span class="n">annotation_comparator</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Compared<span class="p">, </span>Compared<span class="p">]</span><span class="p">, </span>Comparison<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">default_value_comparator</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Compared<span class="p">, </span>Compared<span class="p">]</span><span class="p">, </span>Comparison<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#is_param_compatible_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.is_param_compatible_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if <code class="docutils literal notranslate"><span class="pre">p1</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">p2</span></code>. Meaning that any value valid
for <code class="docutils literal notranslate"><span class="pre">p1</span></code> is valid for <code class="docutils literal notranslate"><span class="pre">p2</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> – The main parameter.</p></li>
<li><p><strong>p2</strong> – The parameter to be compared with.</p></li>
<li><p><strong>annotation_comparator</strong> – The function used to compare the annotations</p></li>
<li><p><strong>default_value_comparator</strong> – The function used to compare the default values</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">is_param_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_param_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_param_compatible_with</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">PO</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.keyed_comparator">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">keyed_comparator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">comparator</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>Compared<span class="p">, </span>Compared<span class="p">]</span><span class="p">, </span>Comparison<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">key</span><span class="p">:</span> <span class="n">Callable<span class="p">[</span><span class="p">[</span>CT<span class="p">]</span><span class="p">, </span>Compared<span class="p">]</span></span></em><span class="sig-paren">)</span> &#x2192; Callable<span class="p">[</span><span class="p">[</span>Compared<span class="p">, </span>Compared<span class="p">]</span><span class="p">, </span>Comparison<span class="p">]</span><a class="reference internal" href="../../_modules/dol/signatures.html#keyed_comparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.keyed_comparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a key-function enabled binary operator.</p>
<p>In various places in python functionality is extended by allowing a key function.
For example, the <code class="docutils literal notranslate"><span class="pre">sorted</span></code> function allows a key function to be passed, which is
applied to each element before sorting. The keyed_comparator function allows a
comparator to be extended in the same way. The returned comparator will apply the
key function toeach input before applying the original comparator.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">eq</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">comparator</span> <span class="o">=</span> <span class="n">keyed_comparator</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">parity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">comparator</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>
<span class="go">[True, False, False, True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.kind_forgiving_func">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">kind_forgiving_func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#kind_forgiving_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.kind_forgiving_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a version of the function that has all POSITIONAL_OR_KEYWORD kinds</p>
<p>The inspiring use case: Many builtins have restrictive parameter kinds which makes it hard to
curry, amongst other such annoyances. For instance, say you want to curry
<cite>isinstance</cite> to make a boolean function that detects string types.
You can’t with partial, because you can’t access the position only
<cite>class_or_tuple</cite> argument to fix it.</p>
<p>Well, make a <cite>kind_forgiving_func</cite> version, and partial to your heart’s content!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_isinstance</span> <span class="o">=</span> <span class="n">kind_forgiving_func</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isinstance_of_str</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_isinstance</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">isinstance_of_str</span><span class="p">(</span><span class="s1">&#39;asdf&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.mk_sig_from_args">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">mk_sig_from_args</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args_without_default</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">args_with_defaults</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#mk_sig_from_args"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.mk_sig_from_args" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a Signature instance by specifying args_without_default and
args_with_defaults.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mk_sig_from_args</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="go">&lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.name_of_obj">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">name_of_obj</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">o</span><span class="p">:</span> <span class="n">object</span></em><span class="sig-paren">)</span> &#x2192; Optional<span class="p">[</span>str<span class="p">]</span><a class="reference internal" href="../../_modules/dol/signatures.html#name_of_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.name_of_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find the (or “a”) name for an object, even if <cite>__name__</cite> doesn’t exist.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">name_of_obj</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="go">&#39;map&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_of_obj</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="go">&#39;list&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_of_obj</span><span class="p">(</span><span class="nb">print</span><span class="p">)</span>
<span class="go">&#39;print&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_of_obj</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="go">&#39;&lt;lambda&gt;&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">name_of_obj</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
<span class="go">&#39;print&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.param_binary_func">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">param_binary_func</code><span class="sig-paren">(</span><em class="sig-param">param1: inspect.Parameter, param2: inspect.Parameter, *, name: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, kind: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, default: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, annotation: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, aggreg: Callable[[Iterable[Comparison]], Any] = &lt;built-in function all&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.param_binary_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two parameters.</p>
<p>Note that by default, this function is strict, and will return False if
any of the parameters are not equal. This is because the default
aggregation function is <cite>all</cite> and the default comparison functions of the
parameter’s attributes are <cite>eq</cite> (meaning equality, not identity).</p>
<p>But you can change that by passing different comparison functions and/or
aggregation functions.</p>
<p>In fact, the real purpose of this function is to be used as a factory of parameter
binary functions, through parametrizing it with <cite>functools.partial</cite>.</p>
<p>The parameter binary functions themselves are meant to be used to make signature
binary functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param1</strong> – first parameter</p></li>
<li><p><strong>param2</strong> – second parameter</p></li>
<li><p><strong>name</strong> – function to compare names</p></li>
<li><p><strong>kind</strong> – function to compare kinds</p></li>
<li><p><strong>default</strong> – function to compare defaults</p></li>
<li><p><strong>annotation</strong> – function to compare annotations</p></li>
<li><p><strong>aggreg</strong> – function to aggregate results</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param1</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param2</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_binary_func</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/i2mint/i2/issues/50#issuecomment-1381686812">https://github.com/i2mint/i2/issues/50#issuecomment-1381686812</a> for discussion.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.param_comparator">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">param_comparator</code><span class="sig-paren">(</span><em class="sig-param">param1: inspect.Parameter, param2: inspect.Parameter, *, name: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, kind: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, default: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, annotation: Callable[[Compared, Compared], Comparison] = &lt;built-in function eq&gt;, aggreg: Callable[[Iterable[Comparison]], Any] = &lt;built-in function all&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#param_comparator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.param_comparator" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare two parameters.</p>
<p>Note that by default, this function is strict, and will return False if
any of the parameters are not equal. This is because the default
aggregation function is <cite>all</cite> and the default comparison functions of the
parameter’s attributes are <cite>eq</cite> (meaning equality, not identity).</p>
<p>But you can change that by passing different comparison functions and/or
aggregation functions.</p>
<p>In fact, the real purpose of this function is to be used as a factory of parameter
binary functions, through parametrizing it with <cite>functools.partial</cite>.</p>
<p>The parameter binary functions themselves are meant to be used to make signature
binary functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>param1</strong> – first parameter</p></li>
<li><p><strong>param2</strong> – second parameter</p></li>
<li><p><strong>name</strong> – function to compare names</p></li>
<li><p><strong>kind</strong> – function to compare kinds</p></li>
<li><p><strong>default</strong> – function to compare defaults</p></li>
<li><p><strong>annotation</strong> – function to compare annotations</p></li>
<li><p><strong>aggreg</strong> – function to aggregate results</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param1</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param2</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_binary_func</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>See <a class="reference external" href="https://github.com/i2mint/i2/issues/50#issuecomment-1381686812">https://github.com/i2mint/i2/issues/50#issuecomment-1381686812</a> for discussion.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.param_for_kind">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">param_for_kind</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">kind='positional_or_keyword'</em>, <em class="sig-param">with_default=False</em>, <em class="sig-param">annotation</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#param_for_kind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.param_for_kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to easily and flexibly make inspect.Parameter objects for testing.</p>
<p>It’s annoying to have to compose parameters from scratch to testing things.
This tool should help making it less annoying.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">param_kinds</span><span class="p">))</span>
<span class="go">[&lt;Parameter &quot;POSITIONAL_ONLY&quot;&gt;, &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;, &lt;Parameter &quot;VAR_POSITIONAL&quot;&gt;, &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;, &lt;Parameter &quot;VAR_KEYWORD&quot;&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_for_kind</span><span class="o">.</span><span class="n">positional_or_keyword</span><span class="p">()</span>
<span class="go">&lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_for_kind</span><span class="o">.</span><span class="n">positional_or_keyword</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;foo&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_for_kind</span><span class="o">.</span><span class="n">keyword_only</span><span class="p">()</span>
<span class="go">&lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">param_for_kind</span><span class="o">.</span><span class="n">keyword_only</span><span class="p">(</span><span class="s2">&quot;baz&quot;</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;baz=&#39;dflt_keyword_only&#39;&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.set_signature_of_func">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">set_signature_of_func</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">parameters</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">return_annotation</span></em>, <em class="sig-param"><span class="n">__validate_parameters__</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#set_signature_of_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.set_signature_of_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the signature of a function, with sugar.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – Function whose signature you want to set</p></li>
<li><p><strong>signature</strong> – A list of parameter specifications. This could be an</p></li>
<li><p><strong>object</strong><strong> or </strong><strong>anything that</strong> (<em>inspect.Parameter</em>) – the mk_param function can resolve into an inspect.Parameter object.</p></li>
<li><p><strong>return_annotation</strong> – Passed on to inspect.Signature.</p></li>
<li><p><strong>__validate_parameters__</strong> – Passed on to inspect.Signature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>None (but sets the signature of the input function)</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Signature (*args, **kwargs)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_signature_of_func</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Signature (a, b, c)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_signature_of_func</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># specifying defaults and annotations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Signature (a, b=None, c: int = 42)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_signature_of_func</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="n">return_annotation</span><span class="o">=</span><span class="nb">str</span>
<span class="gp">... </span><span class="p">)</span>  <span class="c1"># specifying return annotation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Signature (a, b, c) -&gt; str&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># But you can always specify parameters the &quot;long&quot; way</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">set_signature_of_func</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">foo</span><span class="p">,</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;kws&quot;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">)],</span>
<span class="gp">... </span>    <span class="n">return_annotation</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="go">&lt;Signature (**kws) -&gt; str&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.sig_to_dataclass">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">sig_to_dataclass</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>inspect.Signature<span class="p">, </span>Iterable<span class="p">[</span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Mapping<span class="p">[</span>str<span class="p">, </span>inspect.Parameter<span class="p">]</span><span class="p">, </span>Callable<span class="p">, </span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">cls_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">bases</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">module</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#sig_to_dataclass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.sig_to_dataclass" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a <code class="docutils literal notranslate"><span class="pre">class</span></code> (through <code class="docutils literal notranslate"><span class="pre">make_dataclass</span></code>) from the given signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sig</strong> – A <code class="docutils literal notranslate"><span class="pre">SignatureAble</span></code>, that is, anything that ensure_signature can
resolve into an <code class="docutils literal notranslate"><span class="pre">inspect.Signature</span></code> object, including a signature object
itself, but also most callables, a list or params, etc.</p></li>
<li><p><strong>cls_name</strong> – The same as <code class="docutils literal notranslate"><span class="pre">cls_name</span></code> of <code class="docutils literal notranslate"><span class="pre">dataclasses.make_dataclass</span></code></p></li>
<li><p><strong>bases</strong> – The same as <code class="docutils literal notranslate"><span class="pre">bases</span></code> of <code class="docutils literal notranslate"><span class="pre">dataclasses.make_dataclass</span></code></p></li>
<li><p><strong>module</strong> – Set to module (usually <code class="docutils literal notranslate"><span class="pre">__name__</span></code> to specify ther module of
caller) so that the class and instances can be pickle-able.</p></li>
<li><p><strong>kwargs</strong> – Passed on to <code class="docutils literal notranslate"><span class="pre">dataclasses.make_dataclass</span></code></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dataclass</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">sig_to_dataclass</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">cls_name</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
<span class="go">&#39;(a, b: int = 2, c=3) -&gt; None&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
<span class="go">(1, 2, 3)</span>
</pre></div>
</div>
<p>Would also work with any of these (and more):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">sig_to_dataclass</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="n">cls_name</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">sig_to_dataclass</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">cls_name</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note: <code class="docutils literal notranslate"><span class="pre">cls_name</span></code> is not required (we’ll try to figure out a good default for you),
but it’s advised to only use this convenience in extreme mode.
Choosing your own name might make for a safer future if you’re reusing your class.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.sort_params">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">sort_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">params</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#sort_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.sort_params" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> – An iterable of <cite>Parameter</cite> instances</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of these instances sorted so as to obey the <code class="docutils literal notranslate"><span class="pre">kind</span></code> and <code class="docutils literal notranslate"><span class="pre">default</span></code>
order rules of python signatures.</p>
</dd>
</dl>
<p>Note 1: It doesn’t mean that these params constitute a valid signature together,
since it doesn’t verify rules like unicity of names and variadic kinds.</p>
<p>Note 2: Though you can use <code class="docutils literal notranslate"><span class="pre">sorted</span></code> on an iterable of <code class="docutils literal notranslate"><span class="pre">i2.signatures.Param</span></code>
instances, know that even for sorting the three parameters below,
the <code class="docutils literal notranslate"><span class="pre">sort_params</span></code> function is more than twice as fast.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sort_params</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">Parameter</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">[&lt;Parameter &quot;b&quot;&gt;, &lt;Parameter &quot;c&quot;&gt;, &lt;Parameter &quot;a=1&quot;&gt;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.tuple_the_args">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">tuple_the_args</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dol.signatures.tuple_the_args" title="Permalink to this definition">¶</a></dt>
<dd><p>A decorator that will change a VAR_POSITIONAL (<a href="#id43"><span class="problematic" id="id44">*</span></a>args) argument to a tuple (args)
argument of the same name.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.signatures.use_interface">
<code class="sig-prename descclassname">dol.signatures.</code><code class="sig-name descname">use_interface</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">interface_sig</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/signatures.html#use_interface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.signatures.use_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Use interface_sig as (enforced/validated) signature of the decorated function.
That is, the decorated function will use the original function has the backend,
the function actually doing the work, but with a frontend specified
(in looks and in argument validation) <cite>interface_sig</cite></p>
<p>consider the situation where are functionality is parametrized by a
function <cite>g</cite> taking two inputs, <cite>a</cite>, and <cite>b</cite>.
Now you want to carry out this functionality using a function <cite>f</cite> that does what
<cite>g</cite> should do, but doesn’t use <cite>a</cite>, and doesn’t even have it in it’s arguments.</p>
<p>The solution to this is to _adapt_ <cite>f</cite> to the <cite>g</cite> interface:
<a href="#id45"><span class="problematic" id="id46">``</span></a>`
def my_g(a, b):</p>
<blockquote>
<div><p>return f(a)</p>
</div></blockquote>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a>`
and use <cite>my_g</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">11</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interface</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_f</span> <span class="o">=</span> <span class="n">use_interface</span><span class="p">(</span><span class="n">interface</span><span class="p">)(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>See how only the first argument, or <cite>a</cite> keyword argument, is taken into account
in <cite>new_f</cite>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">new_f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">new_f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">new_f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">new_f</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>But if we add more positional arguments than <cite>interface</cite> allows,
or any keyword arguments that <cite>interface</cite> doesn’t recognize…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">too many positional arguments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">got an unexpected keyword argument &#39;c&#39;</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="scrap/store_factories.html" class="btn btn-neutral float-left" title="dol.scrap.store_factories" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sources.html" class="btn btn-neutral float-right" title="dol.sources" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>