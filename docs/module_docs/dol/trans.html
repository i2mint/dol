
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>dol.trans &#8212; dol 0.1.39 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="dol.util" href="util.html" />
    <link rel="prev" title="dol.tests.scrap" href="tests/scrap.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-dol.trans">
<span id="dol-trans"></span><h1>dol.trans<a class="headerlink" href="#module-dol.trans" title="Permalink to this headline">¶</a></h1>
<p>Transformation/wrapping tools</p>
<dl class="py class">
<dt id="dol.trans.OverWritesNotAllowedMixin">
<em class="property">class </em><code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">OverWritesNotAllowedMixin</code><a class="reference internal" href="../../_modules/dol/trans.html#OverWritesNotAllowedMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.OverWritesNotAllowedMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin for only allowing a write to a key if they key doesn’t already exist.
Note: Should be before the persister in the MRO.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">TestPersister</span><span class="p">(</span><span class="n">OverWritesNotAllowedMixin</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">TestPersister</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#p[&#39;foo&#39;] = &#39;bar2&#39;  # will raise error</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;this value should not be stored&#39;</span> 
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">dol.errors.OverWritesNotAllowedError</span>: <span class="n">key foo already exists and cannot be overwritten.</span>
<span class="go">    If you really want to write to that key, delete it before writing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>  <span class="c1"># foo is still bar</span>
<span class="go">&#39;bar&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;this value WILL be stored&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">]</span>
<span class="go">&#39;this value WILL be stored&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.add_ipython_key_completions">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">add_ipython_key_completions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#add_ipython_key_completions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.add_ipython_key_completions" title="Permalink to this definition">¶</a></dt>
<dd><p>Add tab completion that shows you the keys of the store.
Note: ipython already adds local path listing automatically,</p>
<blockquote>
<div><p>so you’ll still get those along with your valid store keys.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.add_path_get">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">add_path_get</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">name=None</em>, <em class="sig-param">path_type: type = &lt;class 'tuple'&gt;</em>, <em class="sig-param">__module__=None</em>, <em class="sig-param">__name__=None</em>, <em class="sig-param">__qualname__=None</em>, <em class="sig-param">__doc__=None</em>, <em class="sig-param">__annotations__=None</em>, <em class="sig-param">__defaults__=None</em>, <em class="sig-param">__kwdefaults__=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#add_path_get"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.add_path_get" title="Permalink to this definition">¶</a></dt>
<dd><p>Make nested stores accessible through key paths.
In a way “flatten the nested keys access”.
By default, the path object will be a tuple (e.g. <code class="docutils literal notranslate"><span class="pre">('a',</span> <span class="pre">'b',</span> <span class="pre">'c')</span></code>, but you can
make it whatever you want, and/or use <cite>dol.paths.KeyPath</cite> to map to and from
forms like <code class="docutils literal notranslate"><span class="pre">'a.b.c'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a/b/c'</span></code>, etc.</p>
<p>Say you have some nested stores.
You know… like a <cite>ZipFileReader</cite> store whose values are <a href="#id1"><span class="problematic" id="id2">`</span></a>ZipReader`s,
whose values are bytes of the zipped files
(and you can go on… whose (json) values are…).</p>
<p>For our example, let’s take a nested dict instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}}}</span>
</pre></div>
</div>
<p>Well, you can access any node of this nested tree of stores like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
<p>And that’s fine. But maybe you’d like to do it this way instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">add_path_get</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
<p>You might also want to access 42 with <cite>a.b.c</cite> or <cite>a/b/c</cite> etc.
To do that you can use <cite>dol.paths.KeyPath</cite> in combination with</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store (class or instance) you’re wrapping.
If not specified, the function will return a decorator.</p></li>
<li><p><strong>name</strong> – The name to give the class (not applicable to instance wrapping)</p></li>
<li><p><strong>path_type</strong> – The type that paths are expressed as. Needs to be an Iterable type.
By default, a tuple.
This is used to decide whether the key should be taken as a “normal”
key of the store,
or should be used to iterate through, recursively getting values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A wrapped store (class or instance), or a store wrapping decorator
(if store is not specified)</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">KeyPath</span></code> in <a class="reference internal" href="paths.html"><span class="doc">dol.paths</span></a></p>
</div>
<p>Wrapping an instance</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">add_path_get</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
<span class="go">{&#39;b&#39;: {&#39;c&#39;: 42}}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="go">{&#39;c&#39;: 42}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
<p>Wrapping a class</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">add_path_get</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>Using add_path_get as a decorator</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@add_path_get</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">S</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>A different kind of path?
You can choose a different path_type, but sometimes (say both keys and key paths are strings)
You need to involve more tools. Like dol.paths.KeyPath…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dol.paths</span> <span class="kn">import</span> <span class="n">KeyPath</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dol.trans</span> <span class="kn">import</span> <span class="n">kv_wrap</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">SS</span> <span class="o">=</span> <span class="n">kv_wrap</span><span class="p">(</span><span class="n">KeyPath</span><span class="p">(</span><span class="n">path_sep</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">))(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">SS</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}};</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a.b&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">];</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a.b.c&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">][</span><span class="s1">&#39;b&#39;</span><span class="p">][</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.add_store_method">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">add_store_method</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span><span class="p">:</span> <span class="n">type</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">method_func</span></em>, <em class="sig-param"><span class="n">method_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">validator</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Callable<span class="p">[</span><span class="p">[</span>type<span class="p">, </span>Callable<span class="p">]</span><span class="p">, </span>bool<span class="p">]</span><span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__qualname__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__doc__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__annotations__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__defaults__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__kwdefaults__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#add_store_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.add_store_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Add methods to store classes or instances</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – A store type or instance</p></li>
<li><p><strong>method_func</strong> – The function of the method to be added</p></li>
<li><p><strong>method_name</strong> – The name of the store attribute this function should be written to</p></li>
<li><p><strong>validator</strong> – An optional validator. If not None, <code class="docutils literal notranslate"><span class="pre">validator(store,</span> <span class="pre">method_func)</span></code> will be called.
If it doesn’t return True, a <code class="docutils literal notranslate"><span class="pre">SetattrNotAllowed</span></code> will be raised.
Note that <code class="docutils literal notranslate"><span class="pre">validator</span></code> can also raise its own exception.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A store with the added (or modified) method</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.add_wrapper_method">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">add_wrapper_method</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wrap_cls</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">method_name</span><span class="o">=</span><span class="default_value">'wrapper'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#add_wrapper_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.add_wrapper_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorator that adds a wrapper method (itself a decorator) to a wrapping class
Clear?
See <cite>mk_wrapper</cite> function and doctest example if not.</p>
<p>What <cite>add_wrapper_method</cite> does is just to add a <cite>“wrapper”</cite> method
(or another name if you ask for it) to <cite>wrap_cls</cite>, so that you can use that
class for it’s purpose of transforming stores more conveniently.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wrap_cls</strong> – The wrapper class (the definitioin of the transformation.
If None, the functiion will make a decorator to decorate wrap_cls later</p></li>
<li><p><strong>method_name</strong> – The method name you want to use (default is ‘wrapper’)</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@add_wrapper_method</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">RelPath</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_root_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_key_of_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">_id</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_root_length</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">+</span> <span class="n">k</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RelDict</span> <span class="o">=</span> <span class="n">RelPath</span><span class="o">.</span><span class="n">wrapper</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="s1">&#39;foo/&#39;</span><span class="p">)(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">RelDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;{&#39;foo/bar&#39;: 42}&quot;</span>  <span class="c1"># reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.cache_iter">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">cache_iter</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">keys_cache: Union[callable</em>, <em class="sig-param">Collection] = &lt;class 'list'&gt;</em>, <em class="sig-param">iter_to_container=None</em>, <em class="sig-param">cache_update_method='update'</em>, <em class="sig-param">name: str = None</em>, <em class="sig-param">__module__=None</em>, <em class="sig-param">__name__=None</em>, <em class="sig-param">__qualname__=None</em>, <em class="sig-param">__doc__=None</em>, <em class="sig-param">__annotations__=None</em>, <em class="sig-param">__defaults__=None</em>, <em class="sig-param">__kwdefaults__=None</em><span class="sig-paren">)</span> &#x2192; Union<span class="p">[</span>callable<span class="p">, </span><a class="reference internal" href="base.html#dol.base.KvReader" title="dol.base.KvReader">dol.base.KvReader</a><span class="p">]</span><a class="headerlink" href="#dol.trans.cache_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a class that wraps input class’s __iter__ becomes cached.</p>
<p>Quite often we have a lot of keys, that we get from a remote data source, and don’t want to have to ask for
them again and again, having them be fetched, sent over the network, etc.
So we need caching.</p>
<p>But this caching is not the typical read caching, since it’s __iter__ we want to cache, and that’s a generator.
So we’ll implement a store class decorator specialized for this.</p>
<p>The following decorator, when applied to a class (that has an __iter__), will perform the __iter__ code, consuming
all items of the generator and storing them in _keys_cache, and then will yield from there every subsequent call.</p>
<p>It is assumed, if you’re using the cached_keys transformation, that you’re dealing with static data
(or data that can be considered static for the life of the store – for example, when conducting analytics).
If you ever need to refresh the cache during the life of the store, you can to delete _keys_cache like this:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">del</span> <span class="pre">your_store._keys_cache</span>
<span class="pre">`</span></code>
Once you do that, the next time you try to ask something about the contents of the store, it will actually do
a live query again, as for the first time.</p>
<p>Note: The default keys_cache is list though in many cases, you’d probably should use set, or an explicitly
computer set instead. The reason list is used as the default is because (1) we didn’t want to assume that
order did not matter (maybe it does to you) and (2) we didn’t want to assume that your keys were hashable.
That said, if you’re keys are hashable, and order does not matter, use set. That’ll give you two things:
(a) your <cite>key in store</cite> checks will be faster (O(1) instead of O(n)) and (b) you’ll enforce unicity of keys.</p>
<p>Know also that if you precompute the keys you want to cache with a container that has an update
method (by default <cite>update</cite>) your cache updates will be faster and if the container you use has
a <cite>remove</cite> method, you’ll be able to delete as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store instance or class to wrap (must have an __iter__), or None if you want a decorator.</p></li>
<li><p><strong>keys_cache</strong> – An explicit collection of keys</p></li>
<li><p><strong>iter_to_container</strong> – The function that will be applied to existing __iter__() and assigned to cache.
The default is list. Another useful one is the sorted function.</p></li>
<li><p><strong>cache_update_method</strong> – <p>Name of the keys_cache update method to use, if it is an attribute of keys_cache.
Note that this cache_update_method will be used only</p>
<blockquote>
<div><p>if keys_cache is an explicit iterable and has that attribute
if keys_cache is a callable and has that attribute.</p>
</div></blockquote>
<p>The default None</p>
</p></li>
<li><p><strong>name</strong> – The name of the new class</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>None: Will return a decorator that can be applied to a store</dt><dd><p>a store class: Will return a wrapped class that caches it’s keys
a store instance: Will return a wrapped instance that caches it’s keys</p>
</dd>
<dt>The instances of such key-cached classes have some extra attributes:</dt><dd><p>_explicit_keys: The actual cache. An iterable container
update_keys_cache: Is called if a user uses the instance to mutate the store (i.e. write or delete).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>If store is</p>
</dd>
</dl>
<p>You have two ways of caching keys:
- By providing the explicit list of keys you want cache (and use)
- By providing a callable that will iterate through your store and collect an explicit list of keys</p>
<p>Let’s take a simple dict as our original store.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Specify an iterable, and it will be used as the cached keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cached</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="s1">&#39;bc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">cached</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># notice that the order you get things is also ruled by the cache</span>
<span class="go">[(&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>Specify a callable, and it will apply it to the existing keys to make your cache</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">cached_keys</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<p>You can use the callable keys_cache specification to filter as well!
Oh, and let’s demo the fact that if you don’t specify the store, it will make a store decorator for you:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cache_my_keys</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">keys</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>  <span class="c1"># used as to transform an instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Let’s use that same <cite>cache_my_keys</cite> to decorate a class instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cached_dict</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cached_dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Note that there’s still an underlying store (dict) that has the data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># repr isn&#39;t wrapped, so you can still see your underlying dict</span>
<span class="go">&quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 1}&quot;</span>
</pre></div>
</div>
<p>And yes, you can still add elements,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26)]</span>
</pre></div>
</div>
<p>do bulk updates,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;more&#39;</span><span class="p">:</span> <span class="s1">&#39;of this&#39;</span><span class="p">},</span> <span class="n">more_of</span><span class="o">=</span><span class="s1">&#39;that&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more&#39;, &#39;of this&#39;), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>and delete…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;more&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>But careful! Know what you’re doing if you try to get creative. Have a look at this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># add an &#39;a&#39; item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">and_more</span><span class="o">=</span><span class="s1">&#39;of that&#39;</span><span class="p">)</span>  <span class="c1"># update to add yet another item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>Indeed: No ‘a’ or ‘and_more’.</p>
<p>Now… they were indeed added. Or to be more precise, the value of the already existing a was changed,
and a new (‘and_more’, ‘of that’) item was indeed added in the underlying store:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 100, &#39;z&#39;: 26, &#39;more_of&#39;: &#39;that&#39;, &#39;and_more&#39;: &#39;of that&#39;}&quot;</span>
</pre></div>
</div>
<p>But you’re not seeing it.</p>
<p>Why?</p>
<p>Because you chose to use a callable keys_cache that doesn’t have an ‘update’ method.
When your _keys_cache attribute (the iterable cache) is not updatable itself, the
way updates work is that we iterate through the underlying store (where the updates actually took place),
and apply the keys_cache (callable) to that iterable.</p>
<p>So what happened here was that you have your new ‘a’ and ‘and_more’ items, but your cached version of the
store doesn’t see it because it’s filtered out. On the other hand, check out what happens if you have
an updateable cache.</p>
<p>Using <cite>set</cite> instead of <cite>list</cite>, after the <cite>filter</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cache_my_keys</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">keys_cache</span><span class="o">=</span><span class="nb">set</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>  <span class="c1"># used as to transform an instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># using sorted because a set&#39;s order is not always the same</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">and_more</span><span class="o">=</span><span class="s1">&#39;of that&#39;</span><span class="p">)</span>  <span class="c1"># update to add yet another item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 100), (&#39;and_more&#39;, &#39;of that&#39;), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>This example was to illustrate a more subtle aspect of cached_keys. You would probably deal with
the filter concern in a different way in this case. But the rope is there – it’s your choice on how
to use it.</p>
<p>And here’s some more examples if that wasn’t enough!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Lets cache the keys of a dict.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cached_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cached_dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And you get a store that behaves as expected (but more speed and RAM)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># whether you iterate with .keys(), .values(), or .items()</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>This is where the keys are stored:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">_keys_cache</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be in the order they were defined</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;bbb&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted according to their length</span>
<span class="go">[&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
</pre></div>
</div>
<p>If you change the keys (adding new ones with __setitem__ or update, or removing with pop or popitem)
then the cache is recomputed (the first time you use an operation that iterates over keys)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># let&#39;s add an element (try d[&#39;d&#39;] = 4 as well)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># whether you iterate with .keys(), .values(), or .items()</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@cached_keys</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield from</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note, could have also used this form: AA = cached_keys(A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">_keys_cache</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>  <span class="c1"># changing the cache, to prove that subsequent listing will read from there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># proof:</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be in the order they were defined</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;bbb&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted according to their length</span>
<span class="go">[&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.cached_keys">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">cached_keys</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">keys_cache: Union[callable</em>, <em class="sig-param">Collection] = &lt;class 'list'&gt;</em>, <em class="sig-param">iter_to_container=None</em>, <em class="sig-param">cache_update_method='update'</em>, <em class="sig-param">name: str = None</em>, <em class="sig-param">__module__=None</em>, <em class="sig-param">__name__=None</em>, <em class="sig-param">__qualname__=None</em>, <em class="sig-param">__doc__=None</em>, <em class="sig-param">__annotations__=None</em>, <em class="sig-param">__defaults__=None</em>, <em class="sig-param">__kwdefaults__=None</em><span class="sig-paren">)</span> &#x2192; Union<span class="p">[</span>callable<span class="p">, </span><a class="reference internal" href="base.html#dol.base.KvReader" title="dol.base.KvReader">dol.base.KvReader</a><span class="p">]</span><a class="reference internal" href="../../_modules/dol/trans.html#cached_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.cached_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a class that wraps input class’s __iter__ becomes cached.</p>
<p>Quite often we have a lot of keys, that we get from a remote data source, and don’t want to have to ask for
them again and again, having them be fetched, sent over the network, etc.
So we need caching.</p>
<p>But this caching is not the typical read caching, since it’s __iter__ we want to cache, and that’s a generator.
So we’ll implement a store class decorator specialized for this.</p>
<p>The following decorator, when applied to a class (that has an __iter__), will perform the __iter__ code, consuming
all items of the generator and storing them in _keys_cache, and then will yield from there every subsequent call.</p>
<p>It is assumed, if you’re using the cached_keys transformation, that you’re dealing with static data
(or data that can be considered static for the life of the store – for example, when conducting analytics).
If you ever need to refresh the cache during the life of the store, you can to delete _keys_cache like this:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">del</span> <span class="pre">your_store._keys_cache</span>
<span class="pre">`</span></code>
Once you do that, the next time you try to ask something about the contents of the store, it will actually do
a live query again, as for the first time.</p>
<p>Note: The default keys_cache is list though in many cases, you’d probably should use set, or an explicitly
computer set instead. The reason list is used as the default is because (1) we didn’t want to assume that
order did not matter (maybe it does to you) and (2) we didn’t want to assume that your keys were hashable.
That said, if you’re keys are hashable, and order does not matter, use set. That’ll give you two things:
(a) your <cite>key in store</cite> checks will be faster (O(1) instead of O(n)) and (b) you’ll enforce unicity of keys.</p>
<p>Know also that if you precompute the keys you want to cache with a container that has an update
method (by default <cite>update</cite>) your cache updates will be faster and if the container you use has
a <cite>remove</cite> method, you’ll be able to delete as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store instance or class to wrap (must have an __iter__), or None if you want a decorator.</p></li>
<li><p><strong>keys_cache</strong> – An explicit collection of keys</p></li>
<li><p><strong>iter_to_container</strong> – The function that will be applied to existing __iter__() and assigned to cache.
The default is list. Another useful one is the sorted function.</p></li>
<li><p><strong>cache_update_method</strong> – <p>Name of the keys_cache update method to use, if it is an attribute of keys_cache.
Note that this cache_update_method will be used only</p>
<blockquote>
<div><p>if keys_cache is an explicit iterable and has that attribute
if keys_cache is a callable and has that attribute.</p>
</div></blockquote>
<p>The default None</p>
</p></li>
<li><p><strong>name</strong> – The name of the new class</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>None: Will return a decorator that can be applied to a store</dt><dd><p>a store class: Will return a wrapped class that caches it’s keys
a store instance: Will return a wrapped instance that caches it’s keys</p>
</dd>
<dt>The instances of such key-cached classes have some extra attributes:</dt><dd><p>_explicit_keys: The actual cache. An iterable container
update_keys_cache: Is called if a user uses the instance to mutate the store (i.e. write or delete).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>If store is</p>
</dd>
</dl>
<p>You have two ways of caching keys:
- By providing the explicit list of keys you want cache (and use)
- By providing a callable that will iterate through your store and collect an explicit list of keys</p>
<p>Let’s take a simple dict as our original store.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Specify an iterable, and it will be used as the cached keys</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cached</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="s1">&#39;bc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">cached</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># notice that the order you get things is also ruled by the cache</span>
<span class="go">[(&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>Specify a callable, and it will apply it to the existing keys to make your cache</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">cached_keys</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">))</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<p>You can use the callable keys_cache specification to filter as well!
Oh, and let’s demo the fact that if you don’t specify the store, it will make a store decorator for you:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cache_my_keys</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">keys</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">keys</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>  <span class="c1"># used as to transform an instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Let’s use that same <cite>cache_my_keys</cite> to decorate a class instead:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cached_dict</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cached_dict</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;c&#39;, &#39;b&#39;]</span>
</pre></div>
</div>
<p>Note that there’s still an underlying store (dict) that has the data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># repr isn&#39;t wrapped, so you can still see your underlying dict</span>
<span class="go">&quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 1}&quot;</span>
</pre></div>
</div>
<p>And yes, you can still add elements,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;z&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">26</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26)]</span>
</pre></div>
</div>
<p>do bulk updates,</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;more&#39;</span><span class="p">:</span> <span class="s1">&#39;of this&#39;</span><span class="p">},</span> <span class="n">more_of</span><span class="o">=</span><span class="s1">&#39;that&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more&#39;, &#39;of this&#39;), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>and delete…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;more&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>But careful! Know what you’re doing if you try to get creative. Have a look at this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># add an &#39;a&#39; item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">and_more</span><span class="o">=</span><span class="s1">&#39;of that&#39;</span><span class="p">)</span>  <span class="c1"># update to add yet another item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;z&#39;, 26), (&#39;more_of&#39;, &#39;that&#39;)]</span>
</pre></div>
</div>
<p>Indeed: No ‘a’ or ‘and_more’.</p>
<p>Now… they were indeed added. Or to be more precise, the value of the already existing a was changed,
and a new (‘and_more’, ‘of that’) item was indeed added in the underlying store:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&quot;{&#39;c&#39;: 3, &#39;b&#39;: 2, &#39;a&#39;: 100, &#39;z&#39;: 26, &#39;more_of&#39;: &#39;that&#39;, &#39;and_more&#39;: &#39;of that&#39;}&quot;</span>
</pre></div>
</div>
<p>But you’re not seeing it.</p>
<p>Why?</p>
<p>Because you chose to use a callable keys_cache that doesn’t have an ‘update’ method.
When your _keys_cache attribute (the iterable cache) is not updatable itself, the
way updates work is that we iterate through the underlying store (where the updates actually took place),
and apply the keys_cache (callable) to that iterable.</p>
<p>So what happened here was that you have your new ‘a’ and ‘and_more’ items, but your cached version of the
store doesn’t see it because it’s filtered out. On the other hand, check out what happens if you have
an updateable cache.</p>
<p>Using <cite>set</cite> instead of <cite>list</cite>, after the <cite>filter</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cache_my_keys</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="n">keys_cache</span><span class="o">=</span><span class="nb">set</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cache_my_keys</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>  <span class="c1"># used as to transform an instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># using sorted because a set&#39;s order is not always the same</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">and_more</span><span class="o">=</span><span class="s1">&#39;of that&#39;</span><span class="p">)</span>  <span class="c1"># update to add yet another item</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 100), (&#39;and_more&#39;, &#39;of that&#39;), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>This example was to illustrate a more subtle aspect of cached_keys. You would probably deal with
the filter concern in a different way in this case. But the rope is there – it’s your choice on how
to use it.</p>
<p>And here’s some more examples if that wasn’t enough!</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Lets cache the keys of a dict.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cached_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">cached_dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And you get a store that behaves as expected (but more speed and RAM)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># whether you iterate with .keys(), .values(), or .items()</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)]</span>
</pre></div>
</div>
<p>This is where the keys are stored:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">_keys_cache</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be in the order they were defined</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;bbb&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted according to their length</span>
<span class="go">[&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
</pre></div>
</div>
<p>If you change the keys (adding new ones with __setitem__ or update, or removing with pop or popitem)
then the cache is recomputed (the first time you use an operation that iterates over keys)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># let&#39;s add an element (try d[&#39;d&#39;] = 4 as well)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># whether you iterate with .keys(), .values(), or .items()</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@cached_keys</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">yield from</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Note, could have also used this form: AA = cached_keys(A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">_keys_cache</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>  <span class="c1"># changing the cache, to prove that subsequent listing will read from there</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># proof:</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Let&#39;s demo the iter_to_container argument. The default is &quot;list&quot;, which will just consume the iter in order</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be in the order they were defined</span>
<span class="go">[&#39;b&#39;, &#39;a&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="nb">sorted</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted</span>
<span class="go">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_dict</span> <span class="o">=</span> <span class="n">cached_keys</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">keys_cache</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">sorted_dict</span><span class="p">({</span><span class="s1">&#39;bbb&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;aa&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># keys will be sorted according to their length</span>
<span class="go">[&#39;c&#39;, &#39;aa&#39;, &#39;bbb&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.catch_and_cache_error_keys">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">catch_and_cache_error_keys</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">errors_caught=&lt;class 'Exception'&gt;</em>, <em class="sig-param">error_callback=None</em>, <em class="sig-param">use_cached_keys_after_completed_iter=True</em>, <em class="sig-param">__module__=None</em>, <em class="sig-param">__name__=None</em>, <em class="sig-param">__qualname__=None</em>, <em class="sig-param">__doc__=None</em>, <em class="sig-param">__annotations__=None</em>, <em class="sig-param">__defaults__=None</em>, <em class="sig-param">__kwdefaults__=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#catch_and_cache_error_keys"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.catch_and_cache_error_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Store that will cache keys as they’re accessed, separating those that raised errors and those that didn’t.
Getting a key will still through an error, but the access attempts will be collected in an ._error_keys attribute.
Successfful attemps will be stored in _keys_cache.
Retrieval iteration (items() or values()) will on the other hand, skip the error (while still caching it).
If the iteration completes (and use_cached_keys_after_completed_iter), the use_cached_keys flag is turned on,
which will result in the store now getting it’s keys from the _keys_cache.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@catch_and_cache_error_keys</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">error_callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">store</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">err</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error with </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> key: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">Blacklist</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">_black_list</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">}</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_black_list</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="gp">... </span>        <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nope, that&#39;s from the black list!&quot;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Blacklist</span><span class="p">(</span><span class="n">black</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>  <span class="n">friday</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">frenzy</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="go">[(&#39;friday&#39;, 20), (&#39;frenzy&#39;, 13)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># sorting to get consistent output</span>
<span class="go">[&#39;frenzy&#39;, &#39;friday&#39;]</span>
</pre></div>
</div>
<p>See that? First we had three keys, then we iterated and got only 2 items (fortunately,
we specified an <code class="docutils literal notranslate"><span class="pre">error_callback</span></code> so we ccould see that the iteration actually dropped a key).
That’s strange. And even stranger is the fact that when we list our keys again, we get only two.</p>
<p>You don’t like it? Neither do I. But
- It’s not a completely outrageous behavior – if you’re talking to live data, it</p>
<blockquote>
<div><p>often happens that you get more, or less, from one second to another.</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>This store isn’t meant to be long living, but rather meant to solve the problem of skiping</dt><dd><p>items that are problematic (for example, malformatted files), with a trace of
what was skipped and what’s valid (in case we need to iterate again and don’t want to
bear the hit of requesting values for keys we already know are problematic.</p>
</dd>
</dl>
</li>
</ul>
<p>Here’s a little peep of what is happening under the hood.
Meet <code class="docutils literal notranslate"><span class="pre">_keys_cache</span></code> and <code class="docutils literal notranslate"><span class="pre">_error_keys</span></code> sets (yes, unordered – so know it) that are meant
to acccumulate valid and problematic keys respectively.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Blacklist</span><span class="p">(</span><span class="n">black</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>  <span class="n">friday</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">frenzy</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">_error_keys</span>
<span class="go">(set(), set())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;friday&#39;</span><span class="p">]</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">_error_keys</span>
<span class="go">({&#39;friday&#39;}, set())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;black&#39;</span><span class="p">]</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">&quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_keys_cache</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">_error_keys</span>
<span class="go">({&#39;friday&#39;}, {&#39;black&#39;})</span>
</pre></div>
</div>
<p>But see that we still have the full list:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;black&#39;, &#39;friday&#39;, &#39;frenzy&#39;]</span>
</pre></div>
</div>
<p>Meet <code class="docutils literal notranslate"><span class="pre">use_cached_keys</span></code>: He’s the culprit. It’s a flag that indicates whether we should be
using the cached keys or not. Obviously, it’ll start off being <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">use_cached_keys</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Now we could set it to <code class="docutils literal notranslate"><span class="pre">True</span></code> manually to change the mode.
But know that this switch happens automatically (UNLESS you specify otherwise by saying:
<code class="docutils literal notranslate"><span class="pre">use_cached_keys_after_completed_iter=False</span></code>) when ever you got through a
VALUE-PRODUCING iteration (i.e. entirely consuming <cite>items()</cite> or <cite>values()</cite>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># sorting to get consistent output</span>
<span class="go">Error with black key: &quot;Nope, that&#39;s from the black list!&quot;</span>
<span class="go">[13, 20]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.constant_output">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">constant_output</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">return_val</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#constant_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.constant_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that returns a constant value no matter what the inputs are.
Is meant to be used with functools.partial to create custom versions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">always_true</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">constant_output</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">always_true</span><span class="p">(</span><span class="s1">&#39;regardless&#39;</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="n">the</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="n">will</span><span class="o">=</span><span class="s1">&#39;return True&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.double_up_as_factory">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">double_up_as_factory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">decorator_func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#double_up_as_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.double_up_as_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Repurpose a decorator both as it’s original form, and as a decorator factory.
That is, from a decorator that is defined do <code class="docutils literal notranslate"><span class="pre">wrapped_func</span> <span class="pre">=</span> <span class="pre">decorator(func,</span> <span class="pre">**params)</span></code>,
make it also be able to do <code class="docutils literal notranslate"><span class="pre">wrapped_func</span> <span class="pre">=</span> <span class="pre">decorator(**params)(func)</span></code>.</p>
<p>Note: You’ll only be able to do this if all but the first argument are keyword-only,
and the first argument (the function to decorate) has a default of <code class="docutils literal notranslate"><span class="pre">None</span></code> (this is for your own good).
This is validated before making the “double up as factory” decorator.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@double_up_as_factory</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiplier</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">_func</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wrapped_foo</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wrapped_foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">30</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multiply_by_3</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="n">multiplier</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wrapped_foo</span> <span class="o">=</span> <span class="n">multiply_by_3</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wrapped_foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">9</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@decorator</span><span class="p">(</span><span class="n">multiplier</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">9</span>
</pre></div>
</div>
<p>Note that to be able to use double_up_as_factory, your first argument (the object to be wrapped) needs to default
to None and be the only argument that is not keyword-only (i.e. all other arguments need to be keyword only).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@double_up_as_factory</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">decorator_2</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">First argument of the decorator function needs to default to None. Was &lt;class &#39;inspect._empty&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@double_up_as_factory</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">decorator_3</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="sd">&#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="gt">Traceback (most recent call last):</span>
  <span class="c">...</span>
<span class="gr">AssertionError</span>: <span class="n">All arguments (besides the first) need to be keyword-only</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.ensure_clear_method">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">ensure_clear_method</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">clear_method=&lt;function _delete_keys_one_by_one&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#ensure_clear_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.ensure_clear_method" title="Permalink to this definition">¶</a></dt>
<dd><p>If obj doesn’t have an enabled clear method, will add one (a slow one that runs through keys and deletes them</p>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.filt_iter">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">filt_iter</code><span class="sig-paren">(</span><em class="sig-param">store=None</em>, <em class="sig-param">*</em>, <em class="sig-param">filt: Union[callable</em>, <em class="sig-param">collections.abc.Iterable] = &lt;function take_everything&gt;</em>, <em class="sig-param">name=None</em>, <em class="sig-param">__module__=None</em>, <em class="sig-param">__name__=None</em>, <em class="sig-param">__qualname__=None</em>, <em class="sig-param">__doc__=None</em>, <em class="sig-param">__annotations__=None</em>, <em class="sig-param">__defaults__=None</em>, <em class="sig-param">__kwdefaults__=None</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#filt_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.filt_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wrapper that will transform a store (class or instance thereof) into a sub-store (i.e. subset of keys).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filt</strong> – A callable or iterable:
callable: Boolean filter function. A func taking a key and and returns True iff the key should be included.
iterable: The collection of keys you want to filter “in”</p></li>
<li><p><strong>name</strong> – The name to give the wrapped class</p></li>
</ul>
</dd>
</dl>
<p>Returns: A wrapper (that then needs to be applied to a store instance or class.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_dict</span> <span class="o">=</span> <span class="n">filt_iter</span><span class="p">(</span><span class="n">filt</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1"># keep only odd length keys</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">filtered_dict</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;ccc&#39;</span><span class="p">:</span> <span class="s1">&#39;a string&#39;</span><span class="p">,</span> <span class="s1">&#39;dddd&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">[&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">s</span>  <span class="c1"># True because odd (length) key</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;bb&#39;</span> <span class="ow">in</span> <span class="n">s</span>  <span class="c1"># False because odd (length) key</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="go">[&#39;a&#39;, &#39;ccc&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
<span class="go">[1, &#39;a string&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bb&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;ccc&#39;, &#39;a string&#39;), (&#39;x&#39;, 10)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">s</span><span class="p">[</span><span class="s1">&#39;xx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;not an odd key&#39;</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This should have failed&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.filtered_iter">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">filtered_iter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filt</span><span class="p">:</span> <span class="n">Union<span class="p">[</span>callable<span class="p">, </span>collections.abc.Iterable<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#filtered_iter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.filtered_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a wrapper that will transform a store (class or instance thereof) into a sub-store (i.e. subset of keys).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filt</strong> – A callable or iterable:
callable: Boolean filter function. A func taking a key and and returns True iff the key should be included.
iterable: The collection of keys you want to filter “in”</p></li>
<li><p><strong>name</strong> – The name to give the wrapped class</p></li>
</ul>
</dd>
</dl>
<p>Returns: A wrapper (that then needs to be applied to a store instance or class.</p>
<p># Commented out doctests since filtered_iter is deprecated
#
# &gt;&gt;&gt; filtered_dict = filtered_iter(filt=lambda k: (len(k) % 2) == 1)(dict)  # keep only odd length keys
# &gt;&gt;&gt;
# &gt;&gt;&gt; s = filtered_dict({‘a’: 1, ‘bb’: object, ‘ccc’: ‘a string’, ‘dddd’: [1, 2]})
# &gt;&gt;&gt;
# &gt;&gt;&gt; list(s)
# [‘a’, ‘ccc’]
# &gt;&gt;&gt; ‘a’ in s  # True because odd (length) key
# True
# &gt;&gt;&gt; ‘bb’ in s  # False because odd (length) key
# False
# &gt;&gt;&gt; assert s.get(‘bb’, None) == None
# &gt;&gt;&gt; len(s)
# 2
# &gt;&gt;&gt; list(s.keys())
# [‘a’, ‘ccc’]
# &gt;&gt;&gt; list(s.values())
# [1, ‘a string’]
# &gt;&gt;&gt; list(s.items())
# [(‘a’, 1), (‘ccc’, ‘a string’)]
# &gt;&gt;&gt; s.get(‘a’)
# 1
# &gt;&gt;&gt; assert s.get(‘bb’) is None
# &gt;&gt;&gt; s[‘x’] = 10
# &gt;&gt;&gt; list(s.items())
# [(‘a’, 1), (‘ccc’, ‘a string’), (‘x’, 10)]
# &gt;&gt;&gt; try:
# …     s[‘xx’] = ‘not an odd key’
# …     raise ValueError(“This should have failed”)
# … except KeyError:
# …     pass</p>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.flatten">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">flatten</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">levels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cache_keys</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__qualname__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__doc__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__annotations__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__defaults__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__kwdefaults__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#flatten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Flatten a nested store.</p>
<p>Say you have a store that has three levels (or more), that is, that you can always
ask for the value <code class="docutils literal notranslate"><span class="pre">store[a][b][c]</span></code> if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a valid key of <code class="docutils literal notranslate"><span class="pre">store</span></code>,
<code class="docutils literal notranslate"><span class="pre">b</span></code> is a valid key of <code class="docutils literal notranslate"><span class="pre">store[a]</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a valid key of <code class="docutils literal notranslate"><span class="pre">store[a][b]</span></code>.</p>
<p>What <code class="docutils literal notranslate"><span class="pre">flattened_store</span> <span class="pre">=</span> <span class="pre">flatten(store,</span> <span class="pre">levels=3)</span></code> will give you is the ability
to access the <code class="docutils literal notranslate"><span class="pre">store[a][b][c]</span></code> as <code class="docutils literal notranslate"><span class="pre">store[a,</span> <span class="pre">b,</span> <span class="pre">c]</span></code>, while still being able
to access these stores “normally”.</p>
<p>If that’s all you need, you can just use the <code class="docutils literal notranslate"><span class="pre">add_get_path</span></code> wrapper for this.</p>
<p>Why would you use <code class="docutils literal notranslate"><span class="pre">flatten</span></code>? Because <code class="docutils literal notranslate"><span class="pre">add_get_path(store)</span></code> would still only
give you the <code class="docutils literal notranslate"><span class="pre">KvReader</span></code> point of view of the root <code class="docutils literal notranslate"><span class="pre">store</span></code>.
If you <code class="docutils literal notranslate"><span class="pre">list(store)</span></code>, you’d only get the first level keys,
or if you ask if <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code> is in the store, it will tell you it’s not
(though you can access data with such a key.</p>
<p>Instead, a flattened store will consider that the keys are those <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>
key paths.</p>
<p>Further, when flattening a store, you can ask for the view to cache the keys,
specifying <code class="docutils literal notranslate"><span class="pre">cache_keys=True</span></code> or give it an explicit place to cache or
factory to make a cache (see <code class="docutils literal notranslate"><span class="pre">cached_keys</span></code> wrapper for more details).
Though caching keys is not the default it’s highly recommended to do so in most
cases. The only reason it is not the default is because if you have millions of
keys, but little memory, that’s not what you might want.</p>
<p>Note: Flattening just provides a wrapper giving you a “flattened view”. It doesn’t
change the store itself, or it’s contents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store instance or class to be wrapped</p></li>
<li><p><strong>levels</strong> – The number of nested levels to flatten</p></li>
<li><p><strong>cache_keys</strong> – Whether to cache the keys, or a cache factory or instance.</p></li>
</ul>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dol</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}},</span>
<span class="gp">... </span>    <span class="s1">&#39;aa&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;bb&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;cc&#39;</span><span class="p">:</span> <span class="s1">&#39;dragon_con&#39;</span><span class="p">}}</span>
<span class="gp">... </span><span class="p">}</span>
</pre></div>
</div>
<p>You can get a flattened view of an instance:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">cache_keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>        <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="gp">... </span>        <span class="o">==</span> <span class="p">[</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">),</span> <span class="mi">42</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;aa&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">,</span> <span class="s1">&#39;cc&#39;</span><span class="p">),</span> <span class="s1">&#39;dragon_con&#39;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>You can make a flattener and apply it to an instance (or a class):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_flattener</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">my_flattener</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>        <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="gp">... </span>        <span class="o">==</span> <span class="p">[</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}),</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;aa&#39;</span><span class="p">,</span> <span class="s1">&#39;bb&#39;</span><span class="p">),</span> <span class="p">{</span><span class="s1">&#39;cc&#39;</span><span class="p">:</span> <span class="s1">&#39;dragon_con&#39;</span><span class="p">})</span>
<span class="gp">... </span>        <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, you can wrap a class itself.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@flatten</span><span class="p">(</span><span class="n">levels</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">MyFlatDict</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MyFlatDict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>        <span class="nb">list</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="gp">... </span>        <span class="o">==</span> <span class="p">[</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;a&#39;</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mi">42</span><span class="p">}}),</span>
<span class="gp">... </span>            <span class="p">((</span><span class="s1">&#39;aa&#39;</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;bb&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;cc&#39;</span><span class="p">:</span> <span class="s1">&#39;dragon_con&#39;</span><span class="p">}})</span>
<span class="gp">... </span>        <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.insert_aliases">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">insert_aliases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">write</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">read</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delete</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__qualname__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__doc__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__annotations__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__defaults__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__kwdefaults__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#insert_aliases"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.insert_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert method aliases of CRUD operations of a store (class or instance).
If store is a class, you’ll get a copy of the class with those methods added.
If store is an instance, the methods will be added in place (no copy will be made).</p>
<p>Note: If an operation (write, read, delete, list, count) is not specified, no alias will be created for
that operation.</p>
<p>IMPORTANT NOTE: The signatures of the methods the aliases will point to will not change.
We say this because, you can call the write method “dump”, but you’ll have to use it as
<cite>store.dump(key, val)</cite>, not <cite>store.dump(val, key)</cite>, which is the signature you’re probably used to
(it’s the one used by json.dump or pickle.dump for example). If you want that familiar interface,
using the insert_load_dump_aliases function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store to extend with aliases.</p></li>
<li><p><strong>write</strong> – Desired method name for __setitem__</p></li>
<li><p><strong>read</strong> – Desired method name for __getitem__</p></li>
<li><p><strong>delete</strong> – Desired method name for __delitem__</p></li>
<li><p><strong>list</strong> – Desired method name for __iter__</p></li>
<li><p><strong>count</strong> – Desired method name for __len__</p></li>
</ul>
</dd>
</dl>
<p>Returns: A store with the desired aliases.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of extending a class</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mydict</span> <span class="o">=</span> <span class="n">insert_aliases</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="s1">&#39;dump&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="s1">&#39;rm&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="o">=</span><span class="s1">&#39;peek&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="s1">&#39;size&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">(</span><span class="n">true</span><span class="o">=</span><span class="s1">&#39;love&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;friends&#39;</span><span class="p">,</span> <span class="s1">&#39;forever&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">{&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="go">&#39;love&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">peek</span><span class="p">())</span>
<span class="go">[&#39;true&#39;, &#39;friends&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">rm</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">{&#39;friends&#39;: &#39;forever&#39;}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Example of extending an instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">true</span><span class="o">=</span><span class="s1">&#39;love&#39;</span><span class="p">)</span>  <span class="c1"># make (and instance) of a UserDict (can&#39;t modify a dict instance)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># make aliases of note that you don&#39;t need</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">insert_aliases</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">write</span><span class="o">=</span><span class="s1">&#39;put&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="s1">&#39;retrieve&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="s1">&#39;num_of_items&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s1">&#39;friends&#39;</span><span class="p">,</span> <span class="s1">&#39;forever&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">{&#39;true&#39;: &#39;love&#39;, &#39;friends&#39;: &#39;forever&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="go">&#39;love&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">num_of_items</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.insert_load_dump_aliases">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">insert_load_dump_aliases</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">delete</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__qualname__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__doc__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__annotations__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__defaults__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__kwdefaults__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#insert_load_dump_aliases"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.insert_load_dump_aliases" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert load and dump methods, with familiar dump(obj, location) signature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – The store to extend with aliases.</p></li>
<li><p><strong>delete</strong> – Desired method name for __delitem__</p></li>
<li><p><strong>list</strong> – Desired method name for __iter__</p></li>
<li><p><strong>count</strong> – Desired method name for __len__</p></li>
</ul>
</dd>
</dl>
<p>Returns: A store with the desired aliases.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mydict</span> <span class="o">=</span> <span class="n">insert_load_dump_aliases</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="s1">&#39;love&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">{&#39;true&#39;: &#39;love&#39;}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.kv_wrap">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">kv_wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trans_obj</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#kv_wrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.kv_wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>kv_wrap: A function that makes a wrapper (a decorator) that will get the wrappers from methods of the input object.</p>
<dl class="simple">
<dt>kv_wrap also has attributes:</dt><dd><p>outcoming_keys, ingoing_keys, outcoming_vals, ingoing_vals, and val_reads_wrt_to_keys</p>
</dd>
</dl>
<p>which will only add a single specific wrapper (specified as a function), when that’s what you need.</p>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.kv_wrap_persister_cls">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">kv_wrap_persister_cls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">persister_cls</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#kv_wrap_persister_cls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.kv_wrap_persister_cls" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a class that wraps a persister into a dol.base.Store,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>persister_cls</strong> – The persister class to wrap</p>
</dd>
</dl>
<p>Returns: A Store wrapping the persister (see dol.base)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;one&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;two&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;three&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_obj_of_data&#39;</span><span class="p">)</span>  <span class="c1"># for example, it has this magic method</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># If you overwrite the _obj_of_data method, you&#39;ll transform outcomming values with it.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For example, say the data you stored were minutes, but you want to get then in secs...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">_obj_of_data</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="n">data</span> <span class="o">*</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And if you want to have class that has this weird &quot;store minutes, retrieve seconds&quot;, you can do this:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">(</span><span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="nb">dict</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_obj_of_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">data</span> <span class="o">*</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>  <span class="c1"># you can write several key-value pairs at once this way!</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Warning! Advanced under-the-hood chat coming up.... Note this:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># What?!? Well, remember, printing an object calls the objects __str__, which usually calls __repr__</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># The wrapper doesn&#39;t wrap those methods, since they don&#39;t have consistent behaviors.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Here you&#39;re getting the __repr__ of the underlying dict store, without the key and value transforms.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Say you wanted to transform the incoming minute-unit data, converting to secs BEFORE they were stored...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="nb">dict</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_data_of_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">obj</span> <span class="o">*</span> <span class="mi">60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">C</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># yet another way you can write multiple key-vals at once</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>  <span class="c1"># but notice that unlike when we printed b, here the stored data is actually transformed!</span>
<span class="go">{&#39;one&#39;: 60, &#39;two&#39;: 120, &#39;three&#39;: 180}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now, just to demonstrate key transformation, let&#39;s say that we need internal (stored) keys to be upper case,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but external (the keys you see when listed) ones to be lower case, for some reason...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">D</span><span class="p">(</span><span class="n">kv_wrap_persister_cls</span><span class="p">(</span><span class="nb">dict</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">_data_of_obj</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">:</span> <span class="n">obj</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>  <span class="c1"># to demonstrated another way of doing this</span>
<span class="gp">... </span>    <span class="n">_key_of_id</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">:</span> <span class="n">_id</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>  <span class="c1"># note if you don&#39;t specify staticmethod, 1st arg must be self</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>  <span class="c1"># a function definition like you&#39;re used to</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;oNe&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">TwO</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tHrEE</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># you see clean lower cased keys at the interface of the store</span>
<span class="go">[(&#39;one&#39;, 60), (&#39;two&#39;, 120), (&#39;three&#39;, 180)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># but internally, the keys are all upper case</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># equivalent to print(d.store), so keys and values not wrapped (values were transformed before stored)</span>
<span class="go">{&#39;ONE&#39;: 60, &#39;TWO&#39;: 120, &#39;THREE&#39;: 180}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># On the other hand, careful, if you gave the data directly to D, you wouldn&#39;t get that.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">D</span><span class="p">({</span><span class="s1">&#39;one&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Thus is because when you construct a D with the dict, it initializes the dicts data with it directly</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># before the key/val transformers are in place to do their jobs.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.mk_kv_reader_from_kv_collection">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">mk_kv_reader_from_kv_collection</code><span class="sig-paren">(</span><em class="sig-param">kv_collection</em>, <em class="sig-param">name=None</em>, <em class="sig-param">getitem=&lt;function transparent_key_method&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#mk_kv_reader_from_kv_collection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.mk_kv_reader_from_kv_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a KvReader class from a Collection class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kv_collection</strong> – The Collection class</p></li>
<li><p><strong>name</strong> – The name to give the KvReader class (by default, it will be kv_collection.__qualname__ + ‘Reader’)</p></li>
<li><p><strong>getitem</strong> – The method that will be assigned to __getitem__. Should have the (self, k) signature.
By default, getitem will be transparent_key_method, returning the key as is.
This default is useful when you want to delegate the actual getting to a _obj_of_data wrapper.</p></li>
</ul>
</dd>
</dl>
<p>Returns: A KvReader class that subclasses the input kv_collection</p>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.mk_trans_obj">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">mk_trans_obj</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#mk_trans_obj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.mk_trans_obj" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to quickly make a trans_obj (just an object holding some trans functions</p>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.mk_wrapper">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">mk_wrapper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wrap_cls</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#mk_wrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.mk_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>You have a wrapper class and you want to make a wrapper out of it,
that is, a decorator factory with which you can make wrappers, like this:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">wrapper</span> <span class="pre">=</span> <span class="pre">mk_wrapper(wrap_cls)</span>
<span class="pre">`</span></code>
that you can then use to transform stores like thiis:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">MyStore</span> <span class="pre">=</span> <span class="pre">wrapper(**wrapper_kwargs)(StoreYouWantToTransform)</span>
<span class="pre">`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wrap_cls</strong> – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">RelPath</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="o">.</span><span class="n">_root_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_key_of_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_id</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">_id</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_root_length</span><span class="p">:]</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">_id_of_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">+</span> <span class="n">k</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relpath_wrap</span> <span class="o">=</span> <span class="n">mk_wrapper</span><span class="p">(</span><span class="n">RelPath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RelDict</span> <span class="o">=</span> <span class="n">relpath_wrap</span><span class="p">(</span><span class="n">root</span><span class="o">=</span><span class="s1">&#39;foo/&#39;</span><span class="p">)(</span><span class="nb">dict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">RelDict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;{&#39;foo/bar&#39;: 42}&quot;</span>  <span class="c1"># reveals that actually, behind the scenes, there&#39;s a &quot;foo/&quot; prefix</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.store_decorator">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">store_decorator</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#store_decorator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.store_decorator" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to make store decorators.</p>
<p>You provide a class-decorating function <code class="docutils literal notranslate"><span class="pre">func</span></code> that takes a store type (and possibly additional params)
and returns another decorated store type.</p>
<p><code class="docutils literal notranslate"><span class="pre">store_decorator</span></code> takes that <code class="docutils literal notranslate"><span class="pre">func</span></code> and provides an enhanced class decorator specialized for stores.
Namely it will:
- Add <code class="docutils literal notranslate"><span class="pre">__module__</span></code>, <code class="docutils literal notranslate"><span class="pre">__qualname__</span></code>, <code class="docutils literal notranslate"><span class="pre">__name__</span></code> and <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> arguments to it
- Copy the aforementioned arguments to the decorated class, or copy the attributes of the original if not specified.
- Output a decorator that can be used in four different ways: a class/instance decorator/factory.</p>
<p>By class/instance decorator/factory we mean that if <code class="docutils literal notranslate"><span class="pre">A</span></code> is a class, <code class="docutils literal notranslate"><span class="pre">a</span></code> an instance of it,
and <code class="docutils literal notranslate"><span class="pre">deco</span></code> a decorator obtained with <code class="docutils literal notranslate"><span class="pre">store_decorator(func)</span></code>,
we can use <code class="docutils literal notranslate"><span class="pre">deco</span></code> to
- class decorator: decorate a class
- class decorator factory: make a function that decorates classes
- instance decorator: decorate an instance of a store
- instancce decorator factor: make a function that decorates instances of stores</p>
<p>For example, say we have the following <code class="docutils literal notranslate"><span class="pre">deco</span></code> that we made with <code class="docutils literal notranslate"><span class="pre">store_decorator</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@store_decorator</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">deco</span><span class="p">(</span><span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># do stuff to cls, or a copy of it...</span>
<span class="gp">... </span>    <span class="bp">cls</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># like this for example</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="bp">cls</span>
</pre></div>
</div>
<p>And a class that has nothing to it:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span> <span class="o">...</span>
</pre></div>
</div>
<p>Nammely, it doesn’t have an <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>We make a <code class="docutils literal notranslate"><span class="pre">decorated_A</span></code> with <code class="docutils literal notranslate"><span class="pre">deco</span></code> (class decorator example)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>
</div>
<p>and we see that we now have an <code class="docutils literal notranslate"><span class="pre">x</span></code> and it’s 42</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="o">.</span><span class="n">x</span>
<span class="go">42</span>
</pre></div>
</div>
<p>But we could have also made a factory to decorate <code class="docutils literal notranslate"><span class="pre">A</span></code> and anything else that comes our way.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">paint_it_42</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">decorated_A</span> <span class="o">=</span> <span class="n">paint_it_42</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decorated_A</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;destined to disappear&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">paint_it_42</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>To be fair though, you’ll probably see the factory usage appear in the following form,
where the class is decorated at definition time.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@deco</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">B</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>If your exists already, and you want to keep it as is (with the same name), you can
use subclassing to transform a copy of <code class="docutils literal notranslate"><span class="pre">A</span></code> instead, as below.
Also note in the following example, that <code class="docutils literal notranslate"><span class="pre">deco</span></code> was used without parentheses,
which is equivalent to <code class="docutils literal notranslate"><span class="pre">&#64;deco()</span></code>,
and yes, store_decorator makes that possible to, as long as your params have defaults</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@deco</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">decorated_A</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">decorated_A</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>
</pre></div>
</div>
<p>Finally, you can also decorate instances:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># b has an x and it&#39;s 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">deco</span><span class="p">()(</span><span class="n">a</span><span class="p">);</span> <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="c1"># b has an x and it&#39;s 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">);</span> <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span>  <span class="c1"># b has an x and it&#39;s 42</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">deco</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">42</span><span class="p">)(</span><span class="n">a</span><span class="p">);</span> <span class="k">assert</span> <span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="mi">42</span><span class="p">;</span> <span class="c1"># b has an x and it&#39;s 42</span>
</pre></div>
</div>
<p>WARNING: Note though that the type of <code class="docutils literal notranslate"><span class="pre">b</span></code> is not the same type as <code class="docutils literal notranslate"><span class="pre">a</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>No, <code class="docutils literal notranslate"><span class="pre">b</span></code> is an instance of a <code class="docutils literal notranslate"><span class="pre">dol.base.Store</span></code>, which is a class containing an
instance of a store (here, <code class="docutils literal notranslate"><span class="pre">a</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&lt;class &#39;dol.base.Store&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">store</span> <span class="o">==</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Now, here’s some more example, slightly closer to real usage</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">dol.trans</span> <span class="kn">import</span> <span class="n">store_decorator</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">rm_deletion</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;Deletions not allowed.&#39;</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;Something&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_w_sommething&#39;</span>
<span class="gp">... </span>    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Should be a type, was </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">store</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">store</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="gp">... </span>    <span class="n">wrapped_store</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">store</span><span class="p">,),</span> <span class="p">{})</span>
<span class="gp">... </span>    <span class="n">wrapped_store</span><span class="o">.</span><span class="fm">__delitem__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">msg</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">wrapped_store</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">remove_deletion</span> <span class="o">=</span> <span class="n">store_decorator</span><span class="p">(</span><span class="n">rm_deletion</span><span class="p">)</span>
</pre></div>
</div>
<p>See how the signature of the wrapper has some extra inputs that were injected (__module__, __qualname__, etc.):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">remove_deletion</span><span class="p">)))</span>
<span class="go">(store=None, *, msg=&#39;Deletions not allowed.&#39;, __module__=None, __name__=None, __qualname__=None, __doc__=None, __annotations__=None, __defaults__=None, __kwdefaults__=None)</span>
</pre></div>
</div>
<p>Using it as a class decorator factory (the most common way):</p>
<p>As a class decorator “factory”, without parameters (and without ()):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserDict</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@remove_deletion</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">WD</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;Here&#39;s the doc&quot;</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">WD</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Deletions not allowed.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">==</span> <span class="s2">&quot;Here&#39;s the doc&quot;</span>
</pre></div>
</div>
<p>As a class decorator “factory”, with parameters:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@remove_deletion</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s1">&#39;No way. I do not trust you!!&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">WD</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">WD</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;No way. I do not trust you!!&#39;</span>
</pre></div>
</div>
<p>The __doc__ is empty:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">WD</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">==</span> <span class="kc">None</span>
</pre></div>
</div>
<p>But we could specify a doc if we wanted to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@remove_deletion</span><span class="p">(</span><span class="vm">__doc__</span><span class="o">=</span><span class="s2">&quot;Hi, I&#39;m a doc.&quot;</span><span class="p">)</span>
<span class="gp">... </span><span class="k">class</span> <span class="nc">WD</span><span class="p">(</span><span class="n">UserDict</span><span class="p">):</span>
<span class="gp">... </span>    <span class="s2">&quot;This is the original doc, that will be overritten&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">WD</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">==</span> <span class="s2">&quot;Hi, I&#39;m a doc.&quot;</span>
</pre></div>
</div>
<p>The class decorations above are equivalent to the two following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">WD</span> <span class="o">=</span> <span class="n">remove_deletion</span><span class="p">(</span><span class="n">UserDict</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">WD</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Deletions not allowed.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">WD</span> <span class="o">=</span> <span class="n">remove_deletion</span><span class="p">(</span><span class="n">UserDict</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;No way. I do not trust you!!&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">WD</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;No way. I do not trust you!!&#39;</span>
</pre></div>
</div>
<p>But we can also decorate instances. In this case they will be wrapped in a Store class
before being passed on to the actual decorator.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">remove_deletion</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">d</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;Deletions not allowed.&#39;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">UserDict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wd</span> <span class="o">=</span> <span class="n">remove_deletion</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s1">&#39;No way. I do not trust you!!&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span> <span class="o">==</span> <span class="n">d</span>  <span class="c1"># same as far as dict comparison goes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">wd</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;No way. I do not trust you!!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dol.trans.wrap_kvs">
<code class="sig-prename descclassname">dol.trans.</code><code class="sig-name descname">wrap_kvs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">store</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">key_of_id</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">id_of_key</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">obj_of_data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">data_of_obj</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">preset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">postget</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__module__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outcoming_key_methods</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">outcoming_value_methods</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">ingoing_key_methods</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">ingoing_value_methods</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__qualname__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__doc__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__annotations__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__defaults__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">__kwdefaults__</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/dol/trans.html#wrap_kvs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dol.trans.wrap_kvs" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a Store that is wrapped with the given key/val transformers.</p>
<dl class="simple">
<dt>Naming convention:</dt><dd><dl class="simple">
<dt>Morphemes:</dt><dd><p>key: outer key
_id: inner key
obj: outer value
data: inner value</p>
</dd>
<dt>Grammar:</dt><dd><p>Y_of_X: means that you get a Y output when giving an X input. Also known as X_to_Y.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>store</strong> – Store class or instance</p></li>
<li><p><strong>name</strong> – Name to give the wrapper class</p></li>
<li><p><strong>key_of_id</strong> – The outcoming key transformation function.
Forms are <cite>k = key_of_id(_id)</cite> or <cite>k = key_of_id(self, _id)</cite></p></li>
<li><p><strong>id_of_key</strong> – The ingoing key transformation function.
Forms are <cite>_id = id_of_key(k)</cite> or <cite>_id = id_of_key(self, k)</cite></p></li>
<li><p><strong>obj_of_data</strong> – The outcoming val transformation function.
Forms are <cite>obj = obj_of_data(data)</cite> or <cite>obj = obj_of_data(self, data)</cite></p></li>
<li><p><strong>data_of_obj</strong> – The ingoing val transformation function.
Forms are <cite>data = data_of_obj(obj)</cite> or <cite>data = data_of_obj(self, obj)</cite></p></li>
<li><p><strong>preset</strong> – <p>A function that is called before doing a <cite>__setitem__</cite>.
The function is called with both <cite>k</cite> and <cite>v</cite> as inputs, and should output a transformed value.
The intent use is to do ingoing value transformations conditioned on the key.
For example, you may want to serialize an object depending on if you’re writing to a</p>
<blockquote>
<div><p>’.csv’, or ‘.json’, or ‘.pickle’ file.</p>
</div></blockquote>
<p>Forms are <cite>preset(k, obj)</cite> or <cite>preset(self, k, obj)</cite></p>
</p></li>
<li><p><strong>postget</strong> – A function that is called after the value <cite>v</cite> for a key <cite>k</cite> is be <cite>__getitem__</cite>.
The function is called with both <cite>k</cite> and <cite>v</cite> as inputs, and should output a transformed value.
The intent use is to do outcoming value transformations conditioned on the key.
We already have <cite>obj_of_data</cite> for outcoming value trans, but cannot condition it’s behavior on k.
For example, you may want to deserialize the bytes of a ‘.csv’, or ‘.json’, or ‘.pickle’ in different ways.
Forms are <cite>obj = postget(k, data)</cite> or <cite>obj = postget(self, k, data)</cite></p></li>
</ul>
</dd>
</dl>
<p>Returns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">key_of_id</span><span class="p">(</span><span class="n">_id</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">_id</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">id_of_key</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">obj_of_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">data</span> <span class="o">-</span> <span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">data_of_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">obj</span> <span class="o">+</span> <span class="mi">100</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">key_of_id</span><span class="o">=</span><span class="n">key_of_id</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">id_of_key</span><span class="p">,</span> <span class="n">obj_of_data</span><span class="o">=</span><span class="n">obj_of_data</span><span class="p">,</span> <span class="n">data_of_obj</span><span class="o">=</span><span class="n">data_of_obj</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;KEY&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="c1"># repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="go">{&#39;key&#39;: 101}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="go">{&#39;key&#39;: 102}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="s1">&#39;kEy&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>  <span class="c1"># repr is just the base class (dict) repr, so shows &quot;inside&quot; the store (lower case keys and +100)</span>
<span class="go">{&#39;key&#39;: 103}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># but from the point of view of the interface the keys are all upper case</span>
<span class="go">[&#39;KEY&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>  <span class="c1"># and the values are those we put there.</span>
<span class="go">[(&#39;KEY&#39;, 3)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># And now this: Showing how to condition the value transform (like obj_of_data), but conditioned on key.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">postget</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;upper </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;lower </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">B</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;BIG&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;letters&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="s1">&#39;small&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;text&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;BIG&#39;, &#39;upper letters&#39;), (&#39;small&#39;, &#39;lower text&#39;)]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Let&#39;s try preset and postget. We&#39;ll wrap a dict and write the same list of lists object to</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># keys ending with .csv, .json, and .pkl, specifying the obvious extension-dependent</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># serialization/deserialization we want to associate with it.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># First, some very simple csv transformation functions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">to_csv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">LoL</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">L</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">L</span><span class="p">),</span> <span class="n">LoL</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">from_csv</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">csv</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">),</span> <span class="n">csv</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">n&#39;</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">LoL</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">from_csv</span><span class="p">(</span><span class="n">to_csv</span><span class="p">(</span><span class="n">LoL</span><span class="p">))</span> <span class="o">==</span> <span class="n">LoL</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">json</span><span class="o">,</span> <span class="nn">pickle</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">preset</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">to_csv</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pkl&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">v</span>  <span class="c1"># as is</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">postget</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.csv&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">from_csv</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.json&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">elif</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.pkl&#39;</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">v</span>  <span class="c1"># as is</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mydict</span> <span class="o">=</span> <span class="n">wrap_kvs</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">preset</span><span class="o">=</span><span class="n">preset</span><span class="p">,</span> <span class="n">postget</span><span class="o">=</span><span class="n">postget</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;c&#39;</span><span class="p">],[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span><span class="s1">&#39;e&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">mydict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo.csv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>  <span class="c1"># store the object as csv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>  <span class="c1"># &quot;printing&quot; a dict by-passes the transformations, so we see the data in the &quot;raw&quot; format it is stored in.</span>
<span class="go">{&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo.csv&#39;</span><span class="p">]</span>  <span class="c1"># but if we actually ask for the data, it deserializes to our original object</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;bar.json&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>  <span class="c1"># store the object as json</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;[[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], [&quot;d&quot;, &quot;e&quot;, &quot;f&quot;]]&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;bar.json&#39;</span><span class="p">]</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;bar.json&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;normal json&#39;</span><span class="p">}</span>  <span class="c1"># let&#39;s write a normal json instead.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">{&#39;foo.csv&#39;: &#39;a,b,c\\nd,e,f&#39;, &#39;bar.json&#39;: &#39;{&quot;a&quot;: 1, &quot;b&quot;: [1, 2], &quot;c&quot;: &quot;normal json&quot;}&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo.csv&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;bar.json&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo.pkl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>  <span class="c1"># &#39;save&#39; obj as pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;foo.pkl&#39;</span><span class="p">]</span>
<span class="go">[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;]]</span>
</pre></div>
</div>
<p># TODO: Add tests for outcoming_key_methods etc.</p>
</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">dol</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="core.html">dol.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">dol.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tests/scrap.html" title="previous chapter">dol.tests.scrap</a></li>
      <li>Next: <a href="util.html" title="next chapter">dol.util</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/module_docs/dol/trans.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>