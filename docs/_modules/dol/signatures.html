<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.signatures &mdash; dol 0.1.105 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/core.html">dol.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
          <li><a href="../dol.html">dol</a> &raquo;</li>
      <li>dol.signatures</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.signatures</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Signature calculus: Tools to make it easier to work with function&#39;s signatures.</span>

<span class="sd">How to:</span>

<span class="sd">    - get names, kinds, defaults, annotations</span>

<span class="sd">    - make signatures flexibly</span>

<span class="sd">    - merge two or more signatures</span>

<span class="sd">    -</span>
<span class="sd">    - give a function a specific signature (with a choice of validations)</span>

<span class="sd">    - get an equivalent function with a different order of arguments</span>

<span class="sd">    - get an equivalent function with a subset of arguments (like partial)</span>

<span class="sd">    - get an equivalent function but with variadic *args and/or **kwargs replaced with</span>
<span class="sd">    non-variadic args (tuple) and kwargs (dict)</span>

<span class="sd">    - make an f(a) function in to a f(a, b=None) function with b ignored</span>


<span class="sd">Get names, kinds, defaults, annotations:</span>

<span class="sd">&gt;&gt;&gt; def func(z, a: float=1.0, /, b=2, *, c: int=3):</span>
<span class="sd">...     pass</span>
<span class="sd">&gt;&gt;&gt; sig = Sig(func)</span>
<span class="sd">&gt;&gt;&gt; sig.names</span>
<span class="sd">[&#39;z&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">&gt;&gt;&gt; from inspect import Parameter</span>
<span class="sd">&gt;&gt;&gt; assert sig.kinds == {</span>
<span class="sd">...     &#39;z&#39;: Parameter.POSITIONAL_ONLY,</span>
<span class="sd">...     &#39;a&#39;: Parameter.POSITIONAL_ONLY,</span>
<span class="sd">...     &#39;b&#39;: Parameter.POSITIONAL_OR_KEYWORD,</span>
<span class="sd">...     &#39;c&#39;: Parameter.KEYWORD_ONLY</span>
<span class="sd">... }</span>
<span class="sd">&gt;&gt;&gt; # Note z is not in there (only defaulted params are included)</span>
<span class="sd">&gt;&gt;&gt; sig.defaults</span>
<span class="sd">{&#39;a&#39;: 1.0, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
<span class="sd">&gt;&gt;&gt; sig.annotations</span>
<span class="sd">{&#39;a&#39;: &lt;class &#39;float&#39;&gt;, &#39;c&#39;: &lt;class &#39;int&#39;&gt;}</span>

<span class="sd">Make signatures flexibly:</span>

<span class="sd">&gt;&gt;&gt; Sig(func)</span>
<span class="sd">&lt;Sig (z, a: float = 1.0, /, b=2, *, c: int = 3)&gt;</span>
<span class="sd">&gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">&lt;Sig (a, b)&gt;</span>
<span class="sd">&gt;&gt;&gt; Sig(&#39;x y z&#39;)</span>
<span class="sd">&lt;Sig (x, y, z)&gt;</span>

<span class="sd">Merge signatures.</span>

<span class="sd">&gt;&gt;&gt; def foo(x): pass</span>
<span class="sd">&gt;&gt;&gt; def bar(y: int, *, z=2): pass  # note the * (keyword only) will be lost!</span>
<span class="sd">&gt;&gt;&gt; Sig(foo) + [&#39;a&#39;, &#39;b&#39;] + Sig(bar)</span>
<span class="sd">&lt;Sig (x, a, b, y: int, z=2)&gt;</span>

<span class="sd">Give a function a signature.</span>

<span class="sd">&gt;&gt;&gt; @Sig(&#39;a b c&#39;)</span>
<span class="sd">... def func(*args, **kwargs):</span>
<span class="sd">...     print(args, kwargs)</span>
<span class="sd">&gt;&gt;&gt; Sig(func)</span>
<span class="sd">&lt;Sig (a, b, c)&gt;</span>


<span class="sd">**Notes to the reader**</span>

<span class="sd">Both in the code and in the docs, we&#39;ll use short hands for parameter (argument) kind.</span>

<span class="sd">    - PK = Parameter.POSITIONAL_OR_KEYWORD</span>

<span class="sd">    - VP = Parameter.VAR_POSITIONAL</span>

<span class="sd">    - VK = Parameter.VAR_KEYWORD</span>

<span class="sd">    - PO = Parameter.POSITIONAL_ONLY</span>

<span class="sd">    - KO = Parameter.KEYWORD_ONLY</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">unwrap</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span> <span class="k">as</span> <span class="n">MappingType</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">cached_property</span><span class="p">,</span>
    <span class="n">update_wrapper</span><span class="p">,</span>
    <span class="n">partial</span><span class="p">,</span>
    <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span>
    <span class="n">wraps</span> <span class="k">as</span> <span class="n">_wraps</span><span class="p">,</span>
    <span class="n">update_wrapper</span> <span class="k">as</span> <span class="n">_update_wrapper</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># monkey patching WRAPPER_ASSIGNMENTS to get &quot;proper&quot; wrapping (adding defaults and</span>
<span class="c1"># kwdefaults</span>

<span class="n">wrapper_assignments</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span> <span class="s1">&#39;__defaults__&#39;</span><span class="p">,</span> <span class="s1">&#39;__kwdefaults__&#39;</span><span class="p">)</span>

<span class="n">update_wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_update_wrapper</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>
<span class="n">wraps</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wraps</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>

<span class="n">_empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

<span class="n">_ParameterKind</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;param_kind&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">ParamsType</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
<span class="n">ParamsAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParamsType</span><span class="p">,</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">SignatureAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Signature</span><span class="p">,</span> <span class="n">ParamsAble</span><span class="p">]</span>
<span class="n">HasParams</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>

<span class="c1"># short hands for Parameter kinds</span>
<span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">VP</span><span class="p">,</span> <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
<span class="n">PO</span><span class="p">,</span> <span class="n">KO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">var_param_kinds</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">VP</span><span class="p">,</span> <span class="n">VK</span><span class="p">})</span>
<span class="n">var_param_types</span> <span class="o">=</span> <span class="n">var_param_kinds</span>  <span class="c1"># Deprecate: for back-compatibility. Delete in 2021</span>

<span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span> <span class="o">=</span> <span class="s1">&#39;strict&#39;</span>
<span class="n">param_attributes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">}</span>


<div class="viewcode-block" id="FuncCallNotMatchingSignature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.FuncCallNotMatchingSignature">[docs]</a><span class="k">class</span> <span class="nc">FuncCallNotMatchingSignature</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when the call signature is not valid&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="IncompatibleSignatures"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.IncompatibleSignatures">[docs]</a><span class="k">class</span> <span class="nc">IncompatibleSignatures</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raise when two signatures are not compatible.</span>
<span class="sd">    (see https://github.com/i2mint/i2/issues/16 for more information on signature</span>
<span class="sd">    compatibility)&quot;&quot;&quot;</span></div>


<span class="c1"># TODO: Couldn&#39;t make this work. See https://www.python.org/dev/peps/pep-0562/</span>
<span class="c1"># deprecated_names = {&#39;assure_callable&#39;, &#39;assure_signature&#39;, &#39;assure_params&#39;}</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def __getattr__(name):</span>
<span class="c1">#     print(name)</span>
<span class="c1">#     if name in deprecated_names:</span>
<span class="c1">#         from warnings import warn</span>
<span class="c1">#         warn(f&quot;{name} is deprecated (see code for new name -- look for aliases)&quot;,</span>
<span class="c1">#         DeprecationWarning)</span>
<span class="c1">#     raise AttributeError(f&quot;module {__name__} has no attribute {name}&quot;)</span>


<span class="k">def</span> <span class="nf">_param_sort_key</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">)</span>


<div class="viewcode-block" id="sort_params"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.sort_params">[docs]</a><span class="k">def</span> <span class="nf">sort_params</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param params: An iterable of `Parameter` instances</span>
<span class="sd">    :return: A list of these instances sorted so as to obey the ``kind`` and ``default``</span>
<span class="sd">        order rules of python signatures.</span>

<span class="sd">    Note 1: It doesn&#39;t mean that these params constitute a valid signature together,</span>
<span class="sd">    since it doesn&#39;t verify rules like unicity of names and variadic kinds.</span>

<span class="sd">    Note 2: Though you can use ``sorted`` on an iterable of ``i2.signatures.Param``</span>
<span class="sd">    instances, know that even for sorting the three parameters below,</span>
<span class="sd">    the ``sort_params`` function is more than twice as fast.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import Parameter</span>
<span class="sd">    &gt;&gt;&gt; sort_params(</span>
<span class="sd">    ...     [Parameter(&#39;a&#39;, kind=Parameter.POSITIONAL_OR_KEYWORD, default=1),</span>
<span class="sd">    ...     Parameter(&#39;b&#39;, kind=Parameter.POSITIONAL_ONLY),</span>
<span class="sd">    ...     Parameter(&#39;c&#39;, kind=Parameter.POSITIONAL_OR_KEYWORD)]</span>
<span class="sd">    ... )</span>
<span class="sd">    [&lt;Parameter &quot;b&quot;&gt;, &lt;Parameter &quot;c&quot;&gt;, &lt;Parameter &quot;a=1&quot;&gt;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">_param_sort_key</span><span class="p">)</span></div>


<div class="viewcode-block" id="name_of_obj"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.name_of_obj">[docs]</a><span class="k">def</span> <span class="nf">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries to find the (or &quot;a&quot;) name for an object, even if `__name__` doesn&#39;t exist.</span>

<span class="sd">    &gt;&gt;&gt; name_of_obj(map)</span>
<span class="sd">    &#39;map&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj([1, 2, 3])</span>
<span class="sd">    &#39;list&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(print)</span>
<span class="sd">    &#39;print&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(lambda x: x)</span>
<span class="sd">    &#39;&lt;lambda&gt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(partial(print, sep=&quot;,&quot;))</span>
<span class="sd">    &#39;print&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;partial&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">ensure_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Empty function made just to carry a signature&quot;&quot;&quot;</span>

        <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="n">assure_callable</span> <span class="o">=</span> <span class="n">ensure_callable</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Signature</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">(</span><span class="n">obj</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">())</span>
    <span class="c1"># if you get this far...</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">assure_signature</span> <span class="o">=</span> <span class="n">ensure_signature</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">dflt_and_annotation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="o">**</span><span class="n">dflt_and_annotation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> into a Parameter object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_params_from_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">MappingType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;In a mapping specification of a params, &#39;</span>
                        <span class="sa">f</span><span class="s2">&quot;either the &#39;name&#39; of the val shouldn&#39;t be specified, &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;or it should be the same as the key (</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">): &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">yield</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">yield</span> <span class="n">v</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="ensure_params"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.ensure_params">[docs]</a><span class="k">def</span> <span class="nf">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get an interable of Parameter instances from an object.</span>

<span class="sd">    :param obj:</span>
<span class="sd">    :return:</span>

<span class="sd">    From a callable:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; ensure_params(f)</span>
<span class="sd">    [&lt;Parameter &quot;w&quot;&gt;, &lt;Parameter &quot;x: float = 1&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z: int = 1&quot;&gt;]</span>

<span class="sd">    From an iterable of strings, dicts, or tuples</span>

<span class="sd">    &gt;&gt;&gt; ensure_params(</span>
<span class="sd">    ...     [</span>
<span class="sd">    ...         &quot;xyz&quot;,</span>
<span class="sd">    ...         (</span>
<span class="sd">    ...             &quot;b&quot;,</span>
<span class="sd">    ...             Parameter.empty,</span>
<span class="sd">    ...             int,</span>
<span class="sd">    ...         ),  # if you want an annotation without a default use Parameter.empty</span>
<span class="sd">    ...         (</span>
<span class="sd">    ...             &quot;c&quot;,</span>
<span class="sd">    ...             2,</span>
<span class="sd">    ...         ),  # if you just want a default, make it the second element of your tup</span>
<span class="sd">    ...         dict(name=&quot;d&quot;, kind=Parameter.VAR_KEYWORD),</span>
<span class="sd">    ...     ]</span>
<span class="sd">    ... )  # all kinds are by default PK: Use dict to specify otherwise.</span>
<span class="sd">    [&lt;Param &quot;xyz&quot;&gt;, &lt;Param &quot;b: int&quot;&gt;, &lt;Param &quot;c=2&quot;&gt;, &lt;Param &quot;**d&quot;&gt;]</span>


<span class="sd">    If no input is given, an empty list is returned.</span>

<span class="sd">    &gt;&gt;&gt; ensure_params()  # equivalent to ensure_params(None)</span>
<span class="sd">    []</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># obj = inspect.unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))</span>

    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">try</span><span class="p">:</span>  <span class="c1"># to get params from the builtin signature function</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
            <span class="c1"># TODO: Can do better here! See attempt in _params_from_mapping:</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">_params_from_mapping</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="c1"># obj = list(obj.values())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: put this in function that has more kind resolution power</span>
                <span class="c1">#  e.g. if a KEYWORD_ONLY arg was encountered, all subsequent</span>
                <span class="c1">#  have to be unless otherwise specified.</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">([</span><span class="n">obj</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># if nothing above worked, perhaps you have a wrapped object? Try unwrapping until</span>
        <span class="c1"># you find a signature...</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__signature__&#39;</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if function didn&#39;t return at this point, it didn&#39;t find a match, so raise</span>
            <span class="c1"># a TypeError</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into an iterable of inspect.Parameter &quot;</span>
                <span class="sa">f</span><span class="s1">&#39;objects: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span></div>


<span class="n">assure_params</span> <span class="o">=</span> <span class="n">ensure_params</span>  <span class="c1"># alias for backcompatibility</span>


<div class="viewcode-block" id="MissingArgValFor"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.MissingArgValFor">[docs]</a><span class="k">class</span> <span class="nc">MissingArgValFor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A simple class to wrap an argument name, indicating that it was missing somewhere.</span>

<span class="sd">    &gt;&gt;&gt; MissingArgValFor(&quot;argname&quot;)</span>
<span class="sd">    MissingArgValFor(&quot;argname&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argname</span> <span class="o">=</span> <span class="n">argname</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;MissingArgValFor(&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">argname</span><span class="si">}</span><span class="s1">&quot;)&#39;</span></div>


<span class="c1"># TODO: Look into the handling of the Parameter.VAR_KEYWORD kind in params</span>
<div class="viewcode-block" id="extract_arguments"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.extract_arguments">[docs]</a><span class="k">def</span> <span class="nf">extract_arguments</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;return&#39;</span><span class="p">,</span>
    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract arguments needed to satisfy the params of a callable, dealing with the</span>
<span class="sd">    dirty details.</span>

<span class="sd">    Returns an (param_args, param_kwargs, remaining_kwargs) tuple where</span>
<span class="sd">    - param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by</span>
<span class="sd">    params,</span>
<span class="sd">    - param_kwargs are those names that are both in params and not in param_args, and</span>
<span class="sd">    - remaining_kwargs are the remaining.</span>

<span class="sd">    Intended usage: When you need to call a function `func` that has some</span>
<span class="sd">    position-only arguments,</span>
<span class="sd">    but you have a kwargs dict of arguments in your hand. You can&#39;t just to `func(</span>
<span class="sd">    **kwargs)`.</span>
<span class="sd">    But you can (now) do</span>
<span class="sd">    ```</span>
<span class="sd">    args, kwargs, remaining = extract_arguments(kwargs, func)  # extract from kwargs</span>
<span class="sd">    what you need for func</span>
<span class="sd">    # ... check if remaing is empty (or not, depending on your paranoia), and then</span>
<span class="sd">    call the func:</span>
<span class="sd">    func(*args, **kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    (And if you doing that a lot: Do put it in a decorator!)</span>

<span class="sd">    See Also: extract_arguments.without_remainding</span>

<span class="sd">    The most frequent case you&#39;ll encounter is when there&#39;s no POSITION_ONLY args,</span>
<span class="sd">    your param_args will be empty</span>
<span class="sd">    and you param_kwargs will contain all the arguments that match params,</span>
<span class="sd">    in the order of these params.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, d=0):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&quot;stuff&quot;)</span>
<span class="sd">    ((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    But sometimes you do have POSITION_ONLY arguments.</span>
<span class="sd">    What extract_arguments will do for you is return the value of these as the first</span>
<span class="sd">    element of</span>
<span class="sd">    the triple.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&quot;stuff&quot;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    Note above how we get `(1, 2, 3)`, the order defined by the func&#39;s signature,</span>
<span class="sd">    instead of `(2, 1, 3)`, the order defined by the kwargs.</span>
<span class="sd">    So it&#39;s the params (e.g. function signature) that determine the order, not kwargs.</span>
<span class="sd">    When using to call a function, this is especially crucial if we use POSITION_ONLY</span>
<span class="sd">    arguments.</span>

<span class="sd">    See also that the third output, the remaining_kwargs, as `{&#39;extra&#39;: &#39;stuff&#39;}` since</span>
<span class="sd">    it was not in the params of the function.</span>
<span class="sd">    Even if you include a VAR_KEYWORD kind of argument in the function, it won&#39;t change</span>
<span class="sd">    this behavior.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&quot;stuff&quot;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    This is because we don&#39;t want to assume that all the kwargs can actually be</span>
<span class="sd">    included in a call to the function behind the params.</span>
<span class="sd">    Instead, the user can chose whether to include the remainder by doing a:</span>
<span class="sd">    ```</span>
<span class="sd">    param_kwargs.update(remaining_kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    et voil.</span>

<span class="sd">    That said, we do understand that it may be a common pattern, so we&#39;ll do that</span>
<span class="sd">    extra step for you</span>
<span class="sd">    if you specify `include_all_when_var_keywords_in_params=True`.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(</span>
<span class="sd">    ...     f,</span>
<span class="sd">    ...     b=2,</span>
<span class="sd">    ...     a=1,</span>
<span class="sd">    ...     c=3,</span>
<span class="sd">    ...     d=4,</span>
<span class="sd">    ...     extra=&quot;stuff&quot;,</span>
<span class="sd">    ...     include_all_when_var_keywords_in_params=True,</span>
<span class="sd">    ... )</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>

<span class="sd">    If you&#39;re expecting no remainder you might want to just get the args and kwargs (</span>
<span class="sd">    not this third</span>
<span class="sd">    expected-to-be-empty remainder). You have two ways to do that, specifying:</span>
<span class="sd">        `what_to_do_with_remainding=&#39;ignore&#39;`, which will just return the (args,</span>
<span class="sd">        kwargs) pair</span>
<span class="sd">        `what_to_do_with_remainding=&#39;assert_empty&#39;`, which will do the same, but first</span>
<span class="sd">        assert the remainder is empty</span>
<span class="sd">    We suggest to use `functools.partial` to configure the `argument_argument` you need.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor = partial(</span>
<span class="sd">    ...     extract_arguments,</span>
<span class="sd">    ...     what_to_do_with_remainding=&quot;assert_empty&quot;,</span>
<span class="sd">    ...     include_all_when_var_keywords_in_params=True,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor(f, b=2, a=1, c=3, d=4, extra=&quot;stuff&quot;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    And what happens if the kwargs doesn&#39;t contain all the POSITION_ONLY arguments?</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, d=&quot;is a kw arg&quot;, e=&quot;is not an arg at all&quot;)</span>
<span class="sd">    ((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>


<span class="sd">    A few more examples...</span>

<span class="sd">    Let&#39;s call `extract_arguments` with params being not a function,</span>
<span class="sd">    but, a Signature instance, a mapping whose values are Parameter instances,</span>
<span class="sd">    or an iterable of Parameter instances...</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b, /, c=None, *, d=0, **kws):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; sig = Signature.from_callable(func)</span>
<span class="sd">    &gt;&gt;&gt; param_map = sig.parameters</span>
<span class="sd">    &gt;&gt;&gt; param_iterable = param_map.values()</span>
<span class="sd">    &gt;&gt;&gt; kwargs = dict(b=2, a=1, c=3, d=4, extra=&quot;stuff&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(sig, **kwargs) == extract_arguments(func, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_map, **kwargs) == extract_arguments(</span>
<span class="sd">    ...     func, **kwargs</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_iterable, **kwargs) == extract_arguments(</span>
<span class="sd">    ...     func, **kwargs</span>
<span class="sd">    ... )</span>

<span class="sd">    Edge case:</span>
<span class="sd">    No params specified? No problem. You&#39;ll just get empty args and kwargs. Everything</span>
<span class="sd">    in the remainder</span>

<span class="sd">    &gt;&gt;&gt; extract_arguments(params=(), b=2, a=1, c=3, d=0)</span>
<span class="sd">    ((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>

<span class="sd">    :param params: Specifies what PO arguments should be extracted.</span>
<span class="sd">        Could be a callable, Signature, iterable of Parameters...</span>
<span class="sd">    :param what_to_do_with_remainding:</span>
<span class="sd">        &#39;return&#39; (default): function will return `param_args`, `param_kwargs`,</span>
<span class="sd">        `remaining_kwargs`</span>
<span class="sd">        &#39;ignore&#39;: function will return `param_args`, `param_kwargs`</span>
<span class="sd">        &#39;assert_empty&#39;: function will assert that `remaining_kwargs` is empty and then</span>
<span class="sd">        return `param_args`, `param_kwargs`</span>
<span class="sd">    :param include_all_when_var_keywords_in_params=False,</span>
<span class="sd">    :param assert_no_missing_position_only_args=False,</span>
<span class="sd">    :param kwargs: The kwargs to extract the args from</span>
<span class="sd">    :return: A (param_args, param_kwargs, remaining_kwargs) tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">what_to_do_with_remainding</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">}</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_all_when_var_keywords_in_params</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assert_no_missing_position_only_args</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(),</span> <span class="p">{},</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">params_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">names_for_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">]</span>
    <span class="n">param_kwargs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">params_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">names_for_args</span><span class="p">)]</span>
    <span class="n">remaining_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_names</span><span class="p">]</span>

    <span class="n">param_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names_for_args</span><span class="p">)</span>
    <span class="n">param_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">param_kwargs_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
    <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">remaining_names</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">include_all_when_var_keywords_in_params</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">next</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span> <span class="kc">None</span><span class="p">,)</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">param_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span>
            <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">assert_no_missing_position_only_args</span><span class="p">:</span>
        <span class="n">missing_argnames</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">argname</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">missing_argnames</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;There were some missing positional only argnames: </span><span class="si">{</span><span class="n">missing_argnames</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;return&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span><span class="p">,</span> <span class="n">remaining_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;remaining_kwargs not empty: remaining_kwargs=</span><span class="si">{</span><span class="n">remaining_kwargs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span></div>


<span class="n">extract_arguments_ignoring_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">extract_arguments</span><span class="p">,</span> <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span>
<span class="p">)</span>
<span class="n">extract_arguments_asserting_no_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">extract_arguments</span><span class="p">,</span> <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;assert_empty&#39;</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span>


<span class="k">def</span> <span class="nf">function_caller</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="Param"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Param">[docs]</a><span class="k">class</span> <span class="nc">Param</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A thin wrap of Parameters: Adds shorter aliases to argument kinds and</span>
<span class="sd">    a POSITIONAL_OR_KEYWORD default to the argument kind to make it faster to make</span>
<span class="sd">    Parameter objects</span>

<span class="sd">    &gt;&gt;&gt; list(map(Param, &#39;some quick arg params&#39;.split()))</span>
<span class="sd">    [&lt;Param &quot;some&quot;&gt;, &lt;Param &quot;quick&quot;&gt;, &lt;Param &quot;arg&quot;&gt;, &lt;Param &quot;params&quot;&gt;]</span>
<span class="sd">    &gt;&gt;&gt; from inspect import Signature</span>
<span class="sd">    &gt;&gt;&gt; P = Param</span>
<span class="sd">    &gt;&gt;&gt; Signature([P(&#39;x&#39;, P.PO), P(&#39;y&#39;, default=42, annotation=int), P(&#39;kw&#39;, P.KO)])</span>
<span class="sd">    &lt;Signature (x, /, y: int = 42, *, kw)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># aliases</span>
    <span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
    <span class="n">PO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
    <span class="n">KO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="n">VP</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
    <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Whether the self parameter can be before the other parameter in a signature.</span>

<span class="sd">        &gt;&gt;&gt; Param(&#39;b&#39;) &lt; Param(&#39;a&#39;, default=1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Param(&#39;b&#39;) &gt; Param(&#39;a&#39;, default=1)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Param(&#39;b&#39;, kind=Param.POSITIONAL_OR_KEYWORD) &lt; Param(&#39;a&#39;, kind=Param.KEYWORD_ONLY)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Param(&#39;b&#39;, kind=Param.POSITIONAL_OR_KEYWORD) &gt; Param(&#39;a&#39;, kind=Param.KEYWORD_ONLY)</span>
<span class="sd">        False</span>

<span class="sd">        Note 1: The dual ``&gt;`` operator is also infered.</span>

<span class="sd">        Note 2: This means that you can used ``sorted`` on an iterable of Param</span>
<span class="sd">        instances, but know that even for sorting the three parameters below,</span>
<span class="sd">        the ``sort_params`` function in the ``i2.signatures`` module is more than twice</span>
<span class="sd">        as fast.</span>

<span class="sd">        &gt;&gt;&gt; sorted(</span>
<span class="sd">        ...     [Param(&#39;a&#39;, default=1),</span>
<span class="sd">        ...     Param(&#39;b&#39;, kind=Param.POSITIONAL_ONLY),</span>
<span class="sd">        ...     Param(&#39;c&#39;)]</span>
<span class="sd">        ... )</span>
<span class="sd">        [&lt;Param &quot;b&quot;&gt;, &lt;Param &quot;c&quot;&gt;, &lt;Param &quot;a=1&quot;&gt;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">other</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="n">P</span> <span class="o">=</span> <span class="n">Param</span>  <span class="c1"># useful shorthand alias</span>


<span class="k">def</span> <span class="nf">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>


<span class="k">def</span> <span class="nf">parameter_to_dict</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>


<span class="n">WRAPPER_UPDATES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__dict__&#39;</span><span class="p">,)</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="c1"># A default signature of (*no_sig_args, **no_sig_kwargs)</span>
<span class="n">DFLT_SIGNATURE</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">no_sig_args</span><span class="p">,</span> <span class="o">**</span><span class="n">no_sig_kwargs</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>

<span class="c1"># TODO: Might want to monkey-patch inspect._signature_from_callable to use sigs_for_sigless_builtin_name</span>
<span class="k">def</span> <span class="nf">_robust_signature_of_callable</span><span class="p">(</span><span class="n">callable_obj</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Signature</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the signature of a Callable, returning a custom made one for those</span>
<span class="sd">    builtins that don&#39;t have one</span>

<span class="sd">    &gt;&gt;&gt; _robust_signature_of_callable(</span>
<span class="sd">    ...     _robust_signature_of_callable</span>
<span class="sd">    ... )  # has a normal signature</span>
<span class="sd">    &lt;Signature (callable_obj: Callable) -&gt; inspect.Signature&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = _robust_signature_of_callable(print)  # has one that this module provides</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(s, Signature)</span>
<span class="sd">    &gt;&gt;&gt; # Will be: &lt;Signature (*value, sep=&#39; &#39;, end=&#39;\n&#39;, file=&lt;_io.TextIOWrapper</span>
<span class="sd">    name=&#39;&lt;stdout&gt;&#39; mode=&#39;w&#39; encoding=&#39;utf-8&#39;&gt;, flush=False)&gt;</span>
<span class="sd">    &gt;&gt;&gt; _robust_signature_of_callable(</span>
<span class="sd">    ...     zip</span>
<span class="sd">    ... )  # doesn&#39;t have one, so will return a blanket one</span>
<span class="sd">    &lt;Signature (*no_sig_args, **no_sig_kwargs)&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">callable_obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="c1"># if isinstance(callable_obj, partial):</span>
        <span class="c1">#     callable_obj = callable_obj.func</span>
        <span class="n">obj_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">callable_obj</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_name</span> <span class="ow">in</span> <span class="n">sigs_for_sigless_builtin_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigs_for_sigless_builtin_name</span><span class="p">[</span><span class="n">obj_name</span><span class="p">]</span> <span class="ow">or</span> <span class="n">DFLT_SIGNATURE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>


<span class="k">def</span> <span class="nf">_names_of_kind</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a tuple containing tuples of names for each kind</span>

<span class="sd">    &gt;&gt;&gt; f = lambda a00, /, a11, a12, *a23, a34, a35, a36, **a47: None</span>
<span class="sd">    &gt;&gt;&gt; _names_of_kind(Sig(f))</span>
<span class="sd">    ((&#39;a00&#39;,), (&#39;a11&#39;, &#39;a12&#39;), (&#39;a23&#39;,), (&#39;a34&#39;, &#39;a35&#39;, &#39;a36&#39;), (&#39;a47&#39;,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">kind</span><span class="p">])</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">maybe_first</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">items</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">name_of_var_kw_argument</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
    <span class="n">var_kw_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">params</span> <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span><span class="p">]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">maybe_first</span><span class="p">(</span><span class="n">var_kw_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_map_action_on_cond</span><span class="p">(</span><span class="n">kvs</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">expand</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kvs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cond</span><span class="p">(</span>
            <span class="n">k</span>
        <span class="p">):</span>  <span class="c1"># make a conditional on (k,v), use type KV, Iterable[KV], expand:KV -&gt; Iterable[KV]</span>
            <span class="k">yield from</span> <span class="n">expand</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>  <span class="c1"># expand should result in (k,v)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">expand_nested_key</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expand_nested_key</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">flatten_if_var_kw</span><span class="p">(</span><span class="n">kvs</span><span class="p">,</span> <span class="n">var_kw_name</span><span class="p">):</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span> <span class="o">==</span> <span class="n">var_kw_name</span>
    <span class="n">expand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="c1"># expand = lambda k: k.values()</span>
    <span class="k">return</span> <span class="n">_map_action_on_cond</span><span class="p">(</span><span class="n">kvs</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">expand</span><span class="p">)</span>


<span class="c1"># TODO: See other signature operating functions below in this module:</span>
<span class="c1">#   Do we need them now that we have Sig?</span>
<span class="c1">#   Do we want to keep them and have Sig use them?</span>
<div class="viewcode-block" id="Sig"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig">[docs]</a><span class="k">class</span> <span class="nc">Sig</span><span class="p">(</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of inspect.Signature that has a lot of extra api sugar,</span>
<span class="sd">    such as</span>
<span class="sd">        - making a signature for a variety of input types (callable,</span>
<span class="sd">            iterable of callables, parameter lists, strings, etc.)</span>
<span class="sd">        - has a dict-like interface</span>
<span class="sd">        - signature merging (with operator interfaces)</span>
<span class="sd">        - quick access to signature data</span>
<span class="sd">        - positional/keyword argument mapping.</span>

<span class="sd">    # Positional/Keyword argument mapping</span>

<span class="sd">    In python, arguments can be positional (args) or keyword (kwargs).</span>
<span class="sd">    ... sometimes both, sometimes a single one is imposed.</span>
<span class="sd">    ... and you have variadic versions of both.</span>
<span class="sd">    ... and you can have defaults or not.</span>
<span class="sd">    ... and all these different kinds have a particular order they must be in.</span>
<span class="sd">    It&#39;s is mess really. The flexibility is nice -- but still; a mess.</span>

<span class="sd">    You only really feel the mess if you try to do some meta-programming with your</span>
<span class="sd">    functions.</span>
<span class="sd">    Then, methods like `normalize_kind` can help you out, since you can enforce, and</span>
<span class="sd">    then assume, some stable interface to your functions.</span>

<span class="sd">    Two of the base methods for dealing with positional (args) and keyword (kwargs)</span>
<span class="sd">    inputs are:</span>
<span class="sd">        - `kwargs_from_args_and_kwargs`: Map some args/kwargs input to a keyword-only</span>
<span class="sd">            expression of the inputs. This is useful if you need to do some processing</span>
<span class="sd">            based on the argument names.</span>
<span class="sd">        - `args_and_kwargs_from_kwargs`: Translate a fully keyword expression of some</span>
<span class="sd">            inputs into an (args, kwargs) pair that can be used to call the function.</span>
<span class="sd">            (Remember, your function can have constraints, so you may need to do this.</span>

<span class="sd">    The usual pattern of use of these methods is to use `kwargs_from_args_and_kwargs`</span>
<span class="sd">    to map all the inputs to their corresponding name, do what needs to be done with</span>
<span class="sd">    that (example, validation, transformation, decoration...) and then map back to an</span>
<span class="sd">    (args, kwargs) pair than can actually be used to call the function.</span>

<span class="sd">    Examples of methods and functions using these:</span>
<span class="sd">    `call_forgivingly`, `tuple_the_args`, `extract_kwargs`, `extract_args_and_kwargs`,</span>
<span class="sd">    `source_kwargs`, and `source_args_and_kwargs`.</span>

<span class="sd">    # Making a signature</span>

<span class="sd">    You can construct a `Sig` object from a callable,</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; Sig(f)</span>
<span class="sd">    &lt;Sig (w, /, x: float = 1, y=1, *, z: int = 1)&gt;</span>

<span class="sd">    but also from any &quot;ParamsAble&quot; object. Such as...</span>
<span class="sd">    an iterable of Parameter instances, strings, tuples, or dicts:</span>

<span class="sd">    &gt;&gt;&gt; Sig(</span>
<span class="sd">    ...     [</span>
<span class="sd">    ...         &quot;a&quot;,</span>
<span class="sd">    ...         (&quot;b&quot;, Parameter.empty, int),</span>
<span class="sd">    ...         (&quot;c&quot;, 2),</span>
<span class="sd">    ...         (&quot;d&quot;, 1.0, float),</span>
<span class="sd">    ...         dict(name=&quot;special&quot;, kind=Parameter.KEYWORD_ONLY, default=0),</span>
<span class="sd">    ...     ]</span>
<span class="sd">    ... )</span>
<span class="sd">    &lt;Sig (a, b: int, c=2, d: float = 1.0, *, special=0)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Sig(</span>
<span class="sd">    ...     [</span>
<span class="sd">    ...         &quot;a&quot;,</span>
<span class="sd">    ...         &quot;b&quot;,</span>
<span class="sd">    ...         dict(name=&quot;args&quot;, kind=Parameter.VAR_POSITIONAL),</span>
<span class="sd">    ...         dict(name=&quot;kwargs&quot;, kind=Parameter.VAR_KEYWORD),</span>
<span class="sd">    ...     ]</span>
<span class="sd">    ... )</span>
<span class="sd">    &lt;Sig (a, b, *args, **kwargs)&gt;</span>

<span class="sd">    The parameters of a signature are like a matrix whose rows are the parameters,</span>
<span class="sd">    and the 4 columns are their properties: name, kind, default, and annotation</span>
<span class="sd">    (the two laste ones being optional).</span>
<span class="sd">    You get a row view when doing `Sig(...).parameters.values()`,</span>
<span class="sd">    but what if you want a column-view?</span>
<span class="sd">    Here&#39;s how:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = Sig(f)</span>
<span class="sd">    &gt;&gt;&gt; s.kinds  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;w&#39;: &lt;_ParameterKind.POSITIONAL_ONLY: 0&gt;,</span>
<span class="sd">    &#39;x&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;y&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;z&#39;: &lt;_ParameterKind.KEYWORD_ONLY: 3&gt;}</span>

<span class="sd">    &gt;&gt;&gt; s.annotations</span>
<span class="sd">    {&#39;x&#39;: &lt;class &#39;float&#39;&gt;, &#39;z&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     s.annotations == f.__annotations__</span>
<span class="sd">    ... )  # same as what you get in `__annotations__`</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s.defaults</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # Note that it&#39;s not the same as you get in __defaults__ though:</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     s.defaults != f.__defaults__ == (1, 2)</span>
<span class="sd">    ... )  # not 3, since __kwdefaults__ has that!</span>

<span class="sd">    We can sum (i.e. merge) and subtract (i.e. remove arguments) Sig instances.</span>
<span class="sd">    Also, Sig instance is callable. It has the effect of inserting it&#39;s signature in</span>
<span class="sd">    the input</span>
<span class="sd">    (in `__signature__`, but also inserting the resulting `__defaults__` and</span>
<span class="sd">    `__kwdefaults__`).</span>
<span class="sd">    One of the intents is to be able to do things like:</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; def g(i, w, /, j=2):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @Sig.from_objs(f, g, [&quot;a&quot;, (&quot;b&quot;, 3.14), (&quot;c&quot;, 42, int)])</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Sig (w, i, /, a, x: float = 1, y=1, j=2, b=3.14, c: int = 42, *, z: int = 1)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; sig = Sig(f) + g + [&quot;a&quot;, (&quot;b&quot;, 3.14), (&quot;c&quot;, 42, int)] - &quot;b&quot; - [&quot;a&quot;, &quot;z&quot;]</span>
<span class="sd">    &gt;&gt;&gt; @sig</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Sig (w, i, x: float = 1, y=1, j=2, c: int = 42)&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Adding parameter kinds as class attributes for usage convenience</span>
    <span class="n">POSITIONAL_ONLY</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
    <span class="n">POSITIONAL_OR_KEYWORD</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
    <span class="n">VAR_POSITIONAL</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
    <span class="n">KEYWORD_ONLY</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="n">VAR_KEYWORD</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span>
        <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Sig instance.</span>
<span class="sd">        See Also: `ensure_params` to see what kind of objects you can make `Sig`s with.</span>

<span class="sd">        :param obj: A ParamsAble object, which could be:</span>
<span class="sd">            - a callable,</span>
<span class="sd">            - and iterable of Parameter instances</span>
<span class="sd">            - an iterable of strings (representing annotation-less, default-less)</span>
<span class="sd">            argument names,</span>
<span class="sd">            - tuples: (argname, default) or (argname, default, annotation),</span>
<span class="sd">            - dicts: ``{&#39;name&#39;: REQUIRED,...}`` with optional `kind`, `default` and</span>
<span class="sd">            `annotation` fields</span>
<span class="sd">            - None (which will produce an argument-less Signature)</span>

<span class="sd">        &gt;&gt;&gt; Sig([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span>
<span class="sd">        &lt;Sig (a, b, c)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(</span>
<span class="sd">        ...     [&quot;a&quot;, (&quot;b&quot;, None), (&quot;c&quot;, 42, int)]</span>
<span class="sd">        ... )  # specifying defaults and annotations</span>
<span class="sd">        &lt;Sig (a, b=None, c: int = 42)&gt;</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; Sig(</span>
<span class="sd">        ...     [&quot;a&quot;, (&quot;b&quot;, inspect._empty, int)]</span>
<span class="sd">        ... )  # specifying an annotation without a default</span>
<span class="sd">        &lt;Sig (a, b: int)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">        &lt;Sig (a, b, c) -&gt; str&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(&#39;(a: int = 0, b: str = None, c: float = 3.14) -&gt; str&#39;)</span>
<span class="sd">        &lt;Sig (a: int = 0, b: str = None, c: float = 3.14) -&gt; str&gt;</span>

<span class="sd">        But you can always specify parameters the &quot;long&quot; way</span>

<span class="sd">        &gt;&gt;&gt; Sig(</span>
<span class="sd">        ...     [inspect.Parameter(name=&quot;kws&quot;, kind=inspect.Parameter.VAR_KEYWORD)],</span>
<span class="sd">        ...     return_annotation=str,</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;Sig (**kws) -&gt; str&gt;</span>

<span class="sd">        And note that:</span>

<span class="sd">        &gt;&gt;&gt; Sig()</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(None)</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^\(.*\)&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
                <span class="c1"># This is a string representation of a signature</span>
                <span class="c1"># Dynamically create a function with the given signature then generate</span>
                <span class="c1"># the Sig object from this function.</span>
                <span class="n">exec_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                <span class="n">f_def</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;def f</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">: pass&#39;</span>
                <span class="n">exec</span><span class="p">(</span><span class="n">f_def</span><span class="p">,</span> <span class="n">exec_env</span><span class="p">)</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">exec_env</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">return_annotation</span> <span class="ow">is</span> <span class="n">empty</span>
        <span class="p">):</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="c1"># TODO: Catch errors and enhance error message with more what-to-do-about it</span>
        <span class="c1">#  message. For example,</span>
        <span class="c1">#  ValueError: wrong parameter order: positional or keyword parameter before</span>
        <span class="c1">#  positional-only parameter</span>
        <span class="c1">#  --&gt; Here we could tell the user what pair of variables violated the rule</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span>
            <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
            <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span> <span class="o">=</span> <span class="n">_names_of_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;You can&#39;t have several variadic keywords: </span><span class="si">{</span><span class="n">vps</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;You can&#39;t have several variadic keywords: </span><span class="si">{</span><span class="n">vks</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="c1"># TODO: Add params for more validation (e.g. arg number/name matching?)</span>
    <span class="c1"># TODO: Switch to ignore_incompatible_signatures=False when existing code is</span>
    <span class="c1">#   changed accordingly.</span>
<div class="viewcode-block" id="Sig.wrap"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ignore_incompatible_signatures</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>

<span class="sd">        This is similar to the `functools.wraps` function, but parametrized by a</span>
<span class="sd">        signature</span>
<span class="sd">        (not a callable). Also, where as both write to the input func&#39;s `__signature__`</span>
<span class="sd">        attribute, here we also write to</span>
<span class="sd">        - `__defaults__` and `__kwdefaults__`, extracting these from `__signature__`</span>
<span class="sd">            (functools.wraps doesn&#39;t do that at the time of writing this</span>
<span class="sd">            (see https://github.com/python/cpython/pull/21379)).</span>
<span class="sd">        - `__annotations__` (also extracted from `__signature__`)</span>
<span class="sd">        - does not write to `__module__`, `__name__`, `__qualname__`, `__doc__`</span>
<span class="sd">            (because again, we&#39;re basinig the injecton on a signature, not a function,</span>
<span class="sd">            so we have no name, doc, etc...)</span>

<span class="sd">        WARNING: The fact that you&#39;ve modified the signature of your function doesn&#39;t</span>
<span class="sd">        mean that the decorated function will work as expected (or even work at all).</span>
<span class="sd">        See below for examples.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__</span>
<span class="sd">        (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert 8 == f(0) == f(0, 1) == f(0, 1, 2) == f(0, 1, 2, 3)</span>

<span class="sd">        Now let&#39;s create a very similar function to f, but where:</span>
<span class="sd">        - w is not position-only</span>
<span class="sd">        - x annot is int instead of float, and doesn&#39;t have a default</span>
<span class="sd">        - z&#39;s default changes to 10</span>

<span class="sd">        &gt;&gt;&gt; def g(w, x: int, y=2, z: int = 10):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(g)</span>
<span class="sd">        &gt;&gt;&gt; f = s.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; inspect.signature(f)  # see that</span>
<span class="sd">        &lt;Sig (w, x: int, y=2, z: int = 10)&gt;</span>
<span class="sd">        &gt;&gt;&gt; # But (unlike with functools.wraps) here we get __defaults__ and</span>
<span class="sd">        __kwdefault__</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__  # see that x has no more default &amp; z&#39;s default is now 10</span>
<span class="sd">        (2, 10)</span>
<span class="sd">        &gt;&gt;&gt; f(</span>
<span class="sd">        ...     0, 1</span>
<span class="sd">        ... )  # see that now we get a different output because using different defaults</span>
<span class="sd">        1024</span>

<span class="sd">        Remember that you are modifying the signature, not the function itself.</span>
<span class="sd">        Signature changes in defaults will indeed change the function&#39;s behavior.</span>
<span class="sd">        But changes in name or kind will only be reflected in the signature, and</span>
<span class="sd">        misalignment with the wrapped function will lead to unexpected results.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)  # error expected!</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 1 to 3 positional arguments but 4 were given</span>

<span class="sd">        But if you try to remove the argument kind constraint by just changing the</span>
<span class="sd">        signature, you&#39;ll fail.</span>

<span class="sd">        &gt;&gt;&gt; def g(w, x: float = 1, y=2, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f = Sig(g).wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; f(0)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() missing 1 required keyword-only argument: &#39;z&#39;</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 0 to 3 positional arguments but 4 were given</span>

<span class="sd">        TODO: Give more explanations why this is.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Should we make a copy/wrap of the function so as to not override</span>
        <span class="c1">#  decorated function itself? Make sure the func remains pickalable!</span>

        <span class="c1"># Analyze self and func signature to validate sanity</span>
        <span class="n">_validate_sanity_of_signature_change</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ignore_incompatible_signatures</span><span class="p">)</span>

        <span class="c1"># Change (mutate!) func, writing a new __signature__, __annotations__,</span>
        <span class="c1"># __defaults__ and __kwdefaults__</span>
        <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_defaults_and_kwdefaults</span><span class="p">()</span>

        <span class="c1"># special case of functools.partial: need to tell .keywords about kwdefaults</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
            <span class="c1"># TODO: .args can&#39;t be modified -- write test to see if problem.</span>
            <span class="c1">#   If it is, consider returning a new partial with updated args &amp; keywords.</span>
            <span class="c1"># wrapped_func.args = wrapped_func.args + wrapped_func.__defaults__</span>
            <span class="n">func</span><span class="o">.</span><span class="n">keywords</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__kwdefaults__</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">func</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>
<span class="sd">        Just calls Sig.wrap so see docs of Sig.wrap (which contains examples and</span>
<span class="sd">        doctests).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.sig_or_default"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.sig_or_default">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sig_or_default</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">default_signature</span><span class="o">=</span><span class="n">DFLT_SIGNATURE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Sig instance, or a default signature if there was a ValueError</span>
<span class="sd">        trying to construct it.</span>

<span class="sd">        For example, `time.time` doesn&#39;t have a signature</span>

<span class="sd">        &gt;&gt;&gt; import time</span>
<span class="sd">        &gt;&gt;&gt; has_signature(time.time)</span>
<span class="sd">        False</span>

<span class="sd">        But we can tell `Sig` to give it the default one:</span>

<span class="sd">        &gt;&gt;&gt; str(Sig.sig_or_default(time.time))</span>
<span class="sd">        &#39;(*no_sig_args, **no_sig_kwargs)&#39;</span>

<span class="sd">        That&#39;s the default signature, which should work for most purposes.</span>
<span class="sd">        You can also specify what the default should be though.</span>

<span class="sd">        &gt;&gt;&gt; fake_signature = Sig(lambda *time_takes_no_arguments: ...)</span>
<span class="sd">        &gt;&gt;&gt; str(Sig.sig_or_default(time.time, fake_signature))</span>
<span class="sd">        &#39;(*time_takes_no_arguments)&#39;</span>

<span class="sd">        Careful though. If you assign a signature to a function that is not aligned</span>
<span class="sd">        with that actually functioning of the function, bad things will happen.</span>
<span class="sd">        In this case, the actual signature of time is the empty signature:</span>

<span class="sd">        &gt;&gt;&gt; str(Sig.sig_or_default(time.time, Sig(lambda: ...)))</span>
<span class="sd">        &#39;()&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># (try to) return cls(obj) if obj is callable:</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># if a ValueError is raised, return the default_signature</span>
            <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">default_signature</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.sig_or_none"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.sig_or_none">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sig_or_none</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Sig instance, or None if there was a ValueError trying to</span>
<span class="sd">        construct it.</span>
<span class="sd">        One use case is to be able to tell if an object has a signature or not.</span>

<span class="sd">        &gt;&gt;&gt; robust_has_signature = lambda obj: bool(Sig.sig_or_none(obj))</span>
<span class="sd">        &gt;&gt;&gt; robust_has_signature(robust_has_signature)  # an easy case</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; robust_has_signature(</span>
<span class="sd">        ...     Sig</span>
<span class="sd">        ... )  # another easy one: This time, a type/class (which is callable, yes)</span>
<span class="sd">        True</span>

<span class="sd">        But here&#39;s where it get&#39;s interesting. `print`, a builtin, doesn&#39;t have a</span>
<span class="sd">        signature through inspect.signature.</span>

<span class="sd">        &gt;&gt;&gt; has_signature(print)</span>
<span class="sd">        False</span>

<span class="sd">        But we do get one with robust_has_signature</span>

<span class="sd">        &gt;&gt;&gt; robust_has_signature(print)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">sig_or_default</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">default_signature</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_positional_and_keyword_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get ``{name: default, ...}`` dicts of positional and keyword defaults.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; pos_defaults, kw_defaults = Sig(foo)._positional_and_keyword_defaults()</span>
<span class="sd">        &gt;&gt;&gt; pos_defaults</span>
<span class="sd">        {&#39;y&#39;: 1}</span>
<span class="sd">        &gt;&gt;&gt; kw_defaults</span>
<span class="sd">        {&#39;z&#39;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ko_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">KO</span><span class="p">]</span>
        <span class="n">dflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ko_names</span><span class="p">},</span>
            <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ko_names</span><span class="p">},</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_dunder_defaults_and_kwdefaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the __defaults__, __kwdefaults__ (i.e. what would be the dunders baring</span>
<span class="sd">        these names in a python callable)</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; __defaults__, __kwdefaults__ = Sig(foo)._dunder_defaults_and_kwdefaults()</span>
<span class="sd">        &gt;&gt;&gt; __defaults__</span>
<span class="sd">        (1,)</span>
<span class="sd">        &gt;&gt;&gt; __kwdefaults__</span>
<span class="sd">        {&#39;z&#39;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pos_defaults</span><span class="p">,</span> <span class="n">kw_defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_positional_and_keyword_defaults</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">pos_defaults</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">),</span>  <span class="c1"># as known as __defaults__ in python callables</span>
            <span class="n">kw_defaults</span><span class="p">,</span>  <span class="c1"># as known as __kwdefaults__ in python callables</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sig.to_signature_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.to_signature_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">to_signature_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dict of keyword arguments to make this signature instance.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0) -&gt; float:</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_signature_kwargs()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        {&#39;parameters&#39;:</span>
<span class="sd">            [&lt;Parameter &quot;w&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;x: float = 2&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;y=1&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;z: int = 0&quot;&gt;],</span>
<span class="sd">        &#39;return_annotation&#39;: &lt;class &#39;float&#39;&gt;}</span>

<span class="sd">        Note that this does NOT return:</span>
<span class="sd">        ```</span>
<span class="sd">                {&#39;parameters&#39;: self.parameters,</span>
<span class="sd">                &#39;return_annotation&#39;: self.return_annotation}</span>
<span class="sd">        ```</span>
<span class="sd">        which would not actually work as keyword arguments of ``Signature``.</span>
<span class="sd">        Yeah, I know. Don&#39;t ask me, ask the authors of `Signature`!</span>

<span class="sd">        Instead, `parammeters` will be ``list(self.parameters.values())``, which does</span>
<span class="sd">        work.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s1">&#39;return_annotation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Sig.to_simple_signature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.to_simple_signature">[docs]</a>    <span class="k">def</span> <span class="nf">to_simple_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A builtin ``inspect.Signature`` instance equivalent (i.e. without the extra</span>
<span class="sd">        properties and methods)</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_simple_signature()</span>
<span class="sd">        &lt;Signature (w, /, x: float = 2, y=1, *, z: int = 0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">to_signature_kwargs</span><span class="p">())</span></div>

<div class="viewcode-block" id="Sig.is_call_compatible_with"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.is_call_compatible_with">[docs]</a>    <span class="k">def</span> <span class="nf">is_call_compatible_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_sig</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">param_comparator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the signature is compatible with ``other_sig``. Meaning that</span>
<span class="sd">        all valid ways to call the signature are valid for ``other_sig``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_call_compatible_with</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other_sig</span><span class="p">,</span> <span class="n">param_comparator</span><span class="o">=</span><span class="n">param_comparator</span>
        <span class="p">)</span></div>

    <span class="c1"># TODO: Make these dunders open/close</span>
    <span class="c1"># def __le__(self, other_sig):</span>
    <span class="c1">#     &quot;&quot;&quot;The &quot;less than or equal&quot; operator (&lt;=).</span>
    <span class="c1">#     Return True if the signature is compatible with ``other_sig``. Meaning that</span>
    <span class="c1">#     all valid ways to call the signature are valid for ``other_sig``.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return self.is_call_compatible_with(other_sig)</span>

    <span class="c1"># def __ge__(self, other_sig):</span>
    <span class="c1">#     &quot;&quot;&quot;The &quot;greater than or equal&quot; operator (&gt;=).</span>
    <span class="c1">#     Return True if ``other_sig`` is compatible with the signature. Meaning that</span>
    <span class="c1">#     all valid ways to call ``other_sig`` are valid for the signature.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     return other_sig &lt;= self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_objs</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">*</span><span class="n">objs</span><span class="p">,</span>
        <span class="n">default_conflict_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span>
        <span class="o">**</span><span class="n">name_and_dflts</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">name_and_dflts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PK</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">default</span><span class="p">}])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">first_obj</span><span class="p">,</span> <span class="o">*</span><span class="n">objs</span> <span class="o">=</span> <span class="n">objs</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ensure_params</span><span class="p">(</span><span class="n">first_obj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span>
                    <span class="n">obj</span><span class="p">,</span> <span class="n">default_conflict_method</span><span class="o">=</span><span class="n">default_conflict_method</span>
                <span class="p">)</span>
                <span class="c1"># sig = sig + obj</span>
            <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if no objs are given</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>  <span class="c1"># return an empty signature</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just list(self.parameters.values()), because that&#39;s often what we want.</span>
<span class="sd">        Why a Sig.params property when we already have a Sig.parameters property?</span>

<span class="sd">        Well, as much as is boggles my mind, it so happens that the Signature.parameters</span>
<span class="sd">        is a name-&gt;Parameter mapping, but the Signature argument `parameters`,</span>
<span class="sd">        though baring the same name,</span>
<span class="sd">        is expected to be a list of Parameter instances.</span>

<span class="sd">        So Sig.params is there to restore semantic consistence sanity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">empty</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;{arg_name: annotation, ...} dict of annotations of the signature.</span>
<span class="sd">        What `func.__annotations__` would give you.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">empty</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">detail_names_by_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PO</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PK</span><span class="p">],</span>
            <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">VP</span><span class="p">]),</span> <span class="kc">None</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">KO</span><span class="p">],</span>
            <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">VK</span><span class="p">]),</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="c1"># TODO: Return type inconsistent. When k is a string, returns Parameter,</span>
    <span class="c1">#  when an iterable of strings (or &#39;space separated argument names&#39;),</span>
    <span class="c1">#  returns a signature. Could also return a single argument signatures.</span>
    <span class="c1">#  Behavior might be confusing. Pros/Cons? See if any current users of getitem,</span>
    <span class="c1">#  and switch to single arg signature return (that&#39;s consistent, and convenience</span>
    <span class="c1">#  of sig[argname] is weak (given sig.params[argname] does it)!)</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>  <span class="c1"># to handle &#39;multiple args in a string&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">),</span> <span class="s1">&#39;key should be iterable, was: </span><span class="si">{k}</span><span class="s1">&#39;</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="c1"># TODO: Deprecate. Should use names_of_kind directly</span>
<div class="viewcode-block" id="Sig.names_for_kind"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.names_for_kind">[docs]</a>    <span class="k">def</span> <span class="nf">names_for_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the arg names tuple for a given kind.</span>
<span class="sd">        Note, if you need to do this several times, or for several kinds, use</span>
<span class="sd">        ``names_of_kind`` property (a tuple) instead: It groups all names of kinds once,</span>
<span class="sd">        and caches the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecated&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">kind</span><span class="p">]</span></div>

    <span class="c1"># TODO: Consider using names_of_kind in other methods/properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; Sig(lambda x, *, y: None).has_var_kinds</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; Sig(lambda x, *y: None).has_var_kinds</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Sig(lambda x, **y: None).has_var_kinds</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">VP</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">VK</span><span class="p">])</span>
        <span class="c1"># Old version:</span>
        <span class="c1"># return any(p.kind in var_param_kinds for p in self.values())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index_of_var_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index of the VAR_POSITIONAL param kind if any, and None if not.</span>
<span class="sd">        See also, Sig.index_of_var_keyword</span>

<span class="sd">        &gt;&gt;&gt; assert Sig(lambda x, *y, z: 0).index_of_var_positional == 1</span>
<span class="sd">        &gt;&gt;&gt; assert Sig(lambda x, /, y, **z: 0).index_of_var_positional == None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_positional_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_of_var_positional</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># else returns None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use index_of_var_positional or var_keyword_name directly when needing that</span>
<span class="sd">        information as well. This will avoid having to check the kinds list twice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index_of_var_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The index of a VAR_KEYWORD param kind if any, and None if not.</span>
<span class="sd">        See also, Sig.index_of_var_positional</span>

<span class="sd">        &gt;&gt;&gt; assert Sig(lambda **kwargs: 0).index_of_var_keyword == 0</span>
<span class="sd">        &gt;&gt;&gt; assert Sig(lambda a, **kwargs: 0).index_of_var_keyword == 1</span>
<span class="sd">        &gt;&gt;&gt; assert Sig(lambda a, *args, **kwargs: 0).index_of_var_keyword == 2</span>

<span class="sd">        And if there&#39;s none...</span>

<span class="sd">        &gt;&gt;&gt; assert Sig(lambda a, *args, b=1: 0).index_of_var_keyword is None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">last_arg_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">last_arg_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">last_arg_idx</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">last_arg_idx</span>
        <span class="c1"># else returns None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_keyword_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_of_var_keyword</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># else returns None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use index_of_var_keyword or var_keyword_name directly when needing that</span>
<span class="sd">        information as well. This will avoid having to check the kinds list twice.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">required_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A tuple of required names, preserving the original signature order.</span>

<span class="sd">        A required name is that must be given in a function call, that is, the name of a</span>
<span class="sd">        paramater that doesn&#39;t have a default, and is not a variadic.</span>

<span class="sd">        That lost one is a frequent gotcha, so oo not fall in that gotcha that easily,</span>
<span class="sd">        we provide a property that contains what we need.</span>

<span class="sd">        &gt;&gt;&gt; f = lambda a00, /, a11, a12, *a23, a34, a35=1, a36=&#39;two&#39;, **a47: None</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).required_names</span>
<span class="sd">        (&#39;a00&#39;, &#39;a11&#39;, &#39;a12&#39;, &#39;a34&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note: This is quicker than using self.names_of_kind:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">empty</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of required arguments.</span>
<span class="sd">        A required argument is one that doesn&#39;t have a default, nor is VAR_POSITIONAL</span>
<span class="sd">        (*args) or VAR_KEYWORD (**kwargs).</span>
<span class="sd">        Note: Sometimes a minimum number of arguments in VAR_POSITIONAL and</span>
<span class="sd">        VAR_KEYWORD are in fact required,</span>
<span class="sd">        but we can&#39;t see this from the signature, so we can&#39;t tell you about that! You</span>
<span class="sd">        do the math.</span>

<span class="sd">        &gt;&gt;&gt; f = lambda a00, /, a11, a12, *a23, a34, a35=1, a36=&#39;two&#39;, **a47: None</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).n_required</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">required_names</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">positional_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PO</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PK</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">keyword_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PK</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">KO</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_transform_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">changes_for_name</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">changes_for_name</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">changes_for_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">parameter_to_dict</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if name is not in params, just use existing param</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

<div class="viewcode-block" id="Sig.modified"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.modified">[docs]</a>    <span class="k">def</span> <span class="nf">modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a modified (new) signature object.</span>

<span class="sd">        Note: This function doesn&#39;t modify the signature, but creates a modified copy</span>
<span class="sd">        of the signature.</span>

<span class="sd">        IMPORTANT WARNING: This is an advanced feature. Avoid wrapping a function with</span>
<span class="sd">        a modified signature, as this may not have the intended effect.</span>

<span class="sd">        &gt;&gt;&gt; def foo(pka, *vpa, koa, **vka): ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; sig</span>
<span class="sd">        &lt;Sig (pka, *vpa, koa, **vka)&gt;</span>
<span class="sd">        &gt;&gt;&gt; assert sig.kinds[&#39;pka&#39;] == PK</span>

<span class="sd">        Let&#39;s make a signature that is the same as sig, except that</span>
<span class="sd">            - `poa` is given a PO (POSITIONAL_ONLY) kind insteadk of PK</span>
<span class="sd">            - `koa` is given a default of None</span>
<span class="sd">            - the signature is given a return_annotation of str</span>

<span class="sd">        &gt;&gt;&gt; new_sig = sig.modified(</span>
<span class="sd">        ...     pka={&#39;kind&#39;: PO},</span>
<span class="sd">        ...     koa={&#39;default&#39;: None},</span>
<span class="sd">        ...     return_annotation=str</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; new_sig</span>
<span class="sd">        &lt;Sig (pka, /, *vpa, koa=None, **vka) -&gt; str&gt;</span>
<span class="sd">        &gt;&gt;&gt; assert new_sig.kinds[&#39;pka&#39;] == PO  # now pos is of the PO kind!</span>

<span class="sd">        Here&#39;s an example of changing signature parameters in bulk.</span>
<span class="sd">        Here we change all kinds to be the friendly PK kind.</span>

<span class="sd">        &gt;&gt;&gt; sig.modified(**{name: {&#39;kind&#39;: PK} for name in sig.names})</span>
<span class="sd">        &lt;Sig (pka, vpa, koa, vka)&gt;</span>

<span class="sd">        Repetition of the above: This gives you a signature with all PK kinds.</span>
<span class="sd">        If you wrap a function with it, it will look like it has all PK kinds.</span>
<span class="sd">        But that doesn&#39;t mean you can actually use thenm as such.</span>
<span class="sd">        You&#39;ll need to modify (decorate further) your function further to reflect</span>
<span class="sd">        its new signature.</span>

<span class="sd">        On the other hand, if you decorate a function with a sig that adds or modifies</span>
<span class="sd">        defaults, these defaults will actually be used (unlike with `functools.wraps`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_return_annotation</span> <span class="o">=</span> <span class="n">changes_for_name</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
            <span class="s1">&#39;return_annotation&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">_allow_reordering</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">sort_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_params</span><span class="p">(</span><span class="n">changes_for_name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform_params</span><span class="p">(</span><span class="n">changes_for_name</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">new_return_annotation</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.ch_param_attrs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.ch_param_attrs">[docs]</a>    <span class="k">def</span> <span class="nf">ch_param_attrs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">param_attr</span><span class="p">,</span> <span class="o">*</span><span class="n">arg_new_vals</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_new_vals</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change a specific attribute of the params, returning a modified signature.</span>
<span class="sd">        This is a convenience method for the modified method when we&#39;re targetting</span>
<span class="sd">        a fixed param attribute: &#39;name&#39;, &#39;kind&#39;, &#39;default&#39;, or &#39;annotation&#39;</span>

<span class="sd">        Instead of having to do this</span>

<span class="sd">        &gt;&gt;&gt; def foo(a, *b, **c): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).modified(a={&#39;name&#39;: &#39;A&#39;}, b={&#39;name&#39;: &#39;B&#39;}, c={&#39;name&#39;: &#39;C&#39;})</span>
<span class="sd">        &lt;Sig (A, *B, **C)&gt;</span>

<span class="sd">        We can simply do this</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).ch_param_attrs(&#39;name&#39;, a=&#39;A&#39;, b=&#39;B&#39;, c=&#39;C&#39;)</span>
<span class="sd">        &lt;Sig (A, *B, **C)&gt;</span>

<span class="sd">        One quite useful thing you can do with this is to set defaults, or set defaults</span>
<span class="sd">        where there are none. If you wrap your function with such a modified signature,</span>
<span class="sd">        you get a &quot;curried&quot; version of your function (called &quot;partial&quot; in python).</span>
<span class="sd">        (Note that the `functools.wraps` won&#39;t deal with defaults &quot;correctly&quot;, but</span>
<span class="sd">        wrapping with `Sig` objects takes care of that oversight!)</span>

<span class="sd">        &gt;&gt;&gt; def foo(a, b, c):</span>
<span class="sd">        ...     return a + b * c</span>
<span class="sd">        &gt;&gt;&gt; special_foo = Sig(foo).ch_param_attrs(&#39;default&#39;, b=2, c=3)(foo)</span>
<span class="sd">        &gt;&gt;&gt; Sig(special_foo)</span>
<span class="sd">        &lt;Sig (a, b=2, c=3)&gt;</span>
<span class="sd">        &gt;&gt;&gt; special_foo(5)  # should be 5 + 2 * 3 == 11</span>
<span class="sd">        11</span>


<span class="sd">        # TODO: Would like to make this work (reordering)</span>
<span class="sd">        # Now, if you want to set a default for a but not b and c for example, you&#39;ll</span>
<span class="sd">        # get complaints:</span>
<span class="sd">        #</span>
<span class="sd">        # ```</span>
<span class="sd">        # ValueError: non-default argument follows default argument</span>
<span class="sd">        # ```</span>
<span class="sd">        #</span>
<span class="sd">        # will tell you.</span>
<span class="sd">        #</span>
<span class="sd">        # It&#39;s true. But if you&#39;re fine with rearranging the argument order,</span>
<span class="sd">        # `ch_param_attrs` can take care of that for you.</span>
<span class="sd">        # You&#39;ll have to tell it explicitly that you wish for this though, because</span>
<span class="sd">        # it&#39;s conservative.</span>
<span class="sd">        #</span>
<span class="sd">        # &gt;&gt;&gt; # Note that for time being, Sig.wraps doesn&#39;t make a copy of the function</span>
<span class="sd">        # &gt;&gt;&gt; #  so we need to redefine foo here@</span>
<span class="sd">        # &gt;&gt;&gt; def foo(a, b, c):</span>
<span class="sd">        # ...     return a + b * c</span>
<span class="sd">        # &gt;&gt;&gt; wrapper = Sig(foo).ch_param_attrs(</span>
<span class="sd">        # ... &#39;default&#39;, a=10, _allow_reordering=True</span>
<span class="sd">        # ... )</span>
<span class="sd">        # &gt;&gt;&gt; another_foo = wrapper(foo)</span>
<span class="sd">        # &gt;&gt;&gt; Sig(another_foo)</span>
<span class="sd">        # &lt;Sig (b, c, a=10)&gt;</span>
<span class="sd">        # &gt;&gt;&gt; another_foo(2, 3)  # should be 10 + (2 * 3) =</span>
<span class="sd">        # 16</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">param_attr</span> <span class="ow">in</span> <span class="n">param_attributes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;param_attr needs to be one of: </span><span class="si">{</span><span class="n">param_attributes</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39; Was: </span><span class="si">{</span><span class="n">param_attr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">all_pk_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PK</span><span class="p">}</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">new_attr_vals</span> <span class="o">=</span> <span class="n">all_pk_self</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span>
            <span class="o">*</span><span class="n">arg_new_vals</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_new_vals</span>
        <span class="p">)</span><span class="o">.</span><span class="n">arguments</span>
        <span class="n">changes_for_name</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="p">{</span><span class="n">param_attr</span><span class="p">:</span> <span class="n">val</span><span class="p">}</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">new_attr_vals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span><span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">)</span></div>

    <span class="c1"># Note: Oh, functools, why do you make currying so limited!</span>
    <span class="c1"># ch_names = partialmethod(ch_param_attrs, param_attr=&quot;name&quot;)</span>
    <span class="c1"># ch_kinds = partialmethod(ch_param_attrs, param_attr=&quot;kind&quot;, _allow_reordering=True)</span>
    <span class="c1"># ch_defaults = partialmethod(</span>
    <span class="c1">#     ch_param_attrs, param_attr=&quot;default&quot;, _allow_reordering=True</span>
    <span class="c1"># )</span>
    <span class="c1"># ch_annotations = partialmethod(ch_param_attrs, param_attr=&quot;annotation&quot;)</span>

    <span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">):</span>
        <span class="n">argnames_not_in_sig</span> <span class="o">=</span> <span class="n">changes_for_name</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">argnames_not_in_sig</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;argument names not in signature: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argnames_not_in_sig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ch_kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span>
            <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ch_kinds_to_position_or_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ch_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span>
            <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">ch_annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_param_attrs</span><span class="p">(</span><span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.merge_with_sig"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.merge_with_sig">[docs]</a>    <span class="k">def</span> <span class="nf">merge_with_sig</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span>
        <span class="n">ch_to_all_pk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">default_conflict_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a signature obtained by merging self signature with another signature.</span>
<span class="sd">        Insofar as it can, given the kind precedence rules, the arguments of self will</span>
<span class="sd">        appear first.</span>

<span class="sd">        :param sig: The signature to merge with.</span>
<span class="sd">        :param ch_to_all_pk: Whether to change all kinds of both signatures to PK (</span>
<span class="sd">        POSITIONAL_OR_KEYWORD)</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; def func(a=None, *, b=1, c=2):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(func)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        &lt;Sig (a=None, *, b=1, c=2)&gt;</span>

<span class="sd">        Observe where the new arguments ``d`` and ``e`` are placed,</span>
<span class="sd">        according to whether they have defaults and what their kind is:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&quot;d&quot;, &quot;e&quot;])</span>
<span class="sd">        &lt;Sig (d, e, a=None, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&quot;d&quot;, (&quot;e&quot;, 4)])</span>
<span class="sd">        &lt;Sig (d, a=None, e=4, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&quot;d&quot;, dict(name=&quot;e&quot;, kind=KO, default=4)])</span>
<span class="sd">        &lt;Sig (d, a=None, *, b=1, c=2, e=4)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig(</span>
<span class="sd">        ...     [dict(name=&quot;d&quot;, kind=KO), dict(name=&quot;e&quot;, kind=KO, default=4)]</span>
<span class="sd">        ... )</span>
<span class="sd">        &lt;Sig (a=None, *, d, b=1, c=2, e=4)&gt;</span>

<span class="sd">        If the kind of the params is not important, but order is, you can specify</span>
<span class="sd">        ``ch_to_all_pk=True``:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&quot;d&quot;, &quot;e&quot;], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (d, e, a=None, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([(&quot;d&quot;, 3), (&quot;e&quot;, 4)], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (a=None, b=1, c=2, d=3, e=4)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch_to_all_pk</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">all_pk_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">all_pk_signature</span><span class="p">(</span><span class="n">ensure_signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="n">_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Happened during an attempt to merge </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">sig</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_POSITIONAL parameter:&quot;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span>
        <span class="p">),</span> <span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_KEYWORD parameter:</span><span class="si">{_msg}</span><span class="s2">&quot;</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;During a signature merge, if two names are the same, they must have the &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;**same kind**:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s2">&quot;Tip: If you&#39;re trying to merge functions in some way, consider decorating &quot;</span>
            <span class="s1">&#39;them with a signature mapping that avoids the argument name clashing&#39;</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="n">default_conflict_method</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;strict&#39;</span><span class="p">,</span>
            <span class="s1">&#39;take_first&#39;</span><span class="p">,</span>
        <span class="p">},</span> <span class="s2">&quot;default_conflict_method should be in {None, &#39;strict&#39;, &#39;take_first&#39;}&quot;</span>

        <span class="k">if</span> <span class="n">default_conflict_method</span> <span class="o">==</span> <span class="s1">&#39;take_first&#39;</span><span class="p">:</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">_sig</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="c1"># if default_conflict_method == &#39;take_first&#39;:</span>
            <span class="c1">#     _sig = _sig - set(_self.keys() &amp; _sig.keys())</span>
            <span class="c1"># else:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;During a signature merge, if two names are the same, they must have &#39;</span>
                <span class="s1">&#39;the &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;**same default**:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s2">&quot;Tip: If you&#39;re trying to merge functions in some way, consider &quot;</span>
                <span class="s1">&#39;decorating &#39;</span>
                <span class="s1">&#39;them with a signature mapping that avoids the argument name clashing&#39;</span>
            <span class="p">)</span>

        <span class="c1"># assert all(</span>
        <span class="c1">#     _self[name].default == _sig[name].default</span>
        <span class="c1">#     for name in _self.keys() &amp; _sig.keys()</span>
        <span class="c1"># ), (</span>
        <span class="c1">#     &#39;During a signature merge, if two names are the same, they must have the &#39;</span>
        <span class="c1">#     f&#39;**same default**:\n\t{_msg}\n&#39;</span>
        <span class="c1">#     &quot;Tip: If you&#39;re trying to merge functions in some way, consider</span>
        <span class="c1">#     decorating &quot;</span>
        <span class="c1">#     &quot;them a signature mapping that &quot;</span>
        <span class="c1">#     &#39;avoids the argument name clashing&#39;</span>
        <span class="c1"># )</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chain_params_of_signatures</span><span class="p">(</span>
                <span class="n">_self</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span>
                <span class="n">_sig</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span>
                <span class="n">_self</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">,</span>
                <span class="n">_sig</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge two signatures (casting all non-VAR kinds to POSITIONAL_OR_KEYWORD</span>
<span class="sd">        before hand)</span>

<span class="sd">        Important Notes:</span>
<span class="sd">        - The resulting Sig will loose it&#39;s return_annotation if it had one.</span>
<span class="sd">            This is to avoid making too many assumptions about how the sig sum will be</span>
<span class="sd">            used.</span>
<span class="sd">            If a return_annotation is needed (say, for composition, the last</span>
<span class="sd">            return_annotation</span>
<span class="sd">            summed), one can subclass Sig and overwrite __add__</span>
<span class="sd">        - POSITION_ONLY and KEYWORD_ONLY kinds will be replaced by</span>
<span class="sd">        POSITIONAL_OR_KEYWORD kind.</span>
<span class="sd">        This is to simplify the interface and code.</span>
<span class="sd">        If the user really wants to maintain those kinds, they can replace them back</span>
<span class="sd">        after the fact.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; def h(i, j, w):</span>
<span class="sd">        ...     ...  # has a &#39;w&#39; argument, like f and g</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def different(a, b: str, c=None):</span>
<span class="sd">        ...     ...  # No argument names in common with other functions</span>

<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(different)</span>
<span class="sd">        &lt;Sig (w, a, b: str, x: float = 1, y=1, z: int = 1, c=None)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(different) + Sig(f)</span>
<span class="sd">        &lt;Sig (a, b: str, w, c=None, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The order of the first signature will take precedence over the second,</span>
<span class="sd">        but default-less arguments have to come before arguments with defaults.</span>
<span class="sd">         first, and Note the difference of the orders.</span>

<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(h)</span>
<span class="sd">        &lt;Sig (w, i, j, x: float = 1, y=1, z: int = 1)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(f)</span>
<span class="sd">        &lt;Sig (i, j, w, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The sum of two Sig&#39;s takes a safe-or-blow-up-now approach.</span>
<span class="sd">        If any of the arguments have different defaults or annotations, summing will</span>
<span class="sd">        raise an AssertionError.</span>
<span class="sd">        It&#39;s up to the user to decorate their input functions to express the default</span>
<span class="sd">        they actually desire.</span>

<span class="sd">        &gt;&gt;&gt; def ff(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     ...  # just like f, but without the default for x</span>
<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(ff)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: During a signature merge, if two names are the same, they must</span>
<span class="sd">        have the **same default**:</span>
<span class="sd">        &lt;BLANKSPACE&gt;</span>
<span class="sd">        Happened during an attempt to merge (w, /, x: float = 1, y=1, *, z: int = 1)</span>
<span class="sd">        and (w, /, x: float, y=1, *, z: int = 1)</span>
<span class="sd">        Tip: If you&#39;re trying to merge functions in some way, consider decorating them</span>
<span class="sd">        with a signature mapping that avoids the argument name clashing</span>


<span class="sd">        &gt;&gt;&gt; def hh(i, j, w=1):</span>
<span class="sd">        ...     ...  # like h, but w has a default</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(hh)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: During a signature merge, if two names are the same, they must</span>
<span class="sd">        have the **same default**:</span>
<span class="sd">        &lt;BLANKSPACE&gt;</span>
<span class="sd">        Happened during an attempt to merge (i, j, w) and (i, j, w=1)</span>
<span class="sd">        Tip: If you&#39;re trying to merge fposiunctions in some way, consider decorating</span>
<span class="sd">        them</span>
<span class="sd">        with a signature mapping that avoids the argument name clashing</span>


<span class="sd">        &gt;&gt;&gt; Sig(f) + [</span>
<span class="sd">        ...     &quot;w&quot;,</span>
<span class="sd">        ...     (&quot;y&quot;, 1),</span>
<span class="sd">        ...     (&quot;d&quot;, 1.0, float),</span>
<span class="sd">        ...     dict(name=&quot;special&quot;, kind=Parameter.KEYWORD_ONLY, default=0),</span>
<span class="sd">        ... ]</span>
<span class="sd">        &lt;Sig (w, x: float = 1, y=1, z: int = 1, d: float = 1.0, special=0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adding on the right.</span>
<span class="sd">        The raison d&#39;tre for this is so that you can start your summing with any</span>
<span class="sd">        signature speccifying</span>
<span class="sd">         object that Sig will be able to resolve into a signature. Like this:</span>

<span class="sd">        &gt;&gt;&gt; [&quot;first_arg&quot;, (&quot;second_arg&quot;, 42)] + Sig(lambda x, y: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, x, y, second_arg=42)&gt;</span>

<span class="sd">        Note that the ``second_arg`` doesn&#39;t actually end up being the second argument</span>
<span class="sd">        because</span>
<span class="sd">        it has a default and x and y don&#39;t. But if you did this:</span>

<span class="sd">        &gt;&gt;&gt; [&quot;first_arg&quot;, (&quot;second_arg&quot;, 42)] + Sig(lambda x=0, y=1: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, second_arg=42, x=0, y=1)&gt;</span>

<span class="sd">        you&#39;d get what you expect.</span>

<span class="sd">        Of course, we could have just obliged you to say ``Sig([&#39;first_arg&#39;,</span>
<span class="sd">        (&#39;second_arg&#39;, 42)])``</span>
<span class="sd">        explicitly and spare ourselves yet another method.</span>
<span class="sd">        The reason we made ``__radd__`` is so we can make it handle 0 + Sig(...),</span>
<span class="sd">        so that you can</span>
<span class="sd">        merge an iterable of signatures like this:</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b, c):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def g(c, b, e):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; sigs = map(Sig, [f, g])</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (a, b, c, e)&gt;</span>

<span class="sd">        Let&#39;s say, for whatever reason (don&#39;t ask me), you wanted to make a function</span>
<span class="sd">        that contains all the</span>
<span class="sd">        arguments of all the functions of ``os.path`` (that don&#39;t contain any var arg</span>
<span class="sd">        kinds).</span>

<span class="sd">        &gt;&gt;&gt; import os.path</span>
<span class="sd">        &gt;&gt;&gt; funcs = list(</span>
<span class="sd">        ...     filter(</span>
<span class="sd">        ...         callable,</span>
<span class="sd">        ...         (</span>
<span class="sd">        ...             getattr(os.path, a)</span>
<span class="sd">        ...             for a in dir(os.path)</span>
<span class="sd">        ...             if not a.startswith(&quot;_&quot;)</span>
<span class="sd">        ...         ),</span>
<span class="sd">        ...     )</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; sigs = filter(lambda sig: not sig.has_var_kinds, map(Sig, funcs))</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (path, p, paths, m, filename, s, f1, f2, fp1, fp2, s1, s2, start=None)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># so that we can do ``sum(iterable_of_sigs)``</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">names</span><span class="p">)}</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.add_params"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.add_params">[docs]</a>    <span class="k">def</span> <span class="nf">add_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new instance of Sig after merging the parameters of this signature</span>
<span class="sd">        with a list of new parameters. The new list of parameters is automatically</span>
<span class="sd">        sorted based on signature constraints given by kinds and default values.</span>
<span class="sd">        See Python native signature documentation for more details.</span>

<span class="sd">        &gt;&gt;&gt; s = Sig(&#39;(a, /, b, *, c)&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add_params([</span>
<span class="sd">        ...     Param(&#39;kwargs&#39;, VK),</span>
<span class="sd">        ...     dict(name=&#39;d&#39;, kind=KO),</span>
<span class="sd">        ...     Param(&#39;args&#39;, VP),</span>
<span class="sd">        ...     &#39;e&#39;,</span>
<span class="sd">        ...     Param(&#39;f&#39;, PO),</span>
<span class="sd">        ... ])</span>
<span class="sd">        &lt;Sig (a, f, /, b, e, *args, c, d, **kwargs)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">comparator</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">KO</span> <span class="ow">or</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">)</span>

        <span class="n">new_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">+</span> <span class="p">[</span><span class="n">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">comparator</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">new_params</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_names</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_chain_params_of_signatures</span><span class="p">(</span><span class="o">*</span><span class="n">sigs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields Parameter instances taken from sigs without repeating the same name</span>
<span class="sd">        twice.</span>

<span class="sd">        &gt;&gt;&gt; str(list(</span>
<span class="sd">        ...     Sig._chain_params_of_signatures(</span>
<span class="sd">        ...         Sig(lambda x, *args, y=1: ...),</span>
<span class="sd">        ...         Sig(lambda x, y, z, **kwargs: ...),</span>
<span class="sd">        ...     )</span>
<span class="sd">        ...   )</span>
<span class="sd">        ... )</span>
<span class="sd">        &#39;[&lt;Parameter &quot;x&quot;&gt;, &lt;Parameter &quot;*args&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z&quot;&gt;, &lt;Parameter &quot;**kwargs&quot;&gt;]&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">already_merged_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sigs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_merged_names</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>
                <span class="n">already_merged_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">without_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sub-signature containing only &quot;required&quot; (i.e. without defaults) parameters.</span>

<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).without_defaults)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">with_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sub-signature containing only &quot;not required&quot; (i.e. with defaults) parameters.</span>

<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).with_defaults)</span>
<span class="sd">        [&#39;args&#39;, &#39;x&#39;, &#39;y&#39;, &#39;kwargs&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize_kind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span>
        <span class="n">except_kinds</span><span class="o">=</span><span class="n">var_param_kinds</span><span class="p">,</span>
        <span class="n">add_defaults_if_necessary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">argname_to_default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">add_defaults_if_necessary</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">argname_to_default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">def</span> <span class="nf">argname_to_default</span><span class="p">(</span><span class="n">argname</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
            <span class="n">there_was_a_default</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">except_kinds</span><span class="p">:</span>
                    <span class="c1"># print(p.name)</span>
                    <span class="k">if</span> <span class="n">add_defaults_if_necessary</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">there_was_a_default</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">_empty</span><span class="p">:</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">argname_to_default</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="n">there_was_a_default</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">p</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_reordering</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span>
                    <span class="n">sort_params</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

<div class="viewcode-block" id="Sig.kwargs_from_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.kwargs_from_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">kwargs_from_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">args</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts a dict of input argument values for target signature, from args</span>
<span class="sd">        and kwargs.</span>

<span class="sd">        When you need to manage how the arguments of a function are specified,</span>
<span class="sd">        you need to take care of</span>
<span class="sd">        multiple cases depending on whether they were specified as positional arguments</span>
<span class="sd">        (`args`) or keyword arguments (`kwargs`).</span>

<span class="sd">        The `kwargs_from_args_and_kwargs` (and it&#39;s sorta-inverse inverse,</span>
<span class="sd">        `args_and_kwargs_from_kwargs`)</span>
<span class="sd">        are there to help you manage this.</span>

<span class="sd">        If you could rely on the the fact that only `kwargs` were given it would</span>
<span class="sd">        reduce the complexity of your code.</span>
<span class="sd">        This is why we have the `all_pk_signature` function in `signatures.py`.</span>

<span class="sd">        We also need to have a means to make a `kwargs` only from the actual `(*args,</span>
<span class="sd">        **kwargs)` used at runtime.</span>
<span class="sd">        We have `Signature.bind` (and `bind_partial`) for that.</span>

<span class="sd">        But these methods will fail if there is extra stuff in the `kwargs`.</span>
<span class="sd">        Yet sometimes we&#39;d like to have a `dict` that services several functions that</span>
<span class="sd">        will extract their needs from it.</span>

<span class="sd">        That&#39;s where  `Sig.extract_kwargs(*args, **kwargs)` is needed.</span>
<span class="sd">        :param args: The args the function will be called with.</span>
<span class="sd">        :param kwargs: The kwargs the function will be called with.</span>
<span class="sd">        :param apply_defaults: (bool) Whether to apply signature defaults to the</span>
<span class="sd">        non-specified argument names</span>
<span class="sd">        :param allow_partial: (bool) True iff you want to allow partial signature</span>
<span class="sd">        fulfillment.</span>
<span class="sd">        :param allow_excess: (bool) Set to True iff you want to allow extra kwargs</span>
<span class="sd">        items to be ignored.</span>
<span class="sd">        :param ignore_kind: (bool) Set to True iff you want to ignore the position and</span>
<span class="sd">        keyword only kinds,</span>
<span class="sd">            in order to be able to accept args and kwargs in such a way that there can</span>
<span class="sd">            be cross-over</span>
<span class="sd">            (args that are supposed to be keyword only, and kwargs that are supposed</span>
<span class="sd">            to be positional only)</span>
<span class="sd">        :return: An {argname: argval, ...} dict</span>

<span class="sd">        See also the sorta-inverse of this function: args_and_kwargs_from_kwargs</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&quot;YY&quot;, *, z: str = &quot;ZZ&quot;):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.kwargs_from_args_and_kwargs((11, 22, &quot;you&quot;), dict(z=&quot;zoo&quot;))</span>
<span class="sd">        ...     == sig.kwargs_from_args_and_kwargs((11, 22), dict(y=&quot;you&quot;, z=&quot;zoo&quot;))</span>
<span class="sd">        ...     == {&quot;w&quot;: 11, &quot;x&quot;: 22, &quot;y&quot;: &quot;you&quot;, &quot;z&quot;: &quot;zoo&quot;}</span>
<span class="sd">        ... )</span>

<span class="sd">        By default, `apply_defaults=False`, which will lead to only get those</span>
<span class="sd">        arguments you input.</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&quot;x&quot;: 22})</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        But if you specify `apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(11,), kwargs={&quot;x&quot;: 22}, apply_defaults=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;YY&#39;, &#39;z&#39;: &#39;ZZ&#39;}</span>

<span class="sd">        By default, `ignore_excess=False`, so specifying kwargs that are not in the</span>
<span class="sd">        signature will lead to an exception.</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(11,), kwargs={&quot;x&quot;: 22, &quot;not_in_sig&quot;: -1}</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        TypeError: Got unexpected keyword arguments: not_in_sig</span>

<span class="sd">        Specifying `allow_excess=True` will ignore such excess fields of kwargs.</span>
<span class="sd">        This is useful when you want to source several functions from a same dict.</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(11,), kwargs={&quot;x&quot;: 22, &quot;not_in_sig&quot;: -1}, allow_excess=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        On the other side of `ignore_excess` you have `allow_partial` that will allow</span>
<span class="sd">        you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being</span>
<span class="sd">        completed later).</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs={&quot;x&quot;: 22})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `allow_partial=True`...</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(), kwargs={&quot;x&quot;: 22}, allow_partial=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;x&#39;: 22}</span>

<span class="sd">        That&#39;s a lot of control (eight combinations total), but not everything is</span>
<span class="sd">        controllable here:</span>
<span class="sd">        Position only and keyword only kinds need to be respected:</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(1, 2, 3, 4), kwargs={})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: too many positional arguments</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs=dict(w=1, x=2, y=3, z=4))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        But if you want to ignore the kind of parameter, just say so:</span>

<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(1, 2, 3, 4), kwargs={}, ignore_kind=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(</span>
<span class="sd">        ...     args=(), kwargs=dict(w=1, x=2, y=3, z=4), ignore_kind=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">vk_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_keyword_name</span>

        <span class="k">if</span> <span class="n">ignore_kind</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_kind</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vk_name</span><span class="p">:</span>  <span class="c1"># has no var keyword kinds</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="p">}</span>  <span class="c1"># take only what you need</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">vk_name</span><span class="p">},</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">vk_name</span><span class="p">,</span> <span class="p">{}),</span>
            <span class="p">)</span>
        <span class="n">binder</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span> <span class="k">if</span> <span class="n">allow_partial</span> <span class="k">else</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_var_positional</span> <span class="ow">and</span> <span class="n">allow_excess</span><span class="p">:</span>
            <span class="n">max_allowed_num_of_posisional_args</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">PK</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">max_allowed_num_of_posisional_args</span><span class="p">]</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">binder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">sig_relevant_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_defaults</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">vk_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_excess</span><span class="p">:</span>  <span class="c1"># don&#39;t ignore excess kwargs</span>
            <span class="n">excess</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">arguments</span>
            <span class="k">if</span> <span class="n">excess</span><span class="p">:</span>
                <span class="n">excess_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">excess</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got unexpected keyword arguments: </span><span class="si">{</span><span class="n">excess_str</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="n">var_kw_name</span> <span class="o">=</span> <span class="n">name_of_var_kw_argument</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">flattened_kvs</span> <span class="o">=</span> <span class="n">expand_nested_key</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">arguments</span><span class="p">,</span> <span class="n">var_kw_name</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">flattened_kvs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Sig.args_and_kwargs_from_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.args_and_kwargs_from_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">args_and_kwargs_from_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">,</span>
        <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">args_limit</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract args and kwargs such that func(*args, **kwargs) can be called,</span>
<span class="sd">        where func has instance&#39;s signature.</span>

<span class="sd">        :param kwargs: The {argname: argval,...} dict to process</span>
<span class="sd">        :param args_limit: How &quot;far&quot; in the params should args (positional arguments)</span>
<span class="sd">            be searched for.</span>
<span class="sd">            - args_limit==0: Take the minimum number possible of args (positional</span>
<span class="sd">                arguments). Only those that are position only or before a var-positional.</span>
<span class="sd">            - args_limit is None: Take the maximum number of args (positional arguments).</span>
<span class="sd">                The only kwargs (keyword arguments) you should have are keyword-only</span>
<span class="sd">                and var-keyword arguments.</span>
<span class="sd">            - args_limit positive integer: Take the args_limit first argument names</span>
<span class="sd">                (of signature) as args, and the rest as kwargs.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     return ((w + x) * y) ** z</span>
<span class="sd">        &gt;&gt;&gt; foo_sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = foo_sig.args_and_kwargs_from_kwargs(</span>
<span class="sd">        ...     dict(w=4, x=3, y=2, z=1)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2, &quot;z&quot;: 1})</span>
<span class="sd">        &gt;&gt;&gt; assert foo(*args, **kwargs) == foo(4, 3, 2, z=1) == 14</span>

<span class="sd">        The `args_limit` begs explanation.</span>
<span class="sd">        Consider the signature of `def foo(w, /, x: float, y=1, *, z: int = 1): ...`</span>
<span class="sd">        for instance. We could call the function with the following (args, kwargs) pairs:</span>
<span class="sd">        - ((1,), {&#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4})</span>
<span class="sd">        - ((1, 2), {&#39;y&#39;: 3, &#39;z&#39;: 4})</span>
<span class="sd">        - ((1, 2, 3), {&#39;z&#39;: 4})</span>
<span class="sd">        The two other combinations (empty args or empty kwargs) are not valid</span>
<span class="sd">        because of the / and * constraints.</span>

<span class="sd">        But when asked for an (args, kwargs) pair, which of the three valid options</span>
<span class="sd">        should be returned? This is what the `args_limit` argument controls.</span>

<span class="sd">        If `args_limit == 0`, the least args (positional arguments) will be returned.</span>
<span class="sd">        It&#39;s the default.</span>

<span class="sd">        &gt;&gt;&gt; kwargs = dict(w=4, x=3, y=2, z=1)</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(kwargs, args_limit=0)</span>
<span class="sd">        ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>

<span class="sd">        If `args_limit is None`, the least kwargs (keyword arguments) will be returned.</span>

<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(kwargs, args_limit=None)</span>
<span class="sd">        ((4, 3, 2), {&#39;z&#39;: 1})</span>

<span class="sd">        If `args_limit` is a positive integer, the first `args_limit` arguments</span>
<span class="sd">        will be returned (not checking at all if this is valid!).</span>

<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(kwargs, args_limit=1)</span>
<span class="sd">        ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(kwargs, args_limit=2)</span>
<span class="sd">        ((4, 3), {&#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(kwargs, args_limit=3)</span>
<span class="sd">        ((4, 3, 2), {&#39;z&#39;: 1})</span>

<span class="sd">        Note that &#39;args_limit&#39;&#39;s behavior is consistent with list behvior in the sense</span>
<span class="sd">        that:</span>

<span class="sd">        &gt;&gt;&gt; args = (0, 1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; args[:0]</span>
<span class="sd">        ()</span>
<span class="sd">        &gt;&gt;&gt; args[:None]</span>
<span class="sd">        (0, 1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; args[2]</span>
<span class="sd">        2</span>

<span class="sd">        By default, only the arguments that were given in the kwargs input will be</span>
<span class="sd">        returned in the (args, kwargs) output.</span>
<span class="sd">        If you also want to get those that have defaults (according to signature),</span>
<span class="sd">        you need to specify it with the `apply_defaults=True` argument.</span>

<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4, x=3))</span>
<span class="sd">        ((4,), {&#39;x&#39;: 3})</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4, x=3), apply_defaults=True)</span>
<span class="sd">        ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 1, &#39;z&#39;: 1})</span>

<span class="sd">        By default, all required arguments must be given.</span>
<span class="sd">        Not doing so will lead to a `TypeError`.</span>
<span class="sd">        If you want to process your arguments anyway, specify `allow_partial=True`.</span>

<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;x&#39;</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4), allow_partial=True)</span>
<span class="sd">        ((4,), {})</span>

<span class="sd">        Specifying argument names that are not recognized by the signature will</span>
<span class="sd">        lead to a `TypeError`.</span>
<span class="sd">        If you want to avoid this (and just take from the input `kwargs` what ever you</span>
<span class="sd">        can), specify this with `allow_excess=True`.</span>

<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4, x=3, extra=&#39;stuff&#39;))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        TypeError: Got unexpected keyword arguments: extra</span>
<span class="sd">        &gt;&gt;&gt; foo_sig.args_and_kwargs_from_kwargs(dict(w=4, x=3, extra=&#39;stuff&#39;),</span>
<span class="sd">        ...     allow_excess=True)</span>
<span class="sd">        ((4,), {&#39;x&#39;: 3})</span>

<span class="sd">        An edge case: When a `VAR_POSITIONAL` follows a `POSITION_OR_KEYWORD`...</span>

<span class="sd">        &gt;&gt;&gt; Sig(lambda a, *b, c=2: None).args_and_kwargs_from_kwargs(</span>
<span class="sd">        ...     {&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: 4}</span>
<span class="sd">        ... )</span>
<span class="sd">        ((1, [2, 3]), {&#39;c&#39;: 4})</span>

<span class="sd">        See `kwargs_from_args_and_kwargs` (namely for the description of the arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">args_limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Take the maximum number of args (positional arguments).</span>
            <span class="c1"># The only kwargs (keyword arguments) you should have are keyword-only</span>
            <span class="c1"># and var-keyword arguments.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">&gt;</span> <span class="n">VP</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">names_for_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">args_limit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Take the minimum number possible of args (positional arguments)</span>
            <span class="c1"># Only those that are position only or before a var-positional.</span>
            <span class="n">vp_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_of_var_positional</span>
            <span class="k">if</span> <span class="n">vp_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">names_for_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PO</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># When there&#39;s a VP present, all arguments before it can only be</span>
                <span class="c1"># expressed positionally if the VP argument is non-empty.</span>
                <span class="c1"># So, here we just consider all arguments positionally up to the VP arg.</span>
                <span class="n">names_for_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[:</span> <span class="p">(</span><span class="n">vp_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names_for_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[:</span><span class="n">args_limit</span><span class="p">]</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names_for_args</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names_for_args</span><span class="p">}</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="n">allow_excess</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">ignore_kind</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names_for_args</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="Sig.extract_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.extract_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience method that calls kwargs_from_args_and_kwargs with defaults,</span>
<span class="sd">        and ignore_kind=True.</span>

<span class="sd">        Strict in the sense that the kwargs cannot contain any arguments that are not</span>
<span class="sd">        valid argument names (as per the signature).</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&quot;YY&quot;, *, z: str = &quot;ZZ&quot;):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.extract_kwargs(1, 2, 3, z=4)</span>
<span class="sd">        ...     == sig.extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        ...     == {&quot;w&quot;: 1, &quot;x&quot;: 2, &quot;y&quot;: 3, &quot;z&quot;: 4}</span>
<span class="sd">        ... )</span>

<span class="sd">        What about var positional and var keywords?</span>

<span class="sd">        &gt;&gt;&gt; def bar(*args, **kwargs):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(bar).extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        {&#39;args&#39;: (1, 2), &#39;kwargs&#39;: {&#39;y&#39;: 3, &#39;z&#39;: 4}}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as</span>
<span class="sd">        a keyword argument too (by default):</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function</span>
<span class="sd">        (in view of being completed later).</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2, _allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments</span>
<span class="sd">        you input.</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2, _apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.extract_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.extract_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_args_limit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess</span>
<span class="sd">        arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        The difference with extract_kwargs is that here the output is ready to be</span>
<span class="sd">        called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be</span>
<span class="sd">        returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a</span>
<span class="sd">        keyword argument too (by default):</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being</span>
<span class="sd">        completed later).</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(</span>
<span class="sd">        ...     x=3, y=2, _allow_partial=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those</span>
<span class="sd">        arguments you input.</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(</span>
<span class="sd">        ...     4, x=3, y=2, _apply_defaults=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2, &quot;z&quot;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">_ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">_allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">_apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="n">args_limit</span><span class="o">=</span><span class="n">_args_limit</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.source_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the kwargs for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&quot;YY&quot;, *, z: str = &quot;ZZ&quot;):</span>
<span class="sd">        ...     ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(11, x=22, extra=&quot;keywords&quot;, are=&quot;ignored&quot;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as a</span>
<span class="sd">        keyword argument too (by default):</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(w=11, x=22, extra=&quot;keywords&quot;, are=&quot;ignored&quot;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(</span>
<span class="sd">        ...     w=11, x=22, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _ignore_kind=False</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being</span>
<span class="sd">        completed later).</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(</span>
<span class="sd">        ...     x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _allow_partial=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those</span>
<span class="sd">        arguments you input.</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(</span>
<span class="sd">        ...     4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _apply_defaults=True</span>
<span class="sd">        ... )</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.source_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess</span>
<span class="sd">        arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        The difference with source_kwargs is that here the output is ready to be</span>
<span class="sd">        called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be</span>
<span class="sd">        returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a</span>
<span class="sd">        keyword argument too (by default):</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     w=4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     w=4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _ignore_kind=False</span>
<span class="sd">        ... )</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being</span>
<span class="sd">        completed later).</span>

<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _allow_partial=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those</span>
<span class="sd">        arguments you input.</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>

<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(</span>
<span class="sd">        ...     4, x=3, y=2, extra=&quot;keywords&quot;, are=&quot;ignored&quot;, _apply_defaults=True</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&quot;x&quot;: 3, &quot;y&quot;: 2, &quot;z&quot;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">_validate_sanity_of_signature_change</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">new_sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">ignore_incompatible_signatures</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">):</span>

    <span class="n">func_pos</span><span class="p">,</span> <span class="n">func_kw</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">_positional_and_keyword_defaults</span><span class="p">()</span>
    <span class="n">self_pos</span><span class="p">,</span> <span class="n">self_kw</span> <span class="o">=</span> <span class="n">new_sig</span><span class="o">.</span><span class="n">_positional_and_keyword_defaults</span><span class="p">()</span>
    <span class="c1"># print(func_pos, func_kw )</span>
    <span class="c1"># print(self_pos, self_kw)</span>

    <span class="n">pos_default_switching_to_kw</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">func_pos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_kw</span><span class="p">)</span>
    <span class="n">kw_default_switching_to_pos</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">func_kw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">self_pos</span><span class="p">)</span>

    <span class="c1"># print(pos_default_switching_to_kw, kw_default_switching_to_pos)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_incompatible_signatures</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">pos_default_switching_to_kw</span> <span class="ow">or</span> <span class="n">kw_default_switching_to_pos</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">IncompatibleSignatures</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Changing both the kind and the default of a param will result to &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;unexpected behaviors if the function is not properly wrapped to do so.&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;If you really want to do this, inject signature using the &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;`ignore_incompatible_signatures=True`&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;argument in `Sig.wrap(...)`. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;Alternatively, you can use `i2.wrapper` tools to have more control &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;over function defaults and signatures.&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;The function you were wrapping had signature: &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="si">}{</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2"> and &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;the signature you wanted to inject was </span><span class="si">{</span><span class="n">new_sig</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="si">}{</span><span class="n">new_sig</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="c1">########################################################################################</span>
<span class="c1"># Recipes</span>


<div class="viewcode-block" id="mk_sig_from_args"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.mk_sig_from_args">[docs]</a><span class="k">def</span> <span class="nf">mk_sig_from_args</span><span class="p">(</span><span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a Signature instance by specifying args_without_default and</span>
<span class="sd">    args_with_defaults.</span>

<span class="sd">    &gt;&gt;&gt; mk_sig_from_args(&quot;a&quot;, &quot;b&quot;, c=1, d=&quot;bar&quot;)</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args_without_default</span>
    <span class="p">),</span> <span class="s1">&#39;all default-less arguments must be strings&#39;</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span>
        <span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_remove_variadics_from_sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove variadics from signature</span>
<span class="sd">    &gt;&gt;&gt; def foo(a, *args, bar, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {args=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">    &gt;&gt;&gt; assert str(sig) == &#39;(a, *args, bar, **kwargs)&#39;</span>
<span class="sd">    &gt;&gt;&gt; new_sig = _remove_variadics_from_sig(sig)</span>
<span class="sd">    &gt;&gt;&gt; str(new_sig)==&#39;(a, args=(), *, bar, kwargs={})&#39;</span>
<span class="sd">    True</span>

<span class="sd">    Note that if there is not variadic positional arguments, the variadic keyword</span>
<span class="sd">    will still be a keyword-only kind.</span>

<span class="sd">    &gt;&gt;&gt; def func(a, bar=None, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; nsig = _remove_variadics_from_sig(Sig(func))</span>
<span class="sd">    &gt;&gt;&gt; assert str(nsig)==&#39;(a, bar=None, *, kwargs={})&#39;</span>

<span class="sd">    If the function has neither variadic kinds, it will remain untouched.</span>

<span class="sd">    &gt;&gt;&gt; def func(a, /, b, *, c=3):</span>
<span class="sd">    ...     return a + b + c</span>
<span class="sd">    &gt;&gt;&gt; sig = _remove_variadics_from_sig(Sig(func))</span>

<span class="sd">    &gt;&gt;&gt; assert sig == Sig(func)</span>


<span class="sd">    If you only want the variadic positional to be handled, but leave leave any</span>
<span class="sd">    VARIADIC_KEYWORD kinds (**kwargs) alone, you can do so by setting</span>
<span class="sd">    `ch_variadic_keyword_to_keyword=False`.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, *args, bar=None, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {args=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert str(Sig(_remove_variadics_from_sig(Sig(foo))))==&#39;(a, args=(), *, bar=None, kwargs={})&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">idx_of_vp</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">index_of_var_positional</span>
    <span class="n">var_keyword_argname</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">var_keyword_name</span>
    <span class="n">result_sig</span> <span class="o">=</span> <span class="n">sig</span>
    <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">var_keyword_argname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">params</span>
        <span class="k">if</span> <span class="n">var_keyword_argname</span><span class="p">:</span>  <span class="c1"># if there&#39;s a VAR_KEYWORD argument</span>
            <span class="k">if</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">index_of_var_keyword</span>
                <span class="c1"># TODO: Reflect on pros/cons of having mutable {} default here:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{})</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># TODO: Avoid this try catch. Look in advance for default ordering?</span>
            <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">())</span>
            <span class="n">result_sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="n">result_sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result_sig</span>


<div class="viewcode-block" id="call_forgivingly"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.call_forgivingly">[docs]</a><span class="k">def</span> <span class="nf">call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call function on given args and kwargs, but only taking what the function needs</span>
<span class="sd">    (not choking if they&#39;re extras variables)</span>

<span class="sd">    Tip: If you into trouble because your kwargs has a &#39;func&#39; key,</span>
<span class="sd">    (which would then clash with the ``func`` param of call_forgivingly), then</span>
<span class="sd">    use `_call_forgivingly` instead, specifying args and kwargs as tuple and</span>
<span class="sd">    dict.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b: int = 0, c=None) -&gt; int:</span>
<span class="sd">    ...     return &quot;foo&quot;, (a, b, c)</span>
<span class="sd">    &gt;&gt;&gt; call_forgivingly(</span>
<span class="sd">    ...     foo,  # the function you want to call</span>
<span class="sd">    ...     &quot;input for a&quot;,  # meant for a -- the first (and only) argument foo requires</span>
<span class="sd">    ...     c=42,  # skiping b and giving c a non-default value</span>
<span class="sd">    ...     intruder=&quot;argument&quot;,  # but wait, this argument name doesn&#39;t exist! Oh no!</span>
<span class="sd">    ... )  # well, as it happens, nothing bad -- the intruder argument is just ignored</span>
<span class="sd">    (&#39;foo&#39;, (&#39;input for a&#39;, 0, 42))</span>

<span class="sd">    An example of what happens when variadic kinds are involved:</span>

<span class="sd">    &gt;&gt;&gt; def bar(x, *args1, y=1, **kwargs1):</span>
<span class="sd">    ...     return x, args1, y, kwargs1</span>
<span class="sd">    &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)</span>
<span class="sd">    (1, (2, 3), 4, {&#39;z&#39;: 5})</span>

<span class="sd">    # &gt;&gt;&gt; def bar(x, y=1, **kwargs1):</span>
<span class="sd">    # ...     return x, y, kwargs1</span>
<span class="sd">    # &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)</span>
<span class="sd">    # (1, 4, {&#39;z&#39;: 5})</span>

<span class="sd">    # &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)</span>

<span class="sd">    # &gt;&gt;&gt; def bar(x, *args1, y=1):</span>
<span class="sd">    # ...     return x, args1, y</span>
<span class="sd">    # &gt;&gt;&gt; call_forgivingly(bar, 1, 2, 3, y=4, z=5)</span>
<span class="sd">    # (1, (2, 3), {&#39;z&#39;: 5})</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO: See if there&#39;s a more elegant way to do this</span>
<span class="k">def</span> <span class="nf">_call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper for _call_forgivingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">variadic_kinds</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">kind</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">VP</span><span class="p">,</span> <span class="n">VK</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">VP</span> <span class="ow">in</span> <span class="n">variadic_kinds</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="ow">and</span> <span class="n">VK</span> <span class="ow">in</span> <span class="n">variadic_kinds</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">variadic_kinds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">new_sig</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">_args</span> <span class="o">=</span> <span class="n">_args</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="p">,)</span>
        <span class="n">_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">VP</span> <span class="ow">in</span> <span class="n">variadic_kinds</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">elif</span> <span class="n">VK</span> <span class="ow">in</span> <span class="n">variadic_kinds</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="call_somewhat_forgivingly"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.call_somewhat_forgivingly">[docs]</a><span class="k">def</span> <span class="nf">call_somewhat_forgivingly</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SignatureAble</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Call function on given args and kwargs, but with controllable argument leniency.</span>
<span class="sd">    By default, the function will only pick from args and kwargs what matches it&#39;s</span>
<span class="sd">    signature, ignoring anything else in args and kwargs.</span>

<span class="sd">    But the real use of `call_somewhat_forgivingly` kicks in when you specify a</span>
<span class="sd">    `enforce_sig`: A signature (or any object that can be resolved into a signature</span>
<span class="sd">    through `Sig(enforce_sig)`) that will be used to bind the inputs, thus validating</span>
<span class="sd">    them against the `enforce_sig` signature (including extra arguments, defaults,</span>
<span class="sd">    etc.).</span>

<span class="sd">    `call_somewhat_forgivingly` helps you do this kind of thing systematically.</span>

<span class="sd">    &gt;&gt;&gt; f = lambda a: a * 11</span>
<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(f, (2,), {}) == f(2)</span>

<span class="sd">    In the above, we have no `enforce_sig`. The real use of call_somewhat_forgivingly</span>
<span class="sd">    is when we ask it to enforce a signature. Let&#39;s do this by specifying a function</span>
<span class="sd">    (no need for it to do anything: Only the signature is used.</span>

<span class="sd">    &gt;&gt;&gt; g = lambda a, b=None: ...</span>

<span class="sd">    Calling `f` on it&#39;s normal set of inputs (one input in this case) gives you the</span>
<span class="sd">    same thing as `f`:</span>

<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(f, (2,), {}, enforce_sig=g) == f(2)</span>
<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(f, (), {&#39;a&#39;: 2}, enforce_sig=g) == f(2)</span>

<span class="sd">    If you call with an extra positional argument, it will just be ignored.</span>

<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(f, (2, &#39;ignored&#39;), {}, enforce_sig=g) == f(2)</span>

<span class="sd">    If you call with a `b` keyword-argument (which matches `g`&#39;s signature,</span>
<span class="sd">    it will also be ignored.</span>

<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(</span>
<span class="sd">    ... f, (2,), {&#39;b&#39;: &#39;ignored&#39;}, enforce_sig=g</span>
<span class="sd">    ... ) == f(2)</span>
<span class="sd">    &gt;&gt;&gt; assert call_somewhat_forgivingly(</span>
<span class="sd">    ...     f, (), {&#39;a&#39;: 2, &#39;b&#39;: &#39;ignored&#39;}, enforce_sig=g</span>
<span class="sd">    ... ) == f(2)</span>

<span class="sd">    But if you call with three positional arguments (one more than g allows),</span>
<span class="sd">    or call with a keyword argument that is not in `g`&#39;s signature, it will</span>
<span class="sd">    raise a `TypeError`:</span>

<span class="sd">    &gt;&gt;&gt; call_somewhat_forgivingly(f,</span>
<span class="sd">    ...     (2, &#39;ignored&#39;, &#39;does_not_fit_g_signature_anymore&#39;), {}, enforce_sig=g</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: too many positional arguments</span>
<span class="sd">    &gt;&gt;&gt; call_somewhat_forgivingly(f,</span>
<span class="sd">    ...     (2,), {&#39;this_argname&#39;: &#39;is not in g&#39;}, enforce_sig=g</span>
<span class="sd">    ... )</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    TypeError: got an unexpected keyword argument &#39;this_argname&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">enforce_sig</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">enforce_sig</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">enforce_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># enforce the func&#39;s signature</span>
            <span class="c1"># this should be the same constraint level as calling the function itself.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enforce_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">enforce_sig</span><span class="p">)</span>
        <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">enforce_sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>
        <span class="k">return</span> <span class="n">_call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">_kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="kind_forgiving_func"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.kind_forgiving_func">[docs]</a><span class="k">def</span> <span class="nf">kind_forgiving_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a version of the function that has all POSITIONAL_OR_KEYWORD kinds</span>

<span class="sd">    The inspiring use case: Many builtins have restrictive parameter kinds which makes it hard to</span>
<span class="sd">    curry, amongst other such annoyances. For instance, say you want to curry</span>
<span class="sd">    `isinstance` to make a boolean function that detects string types.</span>
<span class="sd">    You can&#39;t with partial, because you can&#39;t access the position only</span>
<span class="sd">    `class_or_tuple` argument to fix it.</span>

<span class="sd">    Well, make a `kind_forgiving_func` version, and partial to your heart&#39;s content!</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; _isinstance = kind_forgiving_func(isinstance)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(_isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;asdf&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_kinds</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">Sig</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">})</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>
    <span class="k">return</span> <span class="n">_func</span></div>


<div class="viewcode-block" id="use_interface"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.use_interface">[docs]</a><span class="k">def</span> <span class="nf">use_interface</span><span class="p">(</span><span class="n">interface_sig</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Use interface_sig as (enforced/validated) signature of the decorated function.</span>
<span class="sd">    That is, the decorated function will use the original function has the backend,</span>
<span class="sd">    the function actually doing the work, but with a frontend specified</span>
<span class="sd">    (in looks and in argument validation) `interface_sig`</span>

<span class="sd">    consider the situation where are functionality is parametrized by a</span>
<span class="sd">    function `g` taking two inputs, `a`, and `b`.</span>
<span class="sd">    Now you want to carry out this functionality using a function `f` that does what</span>
<span class="sd">    `g` should do, but doesn&#39;t use `a`, and doesn&#39;t even have it in it&#39;s arguments.</span>

<span class="sd">    The solution to this is to _adapt_ `f` to the `g` interface:</span>
<span class="sd">    ```</span>
<span class="sd">    def my_g(a, b):</span>
<span class="sd">        return f(a)</span>
<span class="sd">    ```</span>
<span class="sd">    and use `my_g`.</span>

<span class="sd">    &gt;&gt;&gt; f = lambda a: a * 11</span>
<span class="sd">    &gt;&gt;&gt; interface = lambda a, b=None: ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; new_f = use_interface(interface)(f)</span>

<span class="sd">    See how only the first argument, or `a` keyword argument, is taken into account</span>
<span class="sd">    in `new_f`:</span>

<span class="sd">    &gt;&gt;&gt; assert new_f(2) == f(2)</span>
<span class="sd">    &gt;&gt;&gt; assert new_f(2, 3) == f(2)</span>
<span class="sd">    &gt;&gt;&gt; assert new_f(2, b=3) == f(2)</span>
<span class="sd">    &gt;&gt;&gt; assert new_f(b=3, a=2) == f(2)</span>

<span class="sd">    But if we add more positional arguments than `interface` allows,</span>
<span class="sd">    or any keyword arguments that `interface` doesn&#39;t recognize...</span>

<span class="sd">    &gt;&gt;&gt; new_f(1,2,3)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: too many positional arguments</span>
<span class="sd">    &gt;&gt;&gt; new_f(1, c=2)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: got an unexpected keyword argument &#39;c&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interface_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">interface_sig</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interface_wrapped_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@interface_sig</span>
        <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">interface_sig</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">_func</span>

    <span class="k">return</span> <span class="n">interface_wrapped_decorator</span></div>


<span class="kn">import</span> <span class="nn">inspect</span>


<div class="viewcode-block" id="has_signature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.has_signature">[docs]</a><span class="k">def</span> <span class="nf">has_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if an object has a signature -- i.e. is callable and inspect.signature(</span>
<span class="sd">    obj) returns something.</span>

<span class="sd">    This can be used to more easily get signatures in bulk without having to write</span>
<span class="sd">    try/catches:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; len(</span>
<span class="sd">    ...     list(</span>
<span class="sd">    ...         filter(</span>
<span class="sd">    ...             None,</span>
<span class="sd">    ...             map(</span>
<span class="sd">    ...                 partial(has_signature, robust=False),</span>
<span class="sd">    ...                 (Sig, print, map, filter, Sig.wrap),</span>
<span class="sd">    ...             ),</span>
<span class="sd">    ...         )</span>
<span class="sd">    ...     )</span>
<span class="sd">    ... )</span>
<span class="sd">    2</span>

<span class="sd">    If robust is set to True, `has_signature` will use `Sig` to get the signature,</span>
<span class="sd">    so will return True in most cases.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">robust</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">((</span><span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<span class="c1"># TODO: Need to define and use this function more carefully.</span>
<span class="c1">#   Is the goal to remove positional? Remove variadics? Normalize the signature?</span>
<div class="viewcode-block" id="all_pk_signature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.all_pk_signature">[docs]</a><span class="k">def</span> <span class="nf">all_pk_signature</span><span class="p">(</span><span class="n">callable_or_signature</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Signature</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Changes all (non-variadic) arguments to be of the PK (POSITION_OR_KEYWORD) kind.</span>

<span class="sd">    Wrapping a function with the resulting signature doesn&#39;t make that function callable</span>
<span class="sd">    with PK kinds in itself.</span>
<span class="sd">    It just gives it a signature without position and keyword ONLY kinds.</span>
<span class="sd">    It should be used to wrap such a function that actually carries out the</span>
<span class="sd">    implementation though!</span>

<span class="sd">    &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; new_foo = all_pk_signature(foo)</span>
<span class="sd">    &gt;&gt;&gt; Sig(new_foo)</span>
<span class="sd">    &lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; all_pk_signature(signature(foo))</span>
<span class="sd">    &lt;Sig (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>

<span class="sd">    But note that the variadic arguments *args and **kwargs remain variadic:</span>

<span class="sd">    &gt;&gt;&gt; all_pk_signature(signature(bar))</span>
<span class="sd">    &lt;Signature (*args, **kwargs)&gt;</span>

<span class="sd">    It works with `Sig` too (since Sig is a Signature), and maintains it&#39;s other</span>
<span class="sd">    attributes (like name).</span>

<span class="sd">    &gt;&gt;&gt; sig = all_pk_signature(Sig(bar))</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    &lt;Sig (*args, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; sig.name</span>
<span class="sd">    &#39;bar&#39;</span>

<span class="sd">    See also: ``i2.wrappers.nice_kinds``</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callable_or_signature</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">callable_or_signature</span>

        <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>

        <span class="n">new_sig</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">()),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">attrval</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_sig</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">attrval</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sig</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callable_or_signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">callable_or_signature</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>


<span class="c1"># Changed ch_signature_to_all_pk to all_pk_signature because ch_signature_to_all_pk</span>
<span class="c1"># was misleading: It doesn&#39;t change anything at all, it returns a constructed signature.</span>
<span class="c1"># It doesn&#39;t change all kinds to PK -- just the non-variadic ones.</span>
<span class="n">ch_signature_to_all_pk</span> <span class="o">=</span> <span class="n">all_pk_signature</span>  <span class="c1"># alias for back-compatibility</span>


<span class="k">def</span> <span class="nf">normalized_func</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">argument_values_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">arg_vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>

        <span class="n">poa</span><span class="p">,</span> <span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">(),</span> <span class="p">{},</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">arg_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">PO</span><span class="p">:</span>
                <span class="n">poa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">PK</span><span class="p">:</span>
                <span class="n">pka</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span><span class="p">:</span>
                <span class="n">vpa</span> <span class="o">=</span> <span class="n">val</span>  <span class="c1"># there can only be one VP!</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">KO</span><span class="p">:</span>
                <span class="n">koa</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">val</span><span class="p">})</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span><span class="p">:</span>
                <span class="n">vka</span> <span class="o">=</span> <span class="n">val</span>  <span class="c1"># there can only be one VK!</span>
        <span class="k">return</span> <span class="n">poa</span><span class="p">,</span> <span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span>

    <span class="k">def</span> <span class="nf">_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">poa</span><span class="p">,</span> <span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span> <span class="o">=</span> <span class="n">argument_values_tuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">poa</span><span class="p">,</span> <span class="o">*</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">)</span>
        <span class="n">_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_kwargs</span>

    <span class="c1"># @sig.modified(**{name: {&#39;kind&#39;: PK} for name in sig.names})</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># poa, pka, vpa, koa, vka = argument_values_tuple(args, kwargs)</span>
        <span class="c1"># print(poa, pka, vpa, koa, vka)</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_func</span>


<div class="viewcode-block" id="ch_variadics_to_non_variadic_kind"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.ch_variadics_to_non_variadic_kind">[docs]</a><span class="k">def</span> <span class="nf">ch_variadics_to_non_variadic_kind</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that will change a VAR_POSITIONAL (*args) argument to a tuple (args)</span>
<span class="sd">    argument of the same name.</span>

<span class="sd">    Essentially, given a `func(a, *b, c, **d)` function want to get a</span>
<span class="sd">    `new_func(a, b=(), c=None, d={})` that has the same functionality</span>
<span class="sd">    (in fact, calls the original `func` function behind the scenes), but without</span>
<span class="sd">    where the variadic arguments *b and **d are replaced with a `b` expecting an</span>
<span class="sd">    iterable (e.g. tuple/list) and `d` expecting a `dict` to contain the</span>
<span class="sd">    desired inputs.</span>

<span class="sd">    Besides this, the decorator tries to be as conservative as possible, making only</span>
<span class="sd">    the minimum changes needed to meet the goal of getting to a variadic-less</span>
<span class="sd">    interface. When it doubt, and error will be raised.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, *args, bar, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {args=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert str(Sig(foo)) == &#39;(a, *args, bar, **kwargs)&#39;</span>
<span class="sd">    &gt;&gt;&gt; wfoo = ch_variadics_to_non_variadic_kind(foo)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(wfoo))</span>
<span class="sd">    &#39;(a, args=(), *, bar, kwargs={})&#39;</span>

<span class="sd">    And now to do this:</span>

<span class="sd">    &gt;&gt;&gt; foo(1, 2, 3, bar=4, hello=&quot;world&quot;)</span>
<span class="sd">    &quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>

<span class="sd">    We can do it like this instead:</span>

<span class="sd">    &gt;&gt;&gt; wfoo(1, (2, 3), bar=4, kwargs=dict(hello=&quot;world&quot;))</span>
<span class="sd">    &quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>

<span class="sd">    Note, the outputs are the same. It&#39;s just the way we call our function that has</span>
<span class="sd">    changed.</span>

<span class="sd">    &gt;&gt;&gt; assert wfoo(1, (2, 3), bar=4, kwargs=dict(hello=&quot;world&quot;)</span>
<span class="sd">    ... ) == foo(1, 2, 3, bar=4, hello=&quot;world&quot;)</span>
<span class="sd">    &gt;&gt;&gt; assert wfoo(1, (2, 3), bar=4) == foo(1, 2, 3, bar=4)</span>
<span class="sd">    &gt;&gt;&gt; assert wfoo(1, (), bar=4) == foo(1, bar=4)</span>

<span class="sd">    Note that if there is not variadic positional arguments, the variadic keyword</span>
<span class="sd">    will still be a keyword-only kind.</span>

<span class="sd">    &gt;&gt;&gt; @ch_variadics_to_non_variadic_kind</span>
<span class="sd">    ... def func(a, bar=None, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(func))</span>
<span class="sd">    &#39;(a, bar=None, *, kwargs={})&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert func(1, bar=4, kwargs=dict(hello=&quot;world&quot;)</span>
<span class="sd">    ...     ) == &quot;a=1, bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>

<span class="sd">    If the function has neither variadic kinds, it will remain untouched.</span>

<span class="sd">    &gt;&gt;&gt; def func(a, /, b, *, c=3):</span>
<span class="sd">    ...     return a + b + c</span>
<span class="sd">    &gt;&gt;&gt; ch_variadics_to_non_variadic_kind(func) == func</span>
<span class="sd">    True</span>

<span class="sd">    If you only want the variadic positional to be handled, but leave leave any</span>
<span class="sd">    VARIADIC_KEYWORD kinds (**kwargs) alone, you can do so by setting</span>
<span class="sd">    `ch_variadic_keyword_to_keyword=False`.</span>
<span class="sd">    If you&#39;ll need to use `ch_variadics_to_non_variadic_kind` in such a way</span>
<span class="sd">    repeatedly, we suggest you use `functools.partial` to not have to specify this</span>
<span class="sd">    configuration repeatedly.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; tuple_the_args = partial(ch_variadics_to_non_variadic_kind,</span>
<span class="sd">    ...     ch_variadic_keyword_to_keyword=False</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; @tuple_the_args</span>
<span class="sd">    ... def foo(a, *args, bar=None, **kwargs):</span>
<span class="sd">    ...     return f&quot;{a=}, {args=}, {bar=}, {kwargs=}&quot;</span>
<span class="sd">    &gt;&gt;&gt; Sig(foo)</span>
<span class="sd">    &lt;Sig (a, args=(), *, bar=None, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; foo(1, (2, 3), bar=4, hello=&quot;world&quot;)</span>
<span class="sd">    &quot;a=1, args=(2, 3), bar=4, kwargs={&#39;hello&#39;: &#39;world&#39;}&quot;</span>




<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">ch_variadics_to_non_variadic_kind</span><span class="p">,</span>
            <span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="n">ch_variadic_keyword_to_keyword</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">idx_of_vp</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">index_of_var_positional</span>
    <span class="n">var_keyword_argname</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">var_keyword_name</span>

    <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">var_keyword_argname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># If the function has any variadic (position or keyword)...</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">variadic_less_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># extract from kwargs those inputs that need to be expressed positionally</span>
            <span class="n">_args</span><span class="p">,</span> <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># print(sig, kwargs, _args, _kwargs)</span>
            <span class="c1"># add these to the existing args</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="n">_args</span>

            <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># separate the args that are positional, variadic, and after variadic</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">_vp_args_</span><span class="p">,</span> <span class="n">args_after_vp</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">args</span><span class="p">[:</span><span class="n">idx_of_vp</span><span class="p">],</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">],</span>
                    <span class="n">args</span><span class="p">[</span><span class="n">idx_of_vp</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">args_after_vp</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FuncCallNotMatchingSignature</span><span class="p">(</span>
                        <span class="s1">&#39;There should be only keyword arguments after the Variadic &#39;</span>
                        <span class="s1">&#39;args. &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;Function was called with (positional=</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">, keywords=&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_kwargs</span><span class="si">}</span><span class="s1">)&#39;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">_vp_args_</span> <span class="o">=</span> <span class="n">args</span><span class="p">,</span> <span class="p">()</span>

            <span class="c1"># extract from the remaining _kwargs, the dict corresponding to the</span>
            <span class="c1"># variadic keywords, if any, since these need to be **-ed later</span>
            <span class="n">_var_keyword_kwargs</span> <span class="o">=</span> <span class="n">_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">var_keyword_argname</span><span class="p">,</span> <span class="p">{})</span>

            <span class="k">if</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="p">:</span>
                <span class="c1"># an extra level of extraction is needed in this case</span>
                <span class="c1"># _var_keyword_kwargs = _var_keyword_kwargs.pop(var_keyword_argname, {})</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_vp_args_</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">_var_keyword_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># call the original function with the unravelled args</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_vp_args_</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">_var_keyword_kwargs</span><span class="p">)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">params</span>

        <span class="k">if</span> <span class="n">var_keyword_argname</span><span class="p">:</span>  <span class="c1"># if there&#39;s a VAR_KEYWORD argument</span>
            <span class="k">if</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">index_of_var_keyword</span>
                <span class="c1"># TODO: Reflect on pros/cons of having mutable {} default here:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{})</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># TODO: Avoid this try catch. Look in advance for default ordering?</span>
            <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">())</span>
            <span class="n">variadic_less_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx_of_vp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">idx_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="n">variadic_less_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">variadic_less_func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span></div>


<span class="n">tuple_the_args</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">ch_variadics_to_non_variadic_kind</span><span class="p">,</span> <span class="n">ch_variadic_keyword_to_keyword</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
<span class="n">tuple_the_args</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;tuple_the_args&#39;</span>
<span class="n">tuple_the_args</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">A decorator that will change a VAR_POSITIONAL (*args) argument to a tuple (args)</span>
<span class="s1">argument of the same name.</span>
<span class="s1">&#39;&#39;&#39;</span>


<div class="viewcode-block" id="ch_func_to_all_pk"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.ch_func_to_all_pk">[docs]</a><span class="k">def</span> <span class="nf">ch_func_to_all_pk</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a decorated function where all arguments are of the PK kind.</span>
<span class="sd">    (PK: Positional_or_keyword)</span>

<span class="sd">    :param func: A callable</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; def f(a, /, b, *, c=None, **kwargs):</span>
<span class="sd">    ...     return a + b * c</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; print(Sig(f))</span>
<span class="sd">    (a, /, b, *, c=None, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; ff = ch_func_to_all_pk(f)</span>
<span class="sd">    &gt;&gt;&gt; print(Sig(ff))</span>
<span class="sd">    (a, b, c=None, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; ff(1, 2, 3)</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def g(x, y=1, *args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; print(Sig(g))</span>
<span class="sd">    (x, y=1, *args, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; gg = ch_func_to_all_pk(g)</span>
<span class="sd">    &gt;&gt;&gt; print(Sig(gg))</span>
<span class="sd">    (x, y=1, args=(), **kwargs)</span>

<span class="sd">    # &gt;&gt;&gt; def h(x, *y, z):</span>
<span class="sd">    # ...     print(f&quot;{x=}, {y=}, {z=}&quot;)</span>
<span class="sd">    # &gt;&gt;&gt; h(1, 2, 3, z=4)</span>
<span class="sd">    # x=1, y=(2, 3), z=4</span>
<span class="sd">    # &gt;&gt;&gt; hh = ch_func_to_all_pk(h)</span>
<span class="sd">    # &gt;&gt;&gt; hh(1, (2, 3), z=4)</span>
<span class="sd">    # x=1, y=(2, 3), z=4</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># _func = tuple_the_args(func)</span>
    <span class="c1"># sig = Sig(_func)</span>
    <span class="c1">#</span>
    <span class="c1"># @wraps(func)</span>
    <span class="c1"># def __func(*args, **kwargs):</span>
    <span class="c1">#     # b = Sig(_func).bind_partial(*args, **kwargs)</span>
    <span class="c1">#     # return _func(*b.args, **b.kwargs)</span>
    <span class="c1">#     args, kwargs = Sig(_func).extract_args_and_kwargs(</span>
    <span class="c1">#         *args, **kwargs, _ignore_kind=False</span>
    <span class="c1">#     )</span>
    <span class="c1">#     return _func(*args, **kwargs)</span>
    <span class="c1">#</span>
    <span class="n">_func</span> <span class="o">=</span> <span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span><span class="o">.</span><span class="n">extract_args_and_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="c1"># _ignore_kind=False,</span>
            <span class="c1"># _allow_partial=True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">__func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">all_pk_signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">__func</span></div>


<div class="viewcode-block" id="copy_func"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.copy_func">[docs]</a><span class="k">def</span> <span class="nf">copy_func</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy a function (not sure it works with all types of callables)&quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="p">(</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="p">,</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">argdefs</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span>
        <span class="n">closure</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__kwdefaults__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__signature__&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span>
    <span class="k">return</span> <span class="n">g</span></div>


<span class="c1"># TODO: Similar to other function in this module -- merge.</span>
<span class="k">def</span> <span class="nf">params_of</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">HasParams</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span>
    <span class="p">),</span> <span class="s1">&#39;obj needs to be a Iterable[Parameter] at this point&#39;</span>
    <span class="k">return</span> <span class="n">obj</span>  <span class="c1"># as is</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># TODO: Encorporate in Sig</span>
<div class="viewcode-block" id="insert_annotations"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.insert_annotations">[docs]</a><span class="k">def</span> <span class="nf">insert_annotations</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Signature</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert annotations in a signature.</span>
<span class="sd">    (Note: not really insert but returns a copy of input signature)</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; s = signature(lambda a, b, c=1, d=&quot;bar&quot;: 0)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; ss = insert_annotations(s, b=int, d=str)</span>
<span class="sd">    &gt;&gt;&gt; ss</span>
<span class="sd">    &lt;Signature (a, b: int, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; insert_annotations(s, b=int, d=str, e=list)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AssertionError: These argument names weren&#39;t found in the signature: {&#39;e&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;These argument names weren&#39;t found in the signature: &quot;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>


<div class="viewcode-block" id="common_and_diff_argnames"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.common_and_diff_argnames">[docs]</a><span class="k">def</span> <span class="nf">common_and_diff_argnames</span><span class="p">(</span><span class="n">func1</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">func2</span><span class="p">:</span> <span class="n">callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get list of argument names that are common to two functions, as well as the two</span>
<span class="sd">    lists of names that are different</span>

<span class="sd">    Args:</span>
<span class="sd">        func1: First function</span>
<span class="sd">        func2: Second function</span>

<span class="sd">    Returns: A dict with fields &#39;common&#39;, &#39;func1_not_func2&#39;, and &#39;func2_not_func1&#39;</span>

<span class="sd">    &gt;&gt;&gt; def f(t, h, i, n, k):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def g(t, w, i, c, e):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(f, g)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;], &#39;func2_not_func1&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(g, f)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;], &#39;func2_not_func1&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func2</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;common&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func1_not_func2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func2_not_func1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">],</span>
    <span class="p">}</span></div>


<span class="n">dflt_name_for_kind</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">arg_order_for_param_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="set_signature_of_func"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.set_signature_of_func">[docs]</a><span class="k">def</span> <span class="nf">set_signature_of_func</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the signature of a function, with sugar.</span>

<span class="sd">    Args:</span>
<span class="sd">        func: Function whose signature you want to set</span>
<span class="sd">        signature: A list of parameter specifications. This could be an</span>
<span class="sd">        inspect.Parameter object or anything that</span>
<span class="sd">            the mk_param function can resolve into an inspect.Parameter object.</span>
<span class="sd">        return_annotation: Passed on to inspect.Signature.</span>
<span class="sd">        __validate_parameters__: Passed on to inspect.Signature.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None (but sets the signature of the input function)</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def foo(*args, **kwargs):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (*args, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(</span>
<span class="sd">    ...     foo, [&quot;a&quot;, (&quot;b&quot;, None), (&quot;c&quot;, 42, int)]</span>
<span class="sd">    ... )  # specifying defaults and annotations</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b=None, c: int = 42)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(</span>
<span class="sd">    ...     foo, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], return_annotation=str</span>
<span class="sd">    ... )  # specifying return annotation</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c) -&gt; str&gt;</span>
<span class="sd">    &gt;&gt;&gt; # But you can always specify parameters the &quot;long&quot; way</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(</span>
<span class="sd">    ...     foo,</span>
<span class="sd">    ...     [inspect.Parameter(name=&quot;kws&quot;, kind=inspect.Parameter.VAR_KEYWORD)],</span>
<span class="sd">    ...     return_annotation=str,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (**kws) -&gt; str&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
        <span class="n">parameters</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>
    <span class="c1"># Not returning func so it&#39;s clear(er) that the function is transformed in place</span>


<span class="c1"># Pattern: (rewiring) wrapper of make_dataclass</span>
<span class="c1"># TODO: Is there a clean way for module to be populated by __name__ of caller module?</span>
<div class="viewcode-block" id="sig_to_dataclass"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.sig_to_dataclass">[docs]</a><span class="k">def</span> <span class="nf">sig_to_dataclass</span><span class="p">(</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">cls_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(),</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a ``class`` (through ``make_dataclass``) from the given signature.</span>

<span class="sd">    :param sig: A ``SignatureAble``, that is, anything that ensure_signature can</span>
<span class="sd">        resolve into an ``inspect.Signature`` object, including a signature object</span>
<span class="sd">        itself, but also most callables, a list or params, etc.</span>
<span class="sd">    :param cls_name: The same as ``cls_name`` of ``dataclasses.make_dataclass``</span>
<span class="sd">    :param bases: The same as ``bases`` of ``dataclasses.make_dataclass``</span>
<span class="sd">    :param module: Set to module (usually ``__name__`` to specify ther module of</span>
<span class="sd">        caller) so that the class and instances can be pickle-able.</span>
<span class="sd">    :param kwargs: Passed on to ``dataclasses.make_dataclass``</span>
<span class="sd">    :return: A dataclass</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, /, b : int=2, *, c=3):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; K = sig_to_dataclass(foo, cls_name=&#39;K&#39;)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(K))</span>
<span class="sd">    &#39;(a, b: int = 2, c=3) -&gt; None&#39;</span>
<span class="sd">    &gt;&gt;&gt; k = K(1,2,3)</span>
<span class="sd">    &gt;&gt;&gt; (k.a, k.b, k.c)</span>
<span class="sd">    (1, 2, 3)</span>

<span class="sd">    Would also work with any of these (and more):</span>

<span class="sd">    &gt;&gt;&gt; K = sig_to_dataclass(Sig(foo), cls_name=&#39;K&#39;)</span>
<span class="sd">    &gt;&gt;&gt; K = sig_to_dataclass(Sig(foo).params, cls_name=&#39;K&#39;)</span>

<span class="sd">    Note: ``cls_name`` is not required (we&#39;ll try to figure out a good default for you),</span>
<span class="sd">    but it&#39;s advised to only use this convenience in extreme mode.</span>
<span class="sd">    Choosing your own name might make for a safer future if you&#39;re reusing your class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">make_dataclass</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">ensure_signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">cls_name</span> <span class="o">=</span> <span class="n">cls_name</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;_made_by_sig_to_dataclass&#39;</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">module</span><span class="p">:</span>
        <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">module</span>
    <span class="k">return</span> <span class="bp">cls</span></div>


<span class="c1">#########################################################################################</span>
<span class="c1"># Manual construction of missing signatures</span>
<span class="c1"># ############################################################################</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">sigs_for_sigless_builtin_name</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;__build_class__&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># __build_class__(func, name, /, *bases, [metaclass], **kwds) -&gt; class</span>
    <span class="s1">&#39;__import__&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span>
    <span class="s1">&#39;bool&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bool(x) -&gt; bool</span>
    <span class="s1">&#39;breakpoint&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># breakpoint(*args, **kws)</span>
    <span class="s1">&#39;bytearray&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bytearray(iterable_of_ints) -&gt; bytearray</span>
    <span class="c1"># bytearray(string, encoding[, errors]) -&gt; bytearray</span>
    <span class="c1"># bytearray(bytes_or_buffer) -&gt; mutable copy of bytes_or_buffer</span>
    <span class="c1"># bytearray(int) -&gt; bytes array of size given by the parameter initialized with</span>
    <span class="c1"># null bytes</span>
    <span class="c1"># bytearray() -&gt; empty bytes array</span>
    <span class="s1">&#39;bytes&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bytes(iterable_of_ints) -&gt; bytes</span>
    <span class="c1"># bytes(string, encoding[, errors]) -&gt; bytes</span>
    <span class="c1"># bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer</span>
    <span class="c1"># bytes(int) -&gt; bytes object of size given by the parameter initialized with null</span>
    <span class="c1"># bytes</span>
    <span class="c1"># bytes() -&gt; empty bytes object</span>
    <span class="s1">&#39;classmethod&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># classmethod(function) -&gt; method</span>
    <span class="s1">&#39;dict&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># dict() -&gt; new empty dictionary</span>
    <span class="c1"># dict(mapping) -&gt; new dictionary initialized from a mapping object&#39;s</span>
    <span class="c1"># dict(iterable) -&gt; new dictionary initialized as if via:</span>
    <span class="c1"># dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs</span>
    <span class="s1">&#39;dir&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># dir([object]) -&gt; list of strings</span>
    <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="n">signature</span><span class="p">(</span><span class="k">lambda</span> <span class="n">function</span><span class="p">,</span> <span class="n">iterable</span><span class="p">:</span> <span class="o">...</span><span class="p">),</span>
    <span class="c1"># filter(function or None, iterable) --&gt; filter object</span>
    <span class="s1">&#39;frozenset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># frozenset() -&gt; empty frozenset object</span>
    <span class="c1"># frozenset(iterable) -&gt; frozenset object</span>
    <span class="s1">&#39;getattr&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># getattr(object, name[, default]) -&gt; value</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># int([x]) -&gt; integer</span>
    <span class="c1"># int(x, base=10) -&gt; integer</span>
    <span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># iter(iterable) -&gt; iterator</span>
    <span class="c1"># iter(callable, sentinel) -&gt; iterator</span>
    <span class="s1">&#39;map&#39;</span><span class="p">:</span> <span class="n">signature</span><span class="p">(</span><span class="k">lambda</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">iterables</span><span class="p">:</span> <span class="o">...</span><span class="p">),</span>
    <span class="c1"># map(func, *iterables) --&gt; map object</span>
    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># max(iterable, *[, default=obj, key=func]) -&gt; value</span>
    <span class="c1"># max(arg1, arg2, *args, *[, key=func]) -&gt; value</span>
    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># min(iterable, *[, default=obj, key=func]) -&gt; value</span>
    <span class="c1"># min(arg1, arg2, *args, *[, key=func]) -&gt; value</span>
    <span class="s1">&#39;next&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># next(iterator[, default])</span>
    <span class="s1">&#39;print&#39;</span><span class="p">:</span> <span class="n">signature</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">False</span><span class="p">:</span> <span class="o">...</span>
    <span class="p">),</span>
    <span class="c1"># print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</span>
    <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># range(stop) -&gt; range object</span>
    <span class="c1"># range(start, stop[, step]) -&gt; range object</span>
    <span class="s1">&#39;set&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># set() -&gt; new empty set object</span>
    <span class="c1"># set(iterable) -&gt; new set object</span>
    <span class="s1">&#39;slice&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># slice(stop)</span>
    <span class="c1"># slice(start, stop[, step])</span>
    <span class="s1">&#39;staticmethod&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># staticmethod(function) -&gt; method</span>
    <span class="s1">&#39;str&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># str(object=&#39;&#39;) -&gt; str</span>
    <span class="c1"># str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span>
    <span class="s1">&#39;super&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># super() -&gt; same as super(__class__, &lt;first argument&gt;)</span>
    <span class="c1"># super(type) -&gt; unbound super object</span>
    <span class="c1"># super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span>
    <span class="c1"># super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span>
    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># type(object_or_name, bases, dict)</span>
    <span class="c1"># type(object) -&gt; the object&#39;s type</span>
    <span class="c1"># type(name, bases, dict) -&gt; a new type</span>
    <span class="s1">&#39;vars&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># vars([object]) -&gt; dictionary</span>
    <span class="s1">&#39;zip&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># zip(*iterables) --&gt; A zip object yielding tuples until an input is exhausted.</span>
<span class="p">}</span>

<span class="c1">############# Tools for testing #########################################################</span>


<div class="viewcode-block" id="param_for_kind"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.param_for_kind">[docs]</a><span class="k">def</span> <span class="nf">param_for_kind</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;positional_or_keyword&#39;</span><span class="p">,</span>
    <span class="n">with_default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">annotation</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to easily and flexibly make inspect.Parameter objects for testing.</span>

<span class="sd">    It&#39;s annoying to have to compose parameters from scratch to testing things.</span>
<span class="sd">    This tool should help making it less annoying.</span>

<span class="sd">    &gt;&gt;&gt; list(map(param_for_kind, param_kinds))</span>
<span class="sd">    [&lt;Parameter &quot;POSITIONAL_ONLY&quot;&gt;, &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;, &lt;Parameter &quot;VAR_POSITIONAL&quot;&gt;, &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;, &lt;Parameter &quot;VAR_KEYWORD&quot;&gt;]</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword()</span>
<span class="sd">    &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword(&quot;foo&quot;)</span>
<span class="sd">    &lt;Parameter &quot;foo&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only()</span>
<span class="sd">    &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only(&quot;baz&quot;, with_default=True)</span>
<span class="sd">    &lt;Parameter &quot;baz=&#39;dflt_keyword_only&#39;&quot;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">kind_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind_obj</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">default</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;dflt_</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">with_default</span> <span class="ow">and</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;var_positional&#39;</span><span class="p">,</span> <span class="s1">&#39;var_keyword&#39;</span><span class="p">}</span>
        <span class="k">else</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind_obj</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>


<span class="n">param_kinds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>

<span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">param_kinds</span><span class="p">:</span>
    <span class="n">lower_kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">))</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">),</span>
        <span class="s1">&#39;with_default&#39;</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">),</span>
        <span class="n">lower_kind</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>

<span class="c1">###########################</span>
<span class="c1"># Signature Compatibility #</span>
<span class="c1">###########################</span>

<span class="c1"># TODO: Implement annotation compatibility</span>
<span class="k">def</span> <span class="nf">is_annotation_compatible_with</span><span class="p">(</span><span class="n">annot1</span><span class="p">,</span> <span class="n">annot2</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span> <span class="nf">is_default_value_compatible_with</span><span class="p">(</span><span class="n">dflt1</span><span class="p">,</span> <span class="n">dflt2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">dflt1</span> <span class="ow">is</span> <span class="n">empty</span> <span class="ow">or</span> <span class="n">dflt2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span>


<div class="viewcode-block" id="is_param_compatible_with"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.is_param_compatible_with">[docs]</a><span class="k">def</span> <span class="nf">is_param_compatible_with</span><span class="p">(</span>
    <span class="n">p1</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span>
    <span class="n">p2</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span>
    <span class="n">annotation_comparator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">default_value_comparator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return True if ``p1`` is compatible with ``p2``. Meaning that any value valid</span>
<span class="sd">    for ``p1`` is valid for ``p2``.</span>

<span class="sd">    :param p1: The main parameter.</span>
<span class="sd">    :param p2: The parameter to be compared with.</span>
<span class="sd">    :param annotation_comparator: The function used to compare the annotations</span>
<span class="sd">    :param default_value_comparator: The function used to compare the default values</span>

<span class="sd">    &gt;&gt;&gt; is_param_compatible_with(</span>
<span class="sd">    ...     Parameter(&#39;a&#39;, PO),</span>
<span class="sd">    ...     Parameter(&#39;b&#39;, PO)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_param_compatible_with(</span>
<span class="sd">    ...     Parameter(&#39;a&#39;, PO),</span>
<span class="sd">    ...     Parameter(&#39;b&#39;, PO, default=0)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_param_compatible_with(</span>
<span class="sd">    ...     Parameter(&#39;a&#39;, PO, default=0),</span>
<span class="sd">    ...     Parameter(&#39;b&#39;, PO)</span>
<span class="sd">    ... )</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">annotation_comparator</span> <span class="o">=</span> <span class="n">annotation_comparator</span> <span class="ow">or</span> <span class="n">is_annotation_compatible_with</span>
    <span class="n">default_value_comparator</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">default_value_comparator</span> <span class="ow">or</span> <span class="n">is_default_value_compatible_with</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">annotation_comparator</span><span class="p">(</span>
        <span class="n">p1</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">annotation</span>
    <span class="p">)</span> <span class="ow">and</span> <span class="n">default_value_comparator</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">p2</span><span class="o">.</span><span class="n">default</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_call_compatible_with"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.is_call_compatible_with">[docs]</a><span class="k">def</span> <span class="nf">is_call_compatible_with</span><span class="p">(</span>
    <span class="n">sig1</span><span class="p">:</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">sig2</span><span class="p">:</span> <span class="n">Sig</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">param_comparator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Return True if ``sig1`` is compatible with ``sig2``. Meaning that all valid ways</span>
<span class="sd">    to call ``sig1`` are valid for ``sig2``.</span>

<span class="sd">    :param sig1: The main signature.</span>
<span class="sd">    :param sig2: The signature to be compared with.</span>
<span class="sd">    :param param_comparator: The function used to compare two parameters</span>

<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, b, *, c)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a, b, c)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;()&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;()&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a=0)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, *, c)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a, /, b, *, c)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, *, c)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a, /, b=0, *, c)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, b)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a, /, b, *, c)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, b)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(a, /, b, *, c=0)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_call_compatible_with(</span>
<span class="sd">    ...     Sig(&#39;(a, /, b, *, c)&#39;),</span>
<span class="sd">    ...     Sig(&#39;(*args, **kwargs)&#39;)</span>
<span class="sd">    ... )</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">validate_variadics</span><span class="p">():</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="c1"># sig1 can only have a VP if sig2 also has one</span>
            <span class="p">(</span><span class="n">vp1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vp2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="ow">and</span>
            <span class="c1"># sig1 can only have a VK if sig2 also has one</span>
            <span class="p">(</span><span class="n">vk1</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">vk2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate_param_counts</span><span class="p">():</span>
        <span class="c1"># sig1 cannot have more positional params than sig2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps2</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vp2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># sig1 cannot have keyword params that do not exist in sig2</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ks1</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ks2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vk2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">validate_extra_params</span><span class="p">():</span>
        <span class="c1"># Any extra PO in sig2 must have a default value</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">pos2</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span> <span class="p">:]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Any extra PK in sig2 must have its corresponding PO or KO in sig1, or a</span>
        <span class="c1"># default value</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pks2</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pks1</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos2</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span>
                <span class="ow">and</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kos1</span>
                <span class="ow">and</span> <span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">empty</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Any extra KO in sig2 must have a default value</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">kos2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kos1</span> <span class="ow">and</span> <span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">validate_param_positions</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ks1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">n2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="c1"># It can be a PK in sig1 and a P (PO or PK) in sig2 only if</span>
                        <span class="c1"># its position in sig2 is &gt;= to its position in sig1</span>
                        <span class="p">(</span><span class="n">n1</span> <span class="ow">in</span> <span class="n">pks1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                        <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">n1</span> <span class="ow">in</span> <span class="n">kos1</span>
                            <span class="ow">and</span> <span class="p">(</span>
                                <span class="c1"># Cannot be a KO in sig1 and a PO in sig2</span>
                                <span class="n">n2</span> <span class="ow">in</span> <span class="n">pos2</span>
                                <span class="ow">or</span>
                                <span class="c1"># It can be a KO in sig1 and a PK in sig2 only if its</span>
                                <span class="c1"># position in sig2 is &gt; than the total number of POs</span>
                                <span class="c1"># and PKs in sig1</span>
                                <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps1</span><span class="p">)</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">):</span>
                        <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">validate_param_compatibility</span><span class="p">():</span>
        <span class="c1"># Every positional param in sig1 must be compatible with its</span>
        <span class="c1"># correspondant param in sig2 (at the same index).</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ps1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps2</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">param_comparator</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sig2</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Every keyword param in sig1 must be compatible with its</span>
        <span class="c1"># correspondant param in sig2 (with the same name).</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ks1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">ks2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">param_comparator</span><span class="p">(</span>
                <span class="n">sig1</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">param_comparator</span> <span class="o">=</span> <span class="n">param_comparator</span> <span class="ow">or</span> <span class="n">is_param_compatible_with</span>

    <span class="n">pos1</span><span class="p">,</span> <span class="n">pks1</span><span class="p">,</span> <span class="n">vp1</span><span class="p">,</span> <span class="n">kos1</span><span class="p">,</span> <span class="n">vk1</span> <span class="o">=</span> <span class="n">sig1</span><span class="o">.</span><span class="n">detail_names_by_kind</span><span class="p">()</span>
    <span class="n">ps1</span> <span class="o">=</span> <span class="n">pos1</span> <span class="o">+</span> <span class="n">pks1</span>
    <span class="n">ks1</span> <span class="o">=</span> <span class="n">pks1</span> <span class="o">+</span> <span class="n">kos1</span>
    <span class="n">pos2</span><span class="p">,</span> <span class="n">pks2</span><span class="p">,</span> <span class="n">vp2</span><span class="p">,</span> <span class="n">kos2</span><span class="p">,</span> <span class="n">vk2</span> <span class="o">=</span> <span class="n">sig2</span><span class="o">.</span><span class="n">detail_names_by_kind</span><span class="p">()</span>
    <span class="n">ps2</span> <span class="o">=</span> <span class="n">pos2</span> <span class="o">+</span> <span class="n">pks2</span>
    <span class="n">ks2</span> <span class="o">=</span> <span class="n">pks2</span> <span class="o">+</span> <span class="n">kos2</span>

    <span class="k">if</span> <span class="n">vp1</span><span class="p">:</span>
        <span class="n">sig1</span> <span class="o">-=</span> <span class="n">vp1</span>
    <span class="k">if</span> <span class="n">vk1</span><span class="p">:</span>
        <span class="n">sig1</span> <span class="o">-=</span> <span class="n">vk1</span>
    <span class="k">if</span> <span class="n">vp2</span><span class="p">:</span>
        <span class="n">sig2</span> <span class="o">-=</span> <span class="n">vp2</span>
    <span class="k">if</span> <span class="n">vk2</span><span class="p">:</span>
        <span class="n">sig2</span> <span class="o">-=</span> <span class="n">vk2</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">validate_variadics</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">validate_param_counts</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">validate_extra_params</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">validate_param_positions</span><span class="p">()</span>
        <span class="ow">and</span> <span class="n">validate_param_compatibility</span><span class="p">()</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>