
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dol.signatures &#8212; dol 0.1.20 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for dol.signatures</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Signature calculus&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">unwrap</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span> <span class="k">as</span> <span class="n">MappingType</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">update_wrapper</span>

<span class="n">_empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

<span class="n">_ParameterKind</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
    <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;param_kind&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">ParamsType</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
<span class="n">ParamsAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParamsType</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span>
<span class="n">SignatureAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">ParamsType</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]]</span>
<span class="n">HasParams</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span> <span class="n">MappingType</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">],</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>

<span class="c1"># short hands for Parameter kinds</span>
<span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">VP</span><span class="p">,</span> <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
<span class="n">PO</span><span class="p">,</span> <span class="n">KO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">var_param_kinds</span> <span class="o">=</span> <span class="p">{</span><span class="n">VP</span><span class="p">,</span> <span class="n">VK</span><span class="p">}</span>
<span class="n">var_param_types</span> <span class="o">=</span> <span class="n">var_param_kinds</span>  <span class="c1"># Deprecate: for back-compatibility. Delete in 2021</span>

<span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span> <span class="o">=</span> <span class="s1">&#39;strict&#39;</span>

<span class="c1"># TODO: Couldn&#39;t make this work. See https://www.python.org/dev/peps/pep-0562/</span>
<span class="c1"># deprecated_names = {&#39;assure_callable&#39;, &#39;assure_signature&#39;, &#39;assure_params&#39;}</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def __getattr__(name):</span>
<span class="c1">#     print(name)</span>
<span class="c1">#     if name in deprecated_names:</span>
<span class="c1">#         from warnings import warn</span>
<span class="c1">#         warn(f&quot;{name} is deprecated (see code for new name -- look for aliases)&quot;, DeprecationWarning)</span>
<span class="c1">#     raise AttributeError(f&quot;module {__name__} has no attribute {name}&quot;)</span>


<div class="viewcode-block" id="name_of_obj"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.name_of_obj">[docs]</a><span class="k">def</span> <span class="nf">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tries to find the (or &quot;a&quot;) name for an object, even if `__name__` doesn&#39;t exist.</span>

<span class="sd">    &gt;&gt;&gt; name_of_obj(map)</span>
<span class="sd">    &#39;map&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj([1, 2, 3])</span>
<span class="sd">    &#39;list&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(print)</span>
<span class="sd">    &#39;print&#39;</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(lambda x: x)</span>
<span class="sd">    &#39;&lt;lambda&gt;&#39;</span>
<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; name_of_obj(partial(print, sep=&#39;,&#39;))</span>
<span class="sd">    &#39;print&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;partial&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;func&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">ensure_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Empty function made just to carry a signature&quot;&quot;&quot;</span>

        <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>


<span class="n">assure_callable</span> <span class="o">=</span> <span class="n">ensure_callable</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">(</span><span class="n">obj</span><span class="p">,))</span>
    <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="p">())</span>
    <span class="c1"># if you get this far...</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into a Signature: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="n">assure_signature</span> <span class="o">=</span> <span class="n">ensure_signature</span>  <span class="c1"># alias for backcompatibility</span>


<span class="k">def</span> <span class="nf">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="o">**</span><span class="n">p</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">dflt_and_annotation</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Param</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="o">**</span><span class="n">dflt_and_annotation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2"> into a Parameter object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_params_from_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">:</span> <span class="n">MappingType</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">MappingType</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">v</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;In a mapping specification of a params, &#39;</span>
                        <span class="sa">f</span><span class="s2">&quot;either the &#39;name&#39; of the val shouldn&#39;t be specified, &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;or it should be the same as the key (</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">): &#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                    <span class="k">yield</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">k</span>
                <span class="k">yield</span> <span class="n">v</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="ensure_params"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.ensure_params">[docs]</a><span class="k">def</span> <span class="nf">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get an interable of Parameter instances from an object.</span>

<span class="sd">    :param obj:</span>
<span class="sd">    :return:</span>

<span class="sd">    From a callable:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; ensure_params(f)</span>
<span class="sd">    [&lt;Parameter &quot;w&quot;&gt;, &lt;Parameter &quot;x: float = 1&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z: int = 1&quot;&gt;]</span>

<span class="sd">    From an iterable of strings, dicts, or tuples</span>

<span class="sd">    &gt;&gt;&gt; ensure_params([&#39;xyz&#39;,</span>
<span class="sd">    ...     (&#39;b&#39;, Parameter.empty, int), # if you want an annotation without a default use Parameter.empty</span>
<span class="sd">    ...     (&#39;c&#39;, 2),  # if you just want a default, make it the second element of your tuple</span>
<span class="sd">    ...     dict(name=&#39;d&#39;, kind=Parameter.VAR_KEYWORD)])  # all kinds are by default PK: Use dict to specify otherwise.</span>
<span class="sd">    [&lt;Param &quot;xyz&quot;&gt;, &lt;Param &quot;b: int&quot;&gt;, &lt;Param &quot;c=2&quot;&gt;, &lt;Param &quot;**d&quot;&gt;]</span>


<span class="sd">    If no input is given, an empty list is returned.</span>

<span class="sd">    &gt;&gt;&gt; ensure_params()  # equivalent to ensure_params(None)</span>
<span class="sd">    []</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># obj = inspect.unwrap(obj, stop=(lambda f: hasattr(f, &quot;__signature__&quot;)))</span>

    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
        <span class="c1"># TODO: Can do better here! See attempt in _params_from_mapping:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_params_from_mapping</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="c1"># obj = list(obj.values())</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]}]</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;annotation&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">]}]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: put this in function that has more kind resolution power</span>
            <span class="c1">#  e.g. if a KEYWORD_ONLY arg was encountered, all subsequent</span>
            <span class="c1">#  have to be unless otherwise specified.</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">ensure_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">([</span><span class="n">obj</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="c1"># if nothing above worked, perhaps you have a wrapped object? Try unwrapping until you find a signature...</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__signature__&#39;</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># if function didn&#39;t return at this point, it didn&#39;t find a match, so raise a TypeError</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to make that object into an iterable of inspect.Parameter objects: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<span class="n">assure_params</span> <span class="o">=</span> <span class="n">ensure_params</span>  <span class="c1"># alias for backcompatibility</span>


<div class="viewcode-block" id="MissingArgValFor"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.MissingArgValFor">[docs]</a><span class="k">class</span> <span class="nc">MissingArgValFor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A simple class to wrap an argument name, indicating that it was missing somewhere.</span>
<span class="sd">    &gt;&gt;&gt; MissingArgValFor(&#39;argname&#39;)</span>
<span class="sd">    MissingArgValFor(&quot;argname&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">argname</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">argname</span> <span class="o">=</span> <span class="n">argname</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;MissingArgValFor(&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">argname</span><span class="si">}</span><span class="s1">&quot;)&#39;</span></div>


<span class="c1"># TODO: Look into the handling of the Parameter.VAR_KEYWORD kind in params</span>
<div class="viewcode-block" id="extract_arguments"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.extract_arguments">[docs]</a><span class="k">def</span> <span class="nf">extract_arguments</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;return&#39;</span><span class="p">,</span>
    <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract arguments needed to satisfy the params of a callable, dealing with the dirty details.</span>

<span class="sd">    Returns an (param_args, param_kwargs, remaining_kwargs) tuple where</span>
<span class="sd">    - param_args are the values of kwargs that are PO (POSITION_ONLY) as defined by params,</span>
<span class="sd">    - param_kwargs are those names that are both in params and not in param_args, and</span>
<span class="sd">    - remaining_kwargs are the remaining.</span>

<span class="sd">    Intended usage: When you need to call a function `func` that has some position-only arguments,</span>
<span class="sd">    but you have a kwargs dict of arguments in your hand. You can&#39;t just to `func(**kwargs)`.</span>
<span class="sd">    But you can (now) do</span>
<span class="sd">    ```</span>
<span class="sd">    args, kwargs, remaining = extract_arguments(kwargs, func)  # extract from kwargs what you need for func</span>
<span class="sd">    # ... check if remaing is empty (or not, depending on your paranoia), and then call the func:</span>
<span class="sd">    func(*args, **kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    (And if you doing that a lot: Do put it in a decorator!)</span>

<span class="sd">    See Also: extract_arguments.without_remainding</span>

<span class="sd">    The most frequent case you&#39;ll encounter is when there&#39;s no POSITION_ONLY args, your param_args will be empty</span>
<span class="sd">    and you param_kwargs will contain all the arguments that match params, in the order of these params.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((), {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    But sometimes you do have POSITION_ONLY arguments.</span>
<span class="sd">    What extract_arguments will do for you is return the value of these as the first element of</span>
<span class="sd">    the triple.</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    Note above how we get `(1, 2, 3)`, the order defined by the func&#39;s signature,</span>
<span class="sd">    instead of `(2, 1, 3)`, the order defined by the kwargs.</span>
<span class="sd">    So it&#39;s the params (e.g. function signature) that determine the order, not kwargs.</span>
<span class="sd">    When using to call a function, this is especially crucial if we use POSITION_ONLY arguments.</span>

<span class="sd">    See also that the third output, the remaining_kwargs, as `{&#39;extra&#39;: &#39;stuff&#39;}` since</span>
<span class="sd">    it was not in the params of the function.</span>
<span class="sd">    Even if you include a VAR_KEYWORD kind of argument in the function, it won&#39;t change</span>
<span class="sd">    this behavior.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4}, {&#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    This is because we don&#39;t want to assume that all the kwargs can actually be</span>
<span class="sd">    included in a call to the function behind the params.</span>
<span class="sd">    Instead, the user can chose whether to include the remainder by doing a:</span>
<span class="sd">    ```</span>
<span class="sd">    param_kwargs.update(remaining_kwargs)</span>
<span class="sd">    ```</span>
<span class="sd">    et voil√†.</span>

<span class="sd">    That said, we do understand that it may be a common pattern, so we&#39;ll do that extra step for you</span>
<span class="sd">    if you specify `include_all_when_var_keywords_in_params=True`.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;,</span>
<span class="sd">    ...                     include_all_when_var_keywords_in_params=True)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;}, {})</span>

<span class="sd">    If you&#39;re expecting no remainder you might want to just get the args and kwargs (not this third</span>
<span class="sd">    expected-to-be-empty remainder). You have two ways to do that, specifying:</span>
<span class="sd">        `what_to_do_with_remainding=&#39;ignore&#39;`, which will just return the (args, kwargs) pair</span>
<span class="sd">        `what_to_do_with_remainding=&#39;assert_empty&#39;`, which will do the same, but first assert the remainder is empty</span>
<span class="sd">    We suggest to use `functools.partial` to configure the `argument_argument` you need.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor = partial(extract_arguments,</span>
<span class="sd">    ...     what_to_do_with_remainding=&#39;assert_empty&#39;,</span>
<span class="sd">    ...     include_all_when_var_keywords_in_params=True)</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; arg_extractor(f, b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    ((1, 2, 3), {&#39;d&#39;: 4, &#39;extra&#39;: &#39;stuff&#39;})</span>

<span class="sd">    And what happens if the kwargs doesn&#39;t contain all the POSITION_ONLY arguments?</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=None, /, d=0): ...</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(f, b=2, d=&#39;is a kw arg&#39;, e=&#39;is not an arg at all&#39;)</span>
<span class="sd">    ((MissingArgValFor(&quot;a&quot;), 2, MissingArgValFor(&quot;c&quot;)), {&#39;d&#39;: &#39;is a kw arg&#39;}, {&#39;e&#39;: &#39;is not an arg at all&#39;})</span>

<span class="sd">    A few more examples...</span>

<span class="sd">    Let&#39;s call `extract_arguments` with params being not a function,</span>
<span class="sd">    but, a Signature instance, a mapping whose values are Parameter instances,</span>
<span class="sd">    or an iterable of Parameter instances...</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b,  /, c=None, *, d=0, **kws): ...</span>
<span class="sd">    &gt;&gt;&gt; sig = Signature.from_callable(func)</span>
<span class="sd">    &gt;&gt;&gt; param_map = sig.parameters</span>
<span class="sd">    &gt;&gt;&gt; param_iterable = param_map.values()</span>
<span class="sd">    &gt;&gt;&gt; kwargs = dict(b=2, a=1, c=3, d=4, extra=&#39;stuff&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(sig, **kwargs) == extract_arguments(func, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_map, **kwargs) == extract_arguments(func, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; assert extract_arguments(param_iterable, **kwargs) == extract_arguments(func, **kwargs)</span>

<span class="sd">    Edge case:</span>
<span class="sd">    No params specified? No problem. You&#39;ll just get empty args and kwargs. Everything in the remainder</span>
<span class="sd">    &gt;&gt;&gt; extract_arguments(params=(), b=2, a=1, c=3, d=0)</span>
<span class="sd">    ((), {}, {&#39;b&#39;: 2, &#39;a&#39;: 1, &#39;c&#39;: 3, &#39;d&#39;: 0})</span>

<span class="sd">    :param params: Specifies what PO arguments should be extracted.</span>
<span class="sd">        Could be a callable, Signature, iterable of Parameters...</span>
<span class="sd">    :param what_to_do_with_remainding:</span>
<span class="sd">        &#39;return&#39; (default): function will return `param_args`, `param_kwargs`, `remaining_kwargs`</span>
<span class="sd">        &#39;ignore&#39;: function will return `param_args`, `param_kwargs`</span>
<span class="sd">        &#39;assert_empty&#39;: function will assert that `remaining_kwargs` is empty and then return `param_args`, `param_kwargs`</span>
<span class="sd">    :param include_all_when_var_keywords_in_params=False,</span>
<span class="sd">    :param assert_no_missing_position_only_args=False,</span>
<span class="sd">    :param kwargs: The kwargs to extract the args from</span>
<span class="sd">    :return: A (param_args, param_kwargs, remaining_kwargs) tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">what_to_do_with_remainding</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;return&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">}</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include_all_when_var_keywords_in_params</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assert_no_missing_position_only_args</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(),</span> <span class="p">{},</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="n">params_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">names_for_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span><span class="p">]</span>
    <span class="n">param_kwargs_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">params_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">names_for_args</span><span class="p">)]</span>
    <span class="n">remaining_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_names</span><span class="p">]</span>

    <span class="n">param_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names_for_args</span><span class="p">)</span>
    <span class="n">param_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">param_kwargs_names</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">}</span>
    <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">remaining_names</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">include_all_when_var_keywords_in_params</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">next</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">),</span> <span class="kc">None</span><span class="p">,)</span>
            <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">param_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span>
            <span class="n">remaining_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">assert_no_missing_position_only_args</span><span class="p">:</span>
        <span class="n">missing_argnames</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">x</span><span class="o">.</span><span class="n">argname</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_args</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MissingArgValFor</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">missing_argnames</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;There were some missing positional only argnames: </span><span class="si">{</span><span class="n">missing_argnames</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">if</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;return&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span><span class="p">,</span> <span class="n">remaining_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span>
    <span class="k">elif</span> <span class="n">what_to_do_with_remainding</span> <span class="o">==</span> <span class="s1">&#39;assert_empty&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">remaining_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;remaining_kwargs not empty: remaining_kwargs=</span><span class="si">{</span><span class="n">remaining_kwargs</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">param_args</span><span class="p">,</span> <span class="n">param_kwargs</span></div>


<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="n">extract_arguments_ignoring_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">extract_arguments</span><span class="p">,</span> <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span>
<span class="p">)</span>
<span class="n">extract_arguments_asserting_no_remainder</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">extract_arguments</span><span class="p">,</span> <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;assert_empty&#39;</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>


<span class="k">def</span> <span class="nf">function_caller</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="Command"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Command">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Command</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A dataclass that holds a `(caller, args, kwargs)` triple and allows one to execute `caller(*args, **kwargs)`</span>

<span class="sd">    :param func: A callable that will be called with (*args, **kwargs) argument</span>
<span class="sd">    :param args: A tuple</span>
<span class="sd">    :param kwargs: A dict</span>
<span class="sd">    :param caller: How to actually implement the execution of the (func, args, kwargs)</span>

<span class="sd">    &gt;&gt;&gt; c = Command(print, (&quot;hello&quot;, &quot;world&quot;), dict(sep=&#39;, &#39;))</span>
<span class="sd">    &gt;&gt;&gt; c()</span>
<span class="sd">    hello, world</span>

<span class="sd">    The usual way to call a function is to... erm... call it.</span>
<span class="sd">    But sometimes you want to do things differently.</span>
<span class="sd">    Like validate it, put it on a queue, etc.</span>
<span class="sd">    That&#39;s where specifying a different caller will be useful.</span>

<span class="sd">    &gt;&gt;&gt; def caller(f, a, k):</span>
<span class="sd">    ...     print(f&quot;Calling {f}(*{a}, **{k}) with result: {f(*a, **k)}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; c = Command(print, (&quot;hello&quot;, &quot;world&quot;), dict(sep=&#39;, &#39;), caller=caller)</span>
<span class="sd">    &gt;&gt;&gt; c()</span>
<span class="sd">    hello, world</span>
<span class="sd">    Calling &lt;built-in function print&gt;(*(&#39;hello&#39;, &#39;world&#39;), **{&#39;sep&#39;: &#39;, &#39;}) with result: None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">caller</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_caller</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">caller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_commands"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.extract_commands">[docs]</a><span class="k">def</span> <span class="nf">extract_commands</span><span class="p">(</span>
    <span class="n">funcs</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mk_command</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Command</span><span class="p">,</span>
    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param funcs:</span>
<span class="sd">    :param mk_command:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b: float = 0.0) -&gt; float:</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x: float, y=1):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>
<span class="sd">    &gt;&gt;&gt; commands = extract_commands((add, mult, formula1), a=1, b=2, c=3, d=4, e=5, w=6, x=7)</span>
<span class="sd">    &gt;&gt;&gt; for command in commands:</span>
<span class="sd">    ...     print(f&quot;Calling {command.func.__name__} with &quot;</span>
<span class="sd">    ...             f&quot;args={command.args} and kwargs={command.kwargs}&quot;)</span>
<span class="sd">    ...     print(command())</span>
<span class="sd">    ...</span>
<span class="sd">    Calling add with args=() and kwargs={&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="sd">    3</span>
<span class="sd">    Calling mult with args=() and kwargs={&#39;x&#39;: 7}</span>
<span class="sd">    7</span>
<span class="sd">    Calling formula1 with args=(6,) and kwargs={&#39;x&#39;: 7}</span>
<span class="sd">    13</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extract</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
        <span class="n">extract_arguments</span><span class="p">,</span>
        <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="n">what_to_do_with_remainding</span><span class="p">,</span>
        <span class="n">include_all_when_var_keywords_in_params</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">assert_no_missing_position_only_args</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">extract</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">mk_command</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="commands_dict"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.commands_dict">[docs]</a><span class="k">def</span> <span class="nf">commands_dict</span><span class="p">(</span>
    <span class="n">funcs</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">mk_command</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">Command</span><span class="p">,</span>
    <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param funcs:</span>
<span class="sd">    :param mk_command:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b: float = 0.0) -&gt; float:</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x: float, y=1):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>
<span class="sd">    &gt;&gt;&gt; d = commands_dict((add, mult, formula1), a=1, b=2, c=3, d=4, e=5, w=6, x=7)</span>
<span class="sd">    &gt;&gt;&gt; d[add]()</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; d[mult]()</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; d[formula1]()</span>
<span class="sd">    13</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">extract_commands</span><span class="p">(</span>
        <span class="n">funcs</span><span class="p">,</span>
        <span class="n">what_to_do_with_remainding</span><span class="o">=</span><span class="n">what_to_do_with_remainding</span><span class="p">,</span>
        <span class="n">mk_command</span><span class="o">=</span><span class="n">mk_command</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">it</span><span class="p">))</span></div>


<div class="viewcode-block" id="Param"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Param">[docs]</a><span class="k">class</span> <span class="nc">Param</span><span class="p">(</span><span class="n">Parameter</span><span class="p">):</span>
    <span class="c1"># aliases</span>
    <span class="n">PK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
    <span class="n">PO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
    <span class="n">KO</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="n">VP</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
    <span class="n">VK</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
    <span class="c1"># OP = Parameter.POSITIONAL_ONLY</span>
    <span class="c1"># OK = Parameter.KEYWORD_ONLY</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>

    <span class="c1"># Note: Was useful to make Param a mapping, to get (dict(param))</span>
    <span class="c1">#  Is not useful anymore, so comment-deprecating</span>
    <span class="c1"># def __iter__(self):</span>
    <span class="c1">#     yield from [&#39;name&#39;, &#39;kind&#39;, &#39;default&#39;, &#39;annotation&#39;]</span>
    <span class="c1">#</span>
    <span class="c1"># def __getitem__(self, k):</span>
    <span class="c1">#     return getattr(self, k)</span>
    <span class="c1">#</span>
    <span class="c1"># def __len__(self):</span>
    <span class="c1">#     return 4</span>


<span class="n">P</span> <span class="o">=</span> <span class="n">Param</span>  <span class="c1"># useful shorthand alias</span>


<span class="k">def</span> <span class="nf">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>


<span class="n">WRAPPER_UPDATES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__dict__&#39;</span><span class="p">,)</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>


<span class="k">def</span> <span class="nf">_robust_signature_of_callable</span><span class="p">(</span><span class="n">callable_obj</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Signature</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the signature of a Callable, returning a custom made one for those builtins that don&#39;t have one</span>

<span class="sd">    &gt;&gt;&gt; _robust_signature_of_callable(_robust_signature_of_callable)  # has a normal signature</span>
<span class="sd">    &lt;Signature (callable_obj: Callable) -&gt; inspect.Signature&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = _robust_signature_of_callable(print)  # has one that this module provides</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(s, Signature)</span>
<span class="sd">    &gt;&gt;&gt; # Will be: &lt;Signature (*value, sep=&#39; &#39;, end=&#39;\n&#39;, file=&lt;_io.TextIOWrapper name=&#39;&lt;stdout&gt;&#39; mode=&#39;w&#39; encoding=&#39;utf-8&#39;&gt;, flush=False)&gt;</span>
<span class="sd">    &gt;&gt;&gt; _robust_signature_of_callable(zip)  # doesn&#39;t have one, so will return a blanket one</span>
<span class="sd">    &lt;Signature (*no_sig_args, **no_sig_kwargs)&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">callable_obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">obj_name</span> <span class="o">=</span> <span class="n">callable_obj</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">obj_name</span> <span class="ow">in</span> <span class="n">sigs_for_sigless_builtin_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sigs_for_sigless_builtin_name</span><span class="p">[</span><span class="n">obj_name</span><span class="p">]</span> <span class="ow">or</span> <span class="n">signature</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="o">*</span><span class="n">no_sig_args</span><span class="p">,</span> <span class="o">**</span><span class="n">no_sig_kwargs</span><span class="p">:</span> <span class="o">...</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span>


<span class="c1"># TODO: See other signature operating functions below in this module:</span>
<span class="c1">#   Do we need them now that we have Sig?</span>
<span class="c1">#   Do we want to keep them and have Sig use them?</span>
<div class="viewcode-block" id="Sig"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig">[docs]</a><span class="k">class</span> <span class="nc">Sig</span><span class="p">(</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A subclass of inspect.Signature that has some extra api sugar, such as a dict-like interface, merging, ...</span>

<span class="sd">    You can construct a `Sig` object from a callable,</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; Sig(f)</span>
<span class="sd">    &lt;Sig (w, /, x: float = 1, y=1, *, z: int = 1)&gt;</span>

<span class="sd">    but also from any &quot;ParamsAble&quot; object. Such as...</span>
<span class="sd">    an iterable of Parameter instances, strings, tuples, or dicts:</span>

<span class="sd">    &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, Parameter.empty, int), (&#39;c&#39;, 2), (&#39;d&#39;, 1.0, float),</span>
<span class="sd">    ...                dict(name=&#39;special&#39;, kind=Parameter.KEYWORD_ONLY, default=0)])</span>
<span class="sd">    &lt;Sig (a, b: int, c=2, d: float = 1.0, *, special=0)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, dict(name=&#39;args&#39;, kind=Parameter.VAR_POSITIONAL),</span>
<span class="sd">    ...                dict(name=&#39;kwargs&#39;, kind=Parameter.VAR_KEYWORD)]</span>
<span class="sd">    ... )</span>
<span class="sd">    &lt;Sig (a, b, *args, **kwargs)&gt;</span>

<span class="sd">    The parameters of a signature are like a matrix whose rows are the parameters,</span>
<span class="sd">    and the 4 columns are their properties: name, kind, default, and annotation</span>
<span class="sd">    (the two laste ones being optional).</span>
<span class="sd">    You get a row view when doing `Sig(...).parameters.values()`,</span>
<span class="sd">    but what if you want a column-view?</span>
<span class="sd">    Here&#39;s how:</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3): ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s = Sig(f)</span>
<span class="sd">    &gt;&gt;&gt; s.kinds  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;w&#39;: &lt;_ParameterKind.POSITIONAL_ONLY: 0&gt;,</span>
<span class="sd">    &#39;x&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;y&#39;: &lt;_ParameterKind.POSITIONAL_OR_KEYWORD: 1&gt;,</span>
<span class="sd">    &#39;z&#39;: &lt;_ParameterKind.KEYWORD_ONLY: 3&gt;}</span>

<span class="sd">    &gt;&gt;&gt; s.annotations</span>
<span class="sd">    {&#39;x&#39;: &lt;class &#39;float&#39;&gt;, &#39;z&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="sd">    &gt;&gt;&gt; assert s.annotations == f.__annotations__  # same as what you get in `__annotations__`</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; s.defaults</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; # Note that it&#39;s not the same as you get in __defaults__ though:</span>
<span class="sd">    &gt;&gt;&gt; assert s.defaults != f.__defaults__ == (1, 2)  # not 3, since __kwdefaults__ has that!</span>

<span class="sd">    We can sum (i.e. merge) and subtract (i.e. remove arguments) Sig instances.</span>
<span class="sd">    Also, Sig instance is callable. It has the effect of inserting it&#39;s signature in the input</span>
<span class="sd">    (in `__signature__`, but also inserting the resulting `__defaults__` and `__kwdefaults__`).</span>
<span class="sd">    One of the intents is to be able to do things like:</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">    &gt;&gt;&gt; def g(i, w, /, j=2): ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @Sig.from_objs(f, g, [&#39;a&#39;, (&#39;b&#39;, 3.14), (&#39;c&#39;, 42, int)])</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Signature (w, i, /, a, x: float = 1, y=1, j=2, b=3.14, c: int = 42, *, z: int = 1)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; sig = Sig(f) + g + [&#39;a&#39;, (&#39;b&#39;, 3.14), (&#39;c&#39;, 42, int)] - &#39;b&#39; - [&#39;a&#39;, &#39;z&#39;]</span>
<span class="sd">    &gt;&gt;&gt; @sig</span>
<span class="sd">    ... def some_func(*args, **kwargs):</span>
<span class="sd">    ...     ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(some_func)</span>
<span class="sd">    &lt;Signature (w, i, x: float = 1, y=1, j=2, c: int = 42)&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span>
        <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a Sig instance.</span>
<span class="sd">        See Also: `ensure_params` to see what kind of objects you can make `Sig`s with.</span>

<span class="sd">        :param obj: A ParamsAble object, which could be:</span>
<span class="sd">            - a callable,</span>
<span class="sd">            - and iterable of Parameter instances</span>
<span class="sd">            - an iterable of strings (representing annotation-less, default-less) argument names,</span>
<span class="sd">            - tuples: (argname, default) or (argname, default, annotation),</span>
<span class="sd">            - dicts: ``{&#39;name&#39;: REQUIRED,...}`` with optional `kind`, `default` and `annotation` fields</span>
<span class="sd">            - None (which will produce an argument-less Signature)</span>

<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &lt;Sig (a, b, c)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, None), (&#39;c&#39;, 42, int)])  # specifying defaults and annotations</span>
<span class="sd">        &lt;Sig (a, b=None, c: int = 42)&gt;</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, (&#39;b&#39;, inspect._empty, int)])  # specifying an annotation without a default</span>
<span class="sd">        &lt;Sig (a, b: int)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">        &lt;Sig (a, b, c) -&gt; str&gt;</span>

<span class="sd">        But you can always specify parameters the &quot;long&quot; way</span>

<span class="sd">        &gt;&gt;&gt; Sig([inspect.Parameter(name=&#39;kws&#39;, kind=inspect.Parameter.VAR_KEYWORD)], return_annotation=str)</span>
<span class="sd">        &lt;Sig (**kws) -&gt; str&gt;</span>

<span class="sd">        And note that:</span>
<span class="sd">        &gt;&gt;&gt; Sig()</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(None)</span>
<span class="sd">        &lt;Sig ()&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">return_annotation</span> <span class="ow">is</span> <span class="n">empty</span><span class="p">:</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">_robust_signature_of_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ensure_params</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span>
            <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
            <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.wrap"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>
<span class="sd">        This is similar to the `functools.wraps` function, but parametrized by a signature</span>
<span class="sd">        (not a callable). Also, where as both write to the input func&#39;s `__signature__`</span>
<span class="sd">        attribute, here we also write to</span>
<span class="sd">        - `__defaults__` and `__kwdefaults__`, extracting these from `__signature__`</span>
<span class="sd">            (functools.wraps doesn&#39;t do that at the time of writing this</span>
<span class="sd">            (see https://github.com/python/cpython/pull/21379)).</span>
<span class="sd">        - `__annotations__` (also extracted from `__signature__`)</span>
<span class="sd">        - does not write to `__module__`, `__name__`, `__qualname__`, `__doc__`</span>
<span class="sd">            (because again, we&#39;re basinig the injecton on a signature, not a function,</span>
<span class="sd">            so we have no name, doc, etc...)</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__</span>
<span class="sd">        (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert 8 == f(0) == f(0, 1) == f(0, 1, 2) == f(0, 1, 2, 3)</span>

<span class="sd">        Now let&#39;s create a very similar function to f, but where:</span>
<span class="sd">        - w is not position-only</span>
<span class="sd">        - x annot is int instead of float, and doesn&#39;t have a default</span>
<span class="sd">        - z&#39;s default changes to 10</span>
<span class="sd">        &gt;&gt;&gt; def g(w, x: int, y=2, z: int = 10):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(g)</span>
<span class="sd">        &gt;&gt;&gt; f = s.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; import inspect</span>
<span class="sd">        &gt;&gt;&gt; inspect.signature(f)  # see that</span>
<span class="sd">        &lt;Signature (w, x: int, y=2, z: int = 10)&gt;</span>
<span class="sd">        &gt;&gt;&gt; # But (unlike with functools.wraps) here we get __defaults__ and __kwdefault__</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__  # see that x has no more default, and z&#39;s default changed to 10</span>
<span class="sd">        (2, 10)</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1)  # see that now we get a different output because using different defaults</span>
<span class="sd">        1024</span>

<span class="sd">        TODO: Something goes wrong when using keyword only arguments.</span>
<span class="sd">            Note that the same problem occurs with functools.wraps, and even boltons.funcutils.wraps.</span>
<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; f(0)  # 0 + 1 * 2 ** 3</span>
<span class="sd">        8</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)  # error expected!</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 1 to 3 positional arguments but 4 were given</span>
<span class="sd">        &gt;&gt;&gt; def g(w, x: int, y=2, *, z: int = 10):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(g)</span>
<span class="sd">        &gt;&gt;&gt; f = s.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; f.__defaults__</span>
<span class="sd">        (2,)</span>
<span class="sd">        &gt;&gt;&gt; f.__kwdefaults__</span>
<span class="sd">        {&#39;z&#39;: 10}</span>
<span class="sd">        &gt;&gt;&gt; f(0, 1, 2, 3)  # error not expected! TODO: Make it work!!</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: f() takes from 2 to 3 positional arguments but 4 were given</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">annotations</span>
        <span class="c1"># endow the function with __defaults__ and __kwdefaults__ (not the default of functools.wraps!)</span>
        <span class="p">(</span>
            <span class="n">func</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span>
            <span class="n">func</span><span class="o">.</span><span class="vm">__kwdefaults__</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dunder_defaults_and_kwdefaults</span><span class="p">()</span>
        <span class="c1"># &quot;copy&quot; over all other non-dunder attributes (not the default of functools.wraps!)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">),</span> <span class="nb">dir</span><span class="p">(</span><span class="n">func</span><span class="p">)):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">func</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gives the input function the signature.</span>
<span class="sd">        Just calls Sig.wrap so see docs of Sig.wrap (which contains examples and doctests).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

<div class="viewcode-block" id="Sig.sig_or_none"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.sig_or_none">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sig_or_none</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a Sig instance, or None if there was a ValueError trying to construct it.</span>
<span class="sd">        One use case is to be able to tell if an object has a signature or not.</span>

<span class="sd">        &gt;&gt;&gt; robust_has_signature = lambda obj: bool(Sig.sig_or_none(obj))</span>
<span class="sd">        &gt;&gt;&gt; robust_has_signature(robust_has_signature)  # an easy case</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; robust_has_signature(Sig)  # another easy one: This time, a type/class (which is callable, yes)</span>
<span class="sd">        True</span>

<span class="sd">        But here&#39;s where it get&#39;s interesting. `print`, a builtin, doesn&#39;t have a signature through inspect.signature.</span>

<span class="sd">        &gt;&gt;&gt; has_signature(print)</span>
<span class="sd">        False</span>

<span class="sd">        But we do get one with robust_has_signature</span>

<span class="sd">        &gt;&gt;&gt; robust_has_signature(print)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_dunder_defaults_and_kwdefaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the __defaults__, __kwdefaults__ (i.e. what would be the dunders baring these names in a python callable)</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1): ...</span>
<span class="sd">        &gt;&gt;&gt; __defaults__, __kwdefaults__ = Sig(foo)._dunder_defaults_and_kwdefaults()</span>
<span class="sd">        &gt;&gt;&gt; __defaults__</span>
<span class="sd">        (1,)</span>
<span class="sd">        &gt;&gt;&gt; __kwdefaults__</span>
<span class="sd">        {&#39;z&#39;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ko_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_for_kind</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span>
        <span class="n">dflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaults</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ko_names</span><span class="p">),</span>
            <span class="c1"># as known as __defaults__ in python callables</span>
            <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">dflts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dflts</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ko_names</span>
            <span class="p">},</span>  <span class="c1"># as known as __kwdefaults__ in python callables</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sig.to_signature_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.to_signature_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">to_signature_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dict of keyword arguments to make this signature instance.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0) -&gt; float: ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_signature_kwargs()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        {&#39;parameters&#39;:</span>
<span class="sd">            [&lt;Parameter &quot;w&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;x: float = 2&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;y=1&quot;&gt;,</span>
<span class="sd">            &lt;Parameter &quot;z: int = 0&quot;&gt;],</span>
<span class="sd">        &#39;return_annotation&#39;: &lt;class &#39;float&#39;&gt;}</span>

<span class="sd">        Note that this does NOT return:</span>
<span class="sd">        ```</span>
<span class="sd">                {&#39;parameters&#39;: self.parameters,</span>
<span class="sd">                &#39;return_annotation&#39;: self.return_annotation}</span>
<span class="sd">        ```</span>
<span class="sd">        which would not actually work as keyword arguments of ``Signature``.</span>
<span class="sd">        Yeah, I know. Don&#39;t ask me, ask the authors of `Signature`!</span>

<span class="sd">        Instead, `parammeters` will be ``list(self.parameters.values())``, which does work.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="s1">&#39;return_annotation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="Sig.to_simple_signature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.to_simple_signature">[docs]</a>    <span class="k">def</span> <span class="nf">to_simple_signature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A builtin ``inspect.Signature`` instance equivalent (i.e. without the extra properties and methods)</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 2, y=1, *, z: int = 0): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(f).to_simple_signature()</span>
<span class="sd">        &lt;Signature (w, /, x: float = 2, y=1, *, z: int = 0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">to_signature_kwargs</span><span class="p">())</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_objs</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">*</span><span class="n">objs</span><span class="p">,</span>
        <span class="n">default_conflict_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">,</span>
        <span class="o">**</span><span class="n">name_and_dflts</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">name_and_dflts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">([{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">:</span> <span class="n">PK</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="n">default</span><span class="p">}])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">first_obj</span><span class="p">,</span> <span class="o">*</span><span class="n">objs</span> <span class="o">=</span> <span class="n">objs</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">ensure_params</span><span class="p">(</span><span class="n">first_obj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span>
                    <span class="n">obj</span><span class="p">,</span> <span class="n">default_conflict_method</span><span class="o">=</span><span class="n">default_conflict_method</span>
                <span class="p">)</span>
                <span class="c1"># sig = sig + obj</span>
            <span class="k">return</span> <span class="n">sig</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if no objs are given</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>  <span class="c1"># return an empty signature</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_params</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just list(self.parameters.values()), because that&#39;s often what we want.</span>
<span class="sd">        Why a Sig.params property when we already have a Sig.parameters property?</span>

<span class="sd">        Well, as much as is boggles my mind, it so happens that the Signature.parameters</span>
<span class="sd">        is a name-&gt;Parameter mapping, but the Signature argument `parameters`, though baring the same name,</span>
<span class="sd">        is expected to be a list of Parameter instances.</span>

<span class="sd">        So Sig.params is there to restore semantic consistence sanity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;{arg_name: annotation, ...} dict of annotations of the signature.</span>
<span class="sd">        What `func.__annotations__` would give you.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="o">!=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
        <span class="p">}</span>

    <span class="c1"># def substitute(self, **sub_for_name):</span>
    <span class="c1">#     def gen():</span>
    <span class="c1">#</span>
    <span class="c1">#         for name, substitution in sub_for_name.items():</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">names_for_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">kind</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_kinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_positional</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_var_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VK</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_required</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The number of required arguments.</span>
<span class="sd">        A required argument is one that doesn&#39;t have a default, nor is VAR_POSITIONAL (*args) or VAR_KEYWORD (**kwargs).</span>
<span class="sd">        Note: Sometimes a minimum number of arguments in VAR_POSITIONAL and VAR_KEYWORD are in fact required,</span>
<span class="sd">        but we can&#39;t see this from the signature, so we can&#39;t tell you about that! You do the math.</span>

<span class="sd">        # Skipping the actual running of the doctest because some IDEs don&#39;t handle @property testing well.</span>
<span class="sd">        # &gt;&gt;&gt; Sig(lambda x, y, z=None, *args, **kwargs: ...).n_required</span>
<span class="sd">        # 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_var_keyword</span>
            <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_var_positional</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sig.merge_with_sig"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.merge_with_sig">[docs]</a>    <span class="k">def</span> <span class="nf">merge_with_sig</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">,</span>
        <span class="n">ch_to_all_pk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">default_conflict_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DFLT_DEFAULT_CONFLICT_METHOD</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a signature obtained by merging self signature with another signature.</span>
<span class="sd">        Insofar as it can, given the kind precedence rules, the arguments of self will appear first.</span>

<span class="sd">        :param sig: The signature to merge with.</span>
<span class="sd">        :param ch_to_all_pk: Whether to change all kinds of both signatures to PK (POSITIONAL_OR_KEYWORD)</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; def func(a=None, *, b=1, c=2): ...</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; s = Sig(func)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        &lt;Sig (a=None, *, b=1, c=2)&gt;</span>

<span class="sd">        Observe where the new arguments ``d`` and ``e`` are placed,</span>
<span class="sd">        according to whether they have defaults and what their kind is:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &lt;Sig (d, e, a=None, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, (&#39;e&#39;, 4)])</span>
<span class="sd">        &lt;Sig (d, a=None, e=4, *, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, dict(name=&#39;e&#39;, kind=KO, default=4)])</span>
<span class="sd">        &lt;Sig (d, a=None, *, b=1, c=2, e=4)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([dict(name=&#39;d&#39;, kind=KO), dict(name=&#39;e&#39;, kind=KO, default=4)])</span>
<span class="sd">        &lt;Sig (a=None, *, d, b=1, c=2, e=4)&gt;</span>

<span class="sd">        If the kind of the params is not important, but order is, you can specify ``ch_to_all_pk=True``:</span>

<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([&#39;d&#39;, &#39;e&#39;], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (d, e, a=None, b=1, c=2)&gt;</span>
<span class="sd">        &gt;&gt;&gt; s.merge_with_sig([(&#39;d&#39;, 3), (&#39;e&#39;, 4)], ch_to_all_pk=True)</span>
<span class="sd">        &lt;Sig (a=None, b=1, c=2, d=3, e=4)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ch_to_all_pk</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">ensure_signature</span><span class="p">(</span><span class="n">sig</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

        <span class="n">_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Happened during an attempt to merge </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> and </span><span class="si">{</span><span class="n">sig</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_POSITIONAL parameter:</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">_self</span><span class="o">.</span><span class="n">has_var_keyword</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_sig</span><span class="o">.</span><span class="n">has_var_keyword</span>
        <span class="p">),</span> <span class="s2">&quot;Can&#39;t merge two signatures if they both have a VAR_KEYWORD parameter:</span><span class="si">{_msg}</span><span class="s2">&quot;</span>

        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;During a signature merge, if two names are the same, they must have the &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;**same kind**:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s2">&quot;Tip: If you&#39;re trying to merge functions in some way, consider decorating &quot;</span>
            <span class="s1">&#39;them with a signature mapping that avoids the argument name clashing&#39;</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="n">default_conflict_method</span> <span class="ow">in</span> <span class="p">{</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;strict&#39;</span><span class="p">,</span>
            <span class="s1">&#39;take_first&#39;</span><span class="p">,</span>
        <span class="p">},</span> <span class="s2">&quot;default_conflict_method should be in {None, &#39;strict&#39;, &#39;take_first&#39;}&quot;</span>

        <span class="k">if</span> <span class="n">default_conflict_method</span> <span class="o">==</span> <span class="s1">&#39;take_first&#39;</span><span class="p">:</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">_sig</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">_self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">_sig</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">default</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_sig</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">):</span>

            <span class="c1"># if default_conflict_method == &#39;take_first&#39;:</span>
            <span class="c1">#     _sig = _sig - set(_self.keys() &amp; _sig.keys())</span>
            <span class="c1"># else:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;During a signature merge, if two names are the same, they must have the &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;**same default**:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">_msg</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s2">&quot;Tip: If you&#39;re trying to merge functions in some way, consider decorating &quot;</span>
                <span class="s1">&#39;them with a signature mapping that avoids the argument name clashing&#39;</span>
            <span class="p">)</span>

        <span class="c1"># assert all(</span>
        <span class="c1">#     _self[name].default == _sig[name].default</span>
        <span class="c1">#     for name in _self.keys() &amp; _sig.keys()</span>
        <span class="c1"># ), (</span>
        <span class="c1">#     &#39;During a signature merge, if two names are the same, they must have the &#39;</span>
        <span class="c1">#     f&#39;**same default**:\n\t{_msg}\n&#39;</span>
        <span class="c1">#     &quot;Tip: If you&#39;re trying to merge functions in some way, consider decorating &quot;</span>
        <span class="c1">#     &quot;them a signature mapping that &quot;</span>
        <span class="c1">#     &#39;avoids the argument name clashing&#39;</span>
        <span class="c1"># )</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chain_params_of_signatures</span><span class="p">(</span>
                <span class="n">_self</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span>
                <span class="n">_sig</span><span class="o">.</span><span class="n">without_defaults</span><span class="p">,</span>
                <span class="n">_self</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">,</span>
                <span class="n">_sig</span><span class="o">.</span><span class="n">with_defaults</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">params</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merge two signatures (casting all non-VAR kinds to POSITIONAL_OR_KEYWORD before hand)</span>

<span class="sd">        Important Notes:</span>
<span class="sd">        - The resulting Sig will loose it&#39;s return_annotation if it had one.</span>
<span class="sd">            This is to avoid making too many assumptions about how the sig sum will be used.</span>
<span class="sd">            If a return_annotation is needed (say, for composition, the last return_annotation</span>
<span class="sd">            summed), one can subclass Sig and overwrite __add__</span>
<span class="sd">        - POSITION_ONLY and KEYWORD_ONLY kinds will be replaced by POSITIONAL_OR_KEYWORD kind.</span>
<span class="sd">        This is to simplify the interface and code.</span>
<span class="sd">        If the user really wants to maintain those kinds, they can replace them back after the fact.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=1, *, z: int = 1): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(i, j, w): ...  # has a &#39;w&#39; argument, like f and g</span>
<span class="sd">        &gt;&gt;&gt; def different(a, b: str, c=None): ...  # No argument names in common with other functions</span>

<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(different)</span>
<span class="sd">        &lt;Sig (w, a, b: str, x: float = 1, y=1, z: int = 1, c=None)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(different) + Sig(f)</span>
<span class="sd">        &lt;Sig (a, b: str, w, c=None, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The order of the first signature will take precedence over the second,</span>
<span class="sd">        but default-less arguments have to come before arguments with defaults.</span>
<span class="sd">         first, and Note the difference of the orders.</span>
<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(h)</span>
<span class="sd">        &lt;Sig (w, i, j, x: float = 1, y=1, z: int = 1)&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(f)</span>
<span class="sd">        &lt;Sig (i, j, w, x: float = 1, y=1, z: int = 1)&gt;</span>

<span class="sd">        The sum of two Sig&#39;s takes a safe-or-blow-up-now approach.</span>
<span class="sd">        If any of the arguments have different defaults or annotations, summing will raise an AssertionError.</span>
<span class="sd">        It&#39;s up to the user to decorate their input functions to express the default they actually desire.</span>

<span class="sd">        &gt;&gt;&gt; def ff(w, /, x: float, y=1, *, z: int = 1): ...  # just like f, but without the default for x</span>
<span class="sd">        &gt;&gt;&gt; Sig(f) + Sig(ff)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: During a signature merge, if two names are the same, they must have the **same default**:</span>
<span class="sd">        &lt;BLANKSPACE&gt;</span>
<span class="sd">        Happened during an attempt to merge (w, /, x: float = 1, y=1, *, z: int = 1) and (w, /, x: float, y=1, *, z: int = 1)</span>
<span class="sd">        Tip: If you&#39;re trying to merge functions in some way, consider decorating them with a signature mapping that avoids the argument name clashing</span>


<span class="sd">        &gt;&gt;&gt; def hh(i, j, w=1): ...  # like h, but w has a default</span>
<span class="sd">        &gt;&gt;&gt; Sig(h) + Sig(hh)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        ValueError: During a signature merge, if two names are the same, they must have the **same default**:</span>
<span class="sd">        &lt;BLANKSPACE&gt;</span>
<span class="sd">        Happened during an attempt to merge (i, j, w) and (i, j, w=1)</span>
<span class="sd">        Tip: If you&#39;re trying to merge functions in some way, consider decorating them with a signature mapping that avoids the argument name clashing</span>


<span class="sd">        &gt;&gt;&gt; Sig(f) + [&#39;w&#39;, (&#39;y&#39;, 1), (&#39;d&#39;, 1.0, float),</span>
<span class="sd">        ...                dict(name=&#39;special&#39;, kind=Parameter.KEYWORD_ONLY, default=0)]</span>
<span class="sd">        &lt;Sig (w, x: float = 1, y=1, z: int = 1, d: float = 1.0, special=0)&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">ch_to_all_pk</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adding on the right.</span>
<span class="sd">        The raison d&#39;√™tre for this is so that you can start your summing with any signature speccifying</span>
<span class="sd">         object that Sig will be able to resolve into a signature. Like this:</span>

<span class="sd">        &gt;&gt;&gt; [&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)] + Sig(lambda x, y: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, x, y, second_arg=42)&gt;</span>

<span class="sd">        Note that the ``second_arg`` doesn&#39;t actually end up being the second argument because</span>
<span class="sd">        it has a default and x and y don&#39;t. But if you did this:</span>

<span class="sd">        &gt;&gt;&gt; [&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)] + Sig(lambda x=0, y=1: x * y)</span>
<span class="sd">        &lt;Sig (first_arg, second_arg=42, x=0, y=1)&gt;</span>

<span class="sd">        you&#39;d get what you expect.</span>

<span class="sd">        Of course, we could have just obliged you to say ``Sig([&#39;first_arg&#39;, (&#39;second_arg&#39;, 42)])``</span>
<span class="sd">        explicitly and spare ourselves yet another method.</span>
<span class="sd">        The reason we made ``__radd__`` is so we can make it handle 0 + Sig(...), so that you can</span>
<span class="sd">        merge an iterable of signatures like this:</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b, c): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(c, b, e): ...</span>
<span class="sd">        &gt;&gt;&gt; sigs = map(Sig, [f, g])</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (a, b, c, e)&gt;</span>

<span class="sd">        Let&#39;s say, for whatever reason (don&#39;t ask me), you wanted to make a function that contains all the</span>
<span class="sd">        arguments of all the functions of ``os.path`` (that don&#39;t contain any var arg kinds).</span>

<span class="sd">        &gt;&gt;&gt; import os.path</span>
<span class="sd">        &gt;&gt;&gt; funcs = list(filter(callable, (getattr(os.path, a) for a in dir(os.path) if not a.startswith(&#39;_&#39;))))</span>
<span class="sd">        &gt;&gt;&gt; sigs = filter(lambda sig: not sig.has_var_kinds, map(Sig, funcs))</span>
<span class="sd">        &gt;&gt;&gt; sum(sigs)</span>
<span class="sd">        &lt;Sig (path, p, paths, m, filename, s, f1, f2, fp1, fp2, s1, s2, start=None)&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sig</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># so that we can do ``sum(iterable_of_sigs)``</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">([])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ensure_params</span><span class="p">(</span><span class="n">names</span><span class="p">)}</span>
        <span class="n">new_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">p</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_names</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_chain_params_of_signatures</span><span class="p">(</span><span class="o">*</span><span class="n">sigs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields Parameter instances taken from sigs without repeating the same name twice.</span>
<span class="sd">        &gt;&gt;&gt; str(list(Sig._chain_params_of_signatures(Sig(lambda x, *args, y=1: ...),</span>
<span class="sd">        ...     Sig(lambda x, y, z, **kwargs: ...))))</span>
<span class="sd">        &#39;[&lt;Parameter &quot;x&quot;&gt;, &lt;Parameter &quot;*args&quot;&gt;, &lt;Parameter &quot;y=1&quot;&gt;, &lt;Parameter &quot;z&quot;&gt;, &lt;Parameter &quot;**kwargs&quot;&gt;]&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">already_merged_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sigs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_merged_names</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>
                <span class="n">already_merged_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">without_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).without_defaults)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">with_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; list(Sig(lambda *args, a, b, x=1, y=1, **kwargs: ...).with_defaults)</span>
<span class="sd">        [&#39;args&#39;, &#39;x&#39;, &#39;y&#39;, &#39;kwargs&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">param_has_default_or_is_var_kind</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">normalize_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">p</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">()),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Sig.kwargs_from_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.kwargs_from_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">kwargs_from_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">args</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts a dict of input argument values for target signature, from args and kwargs.</span>

<span class="sd">        When you need to manage how the arguments of a function are specified, you need to take care of</span>
<span class="sd">        multiple cases depending on whether they were specified as positional arguments</span>
<span class="sd">        (`args`) or keyword arguments (`kwargs`).</span>

<span class="sd">        The `kwargs_from_args_and_kwargs` (and it&#39;s sorta-inverse inverse, `args_and_kwargs_from_kwargs`)</span>
<span class="sd">        are there to help you manage this.</span>

<span class="sd">        If you could rely on the the fact that only `kwargs` were given it would reduce the complexity of your code.</span>
<span class="sd">        This is why we have the `ch_signature_to_all_pk` function in `signatures.py`.</span>

<span class="sd">        We also need to have a means to make a `kwargs` only from the actual `(*args, **kwargs)` used at runtime.</span>
<span class="sd">        We have `Signature.bind` (and `bind_partial`) for that.</span>

<span class="sd">        But these methods will fail if there is extra stuff in the `kwargs`.</span>
<span class="sd">        Yet sometimes we&#39;d like to have a `dict` that services several functions that will extract their needs from it.</span>

<span class="sd">        That&#39;s where  `Sig.extract_kwargs(*args, **kwargs)` is needed.</span>
<span class="sd">        :param args: The args the function will be called with.</span>
<span class="sd">        :param kwargs: The kwargs the function will be called with.</span>
<span class="sd">        :param apply_defaults: (bool) Whether to apply signature defaults to the non-specified argument names</span>
<span class="sd">        :param allow_partial: (bool) True iff you want to allow partial signature fulfillment.</span>
<span class="sd">        :param allow_excess: (bool) Set to True iff you want to allow extra kwargs items to be ignored.</span>
<span class="sd">        :param ignore_kind: (bool) Set to True iff you want to ignore the position and keyword only kinds,</span>
<span class="sd">            in order to be able to accept args and kwargs in such a way that there can be cross-over</span>
<span class="sd">            (args that are supposed to be keyword only, and kwargs that are supposed to be positional only)</span>
<span class="sd">        :return: An {argname: argval, ...} dict</span>

<span class="sd">        See also the sorta-inverse of this function: args_and_kwargs_from_kwargs</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.kwargs_from_args_and_kwargs((11, 22, &#39;you&#39;), dict(z=&#39;zoo&#39;))</span>
<span class="sd">        ...     == sig.kwargs_from_args_and_kwargs((11, 22), dict(y=&#39;you&#39;, z=&#39;zoo&#39;))</span>
<span class="sd">        ...     == {&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;you&#39;, &#39;z&#39;: &#39;zoo&#39;})</span>

<span class="sd">        By default, `apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22})</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        But if you specify `apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22}, apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22, &#39;y&#39;: &#39;YY&#39;, &#39;z&#39;: &#39;ZZ&#39;}</span>

<span class="sd">        By default, `ignore_excess=False`, so specifying kwargs that are not in the signature will lead to an exception.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22, &#39;not_in_sig&#39;: -1})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        TypeError: Got unexpected keyword arguments: not_in_sig</span>

<span class="sd">        Specifying `allow_excess=True` will ignore such excess fields of kwargs.</span>
<span class="sd">        This is useful when you want to source several functions from a same dict.</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(11,), kwargs={&#39;x&#39;: 22, &#39;not_in_sig&#39;: -1}, allow_excess=True)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        On the other side of `ignore_excess` you have `allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs={&#39;x&#39;: 22})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs={&#39;x&#39;: 22}, allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 22}</span>

<span class="sd">        That&#39;s a lot of control (eight combinations total), but not everything is controllable here:</span>
<span class="sd">        Position only and keyword only kinds need to be respected:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(1, 2, 3, 4), kwargs={})</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: too many positional arguments</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs=dict(w=1, x=2, y=3, z=4))</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        But if you want to ignore the kind of parameter, just say so:</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(1, 2, 3, 4), kwargs={}, ignore_kind=True)</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &gt;&gt;&gt; sig.kwargs_from_args_and_kwargs(args=(), kwargs=dict(w=1, x=2, y=3, z=4), ignore_kind=True)</span>
<span class="sd">        {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore_kind</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_kind</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">no_var_kw</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">has_var_keyword</span>
        <span class="k">if</span> <span class="n">no_var_kw</span><span class="p">:</span>  <span class="c1"># has no var keyword kinds</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span>
            <span class="p">}</span>  <span class="c1"># take only what you need</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sig_relevant_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>  <span class="c1"># take all the kwargs</span>

        <span class="n">binder</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind_partial</span> <span class="k">if</span> <span class="n">allow_partial</span> <span class="k">else</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">binder</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">sig_relevant_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apply_defaults</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">no_var_kw</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_excess</span><span class="p">:</span>  <span class="c1"># don&#39;t ignore excess kwargs</span>
            <span class="n">excess</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">arguments</span>
            <span class="k">if</span> <span class="n">excess</span><span class="p">:</span>
                <span class="n">excess_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">excess</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got unexpected keyword arguments: </span><span class="si">{</span><span class="n">excess_str</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sig.args_and_kwargs_from_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.args_and_kwargs_from_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">args_and_kwargs_from_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">kwargs</span><span class="p">,</span>
        <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an (args, kwargs) tuple from the kwargs, where args contain the position only arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">        ...     return ((w + x) * y) ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).args_and_kwargs_from_kwargs(dict(w=4, x=3, y=2, z=1))</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        &gt;&gt;&gt; assert foo(*args, **kwargs) == foo(4, 3, 2, z=1) == 14</span>

<span class="sd">        See kwargs_from_args_and_kwargs (namely for the description of the arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position_only_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">PO</span><span class="p">}</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">position_only_names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># kwargs = self.kwargs_from_args_and_kwargs(args, kwargs, apply_defaults, allow_partial, allow_excess)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">position_only_names</span><span class="p">}</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="n">allow_excess</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">ignore_kind</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">position_only_names</span><span class="p">}</span>

        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="Sig.extract_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.extract_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience method that calls kwargs_from_args_and_kwargs with defaults, and ignore_kind=True.</span>

<span class="sd">        Strict in the sense that the kwargs cannot contain any arguments that are not</span>
<span class="sd">        valid argument names (as per the signature).</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; sig = Sig(foo)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     sig.extract_kwargs(1, 2, 3, z=4)</span>
<span class="sd">        ...     == sig.extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        ...     == {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;y&#39;: 3, &#39;z&#39;: 4})</span>

<span class="sd">        What about var positional and var keywords?</span>
<span class="sd">        &gt;&gt;&gt; def bar(*args, **kwargs): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(bar).extract_kwargs(1, 2, y=3, z=4)</span>
<span class="sd">        {&#39;args&#39;: (1, 2), &#39;kwargs&#39;: {&#39;y&#39;: 3, &#39;z&#39;: 4}}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(w=11, x=22, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(x=3, y=2, _allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_kwargs(4, x=3, y=2, _apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.extract_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.extract_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">extract_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        The difference with extract_kwargs is that here the output is ready to be called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(w=4, x=3, y=2, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).extract_args_and_kwargs(x=3, y=2)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(x=3, y=2, _allow_partial=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).extract_args_and_kwargs(4, x=3, y=2, _apply_defaults=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_kwargs</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">_ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">_allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">_apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.source_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the kwargs for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=&#39;YY&#39;, *, z: str = &#39;ZZ&#39;): ...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=11` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(w=11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 11, &#39;x&#39;: 22}</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(w=11, x=22, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _allow_partial=True)</span>
<span class="sd">        {&#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2}</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _apply_defaults=True)</span>
<span class="sd">        {&#39;w&#39;: 4, &#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: &#39;ZZ&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Sig.source_args_and_kwargs"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.Sig.source_args_and_kwargs">[docs]</a>    <span class="k">def</span> <span class="nf">source_args_and_kwargs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">_ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_allow_partial</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_apply_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Source the (args, kwargs) for the signature instance, ignoring excess arguments.</span>

<span class="sd">        &gt;&gt;&gt; def foo(w, /, x: float, y=2, *, z: int = 1):</span>
<span class="sd">        ...     return w + x * y ** z</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        The difference with source_kwargs is that here the output is ready to be called by the</span>
<span class="sd">        function whose signature we have, since the position-only arguments will be returned as</span>
<span class="sd">        args.</span>

<span class="sd">        &gt;&gt;&gt; foo(*args, **kwargs)</span>
<span class="sd">        10</span>

<span class="sd">        Note that though `w` is a position only argument, you can specify `w=4` as a keyword argument too (by default):</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(w=4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>

<span class="sd">        If you don&#39;t want to allow that, you can say `_ignore_kind=False`</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(w=4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _ignore_kind=False)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;w&#39; parameter is positional only, but was passed as a keyword</span>

<span class="sd">        You can use `_allow_partial` that will allow you, if</span>
<span class="sd">        set to `True`, to underspecify the params of a function (in view of being completed later).</span>
<span class="sd">        &gt;&gt;&gt; Sig(foo).source_args_and_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: missing a required argument: &#39;w&#39;</span>

<span class="sd">        But if you specify `_allow_partial=True`...</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _allow_partial=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        By default, `_apply_defaults=False`, which will lead to only get those arguments you input.</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2})</span>
<span class="sd">        True</span>

<span class="sd">        But if you specify `_apply_defaults=True` non-specified non-require arguments</span>
<span class="sd">        will be returned with their defaults:</span>
<span class="sd">        &gt;&gt;&gt; args, kwargs = Sig(foo).source_args_and_kwargs(4, x=3, y=2, extra=&#39;keywords&#39;, are=&#39;ignored&#39;, _apply_defaults=True)</span>
<span class="sd">        &gt;&gt;&gt; (args, kwargs) == ((4,), {&#39;x&#39;: 3, &#39;y&#39;: 2, &#39;z&#39;: 1})</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">kwargs</span><span class="p">,</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="n">_ignore_kind</span><span class="p">,</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="n">_allow_partial</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_apply_defaults</span><span class="p">,</span>
        <span class="p">)</span></div></div>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Recipes</span>


<div class="viewcode-block" id="mk_sig_from_args"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.mk_sig_from_args">[docs]</a><span class="k">def</span> <span class="nf">mk_sig_from_args</span><span class="p">(</span><span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a Signature instance by specifying args_without_default and args_with_defaults.</span>
<span class="sd">    &gt;&gt;&gt; mk_sig_from_args(&#39;a&#39;, &#39;b&#39;, c=1, d=&#39;bar&#39;)</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args_without_default</span>
    <span class="p">),</span> <span class="s1">&#39;all default-less arguments must be strings&#39;</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span>
        <span class="o">*</span><span class="n">args_without_default</span><span class="p">,</span> <span class="o">**</span><span class="n">args_with_defaults</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>


<div class="viewcode-block" id="call_forgivingly"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.call_forgivingly">[docs]</a><span class="k">def</span> <span class="nf">call_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call function on given args and kwargs, but only taking what the function needs</span>
<span class="sd">    (not choking if they&#39;re extras variables)</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b: int=0, c=None) -&gt; int:</span>
<span class="sd">    ...     return &#39;foo&#39;, (a, b, c)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; call_forgivingly(</span>
<span class="sd">    ...     foo, # the function you want to call</span>
<span class="sd">    ...     &#39;input for a&#39;, # meant for a -- the first (and only) argument foo requires</span>
<span class="sd">    ...     c=42,  # skiping b and giving c a non-default value</span>
<span class="sd">    ...     intruder=&#39;argument&#39;  # but wait, this argument name doesn&#39;t exist! Oh no, what&#39;s going to happen?</span>
<span class="sd">    ... )  # well, as it happens, nothing bad -- the intruder argument is just ignored</span>
<span class="sd">    (&#39;foo&#39;, (&#39;input for a&#39;, 0, 42))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_args_and_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="has_signature"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.has_signature">[docs]</a><span class="k">def</span> <span class="nf">has_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">robust</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if an object has a signature -- i.e. is callable and inspect.signature(obj) returns something.</span>

<span class="sd">    This can be used to more easily get signatures in bulk without having to write try/catches:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; len(list(filter(None, map(partial(has_signature, robust=False), (Sig, print, map, filter, Sig.wrap)))))</span>
<span class="sd">    2</span>

<span class="sd">    If robust is set to True, `has_signature` will use `Sig` to get the signature, so will return True in most cases.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">robust</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">Sig</span><span class="o">.</span><span class="n">sig_or_none</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">bool</span><span class="p">((</span><span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>


<span class="k">def</span> <span class="nf">number_of_required_arguments</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>


<div class="viewcode-block" id="ch_signature_to_all_pk"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.ch_signature_to_all_pk">[docs]</a><span class="k">def</span> <span class="nf">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">Signature</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Changes all (non-varadaic) arguments to be of the PK (POSITION_OR_KEYWORD) kind.</span>

<span class="sd">    Wrapping a function with the resulting signature doesn&#39;t make that function callable</span>
<span class="sd">    with PK kinds in itself.</span>
<span class="sd">    It just gives it a signature without position and keyword ONLY kinds.</span>
<span class="sd">    It should be used to wrap such a function that actually carries out the</span>
<span class="sd">    implementation though!</span>

<span class="sd">    &gt;&gt;&gt; def foo(w, /, x: float, y=1, *, z: int = 1, **kwargs): ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(*args, **kwargs): ...</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; ch_signature_to_all_pk(signature(foo))</span>
<span class="sd">    &lt;Signature (w, x: float, y=1, z: int = 1, **kwargs)&gt;</span>

<span class="sd">    But note that the varadaic arguments *args and **kwargs remain varadaic:</span>

<span class="sd">    &gt;&gt;&gt; ch_signature_to_all_pk(signature(bar))</span>
<span class="sd">    &lt;Signature (*args, **kwargs)&gt;</span>

<span class="sd">    It works with `Sig` too (since Sig is a Signature), and maintains it&#39;s other</span>
<span class="sd">    attributes (like name).</span>

<span class="sd">    &gt;&gt;&gt; sig = ch_signature_to_all_pk(Sig(bar))</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    &lt;Sig (*args, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; sig.name</span>
<span class="sd">    &#39;bar&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">changed_params</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">p</span>

    <span class="n">new_sig</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig</span><span class="p">)(</span><span class="nb">list</span><span class="p">(</span><span class="n">changed_params</span><span class="p">()),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">attrval</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">new_sig</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">attrval</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_sig</span></div>


<div class="viewcode-block" id="tuple_the_args"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.tuple_the_args">[docs]</a><span class="k">def</span> <span class="nf">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that will change a VAR_POSITIONAL (*args) argument to a tuple (args)</span>
<span class="sd">    argument of the same name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">params_of</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">is_vp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_vp</span><span class="p">):</span>
        <span class="n">index_of_vp</span> <span class="o">=</span> <span class="n">is_vp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># there&#39;s can be only one</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">vpless_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># extract the element of args that needs to be unraveled</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">_vp_args_</span><span class="p">,</span> <span class="n">aa</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">args</span><span class="p">[:</span><span class="n">index_of_vp</span><span class="p">],</span>
                <span class="n">args</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">],</span>
                <span class="n">args</span><span class="p">[(</span><span class="n">index_of_vp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:],</span>
            <span class="p">)</span>
            <span class="c1"># call the original function with the unravelled args</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_vp_args_</span><span class="p">,</span> <span class="o">*</span><span class="n">aa</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># TODO: Avoid this try catch. Look in advance for default ordering</span>
            <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">())</span>
            <span class="n">vpless_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="n">vpless_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">vpless_func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span></div>
        <span class="c1"># Problems with copying (like when func is a partial) so removing!</span>
        <span class="c1"># return copy_func(</span>
        <span class="c1">#     func</span>
        <span class="c1"># )  # don&#39;t change anything (or should we wrap anyway, to be consistent?)</span>


<div class="viewcode-block" id="copy_func"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.copy_func">[docs]</a><span class="k">def</span> <span class="nf">copy_func</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy a function (not sure it works with all types of callables)&quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="p">(</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="p">,</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">argdefs</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span>
        <span class="n">closure</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__kwdefaults__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__signature__&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span>
    <span class="k">return</span> <span class="n">g</span></div>


<span class="c1"># TODO: Similar to other function in this module -- merge.</span>
<span class="k">def</span> <span class="nf">params_of</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">HasParams</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span>
    <span class="p">),</span> <span class="s1">&#39;obj needs to be a Iterable[Parameter] at this point&#39;</span>
    <span class="k">return</span> <span class="n">obj</span>  <span class="c1"># as is</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># TODO: Encorporate in Sig</span>
<div class="viewcode-block" id="insert_annotations"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.insert_annotations">[docs]</a><span class="k">def</span> <span class="nf">insert_annotations</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Signature</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="o">**</span><span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Insert annotations in a signature.</span>
<span class="sd">    (Note: not really insert but returns a copy of input signature)</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; s = signature(lambda a, b, c=1, d=&#39;bar&#39;: 0)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    &lt;Signature (a, b, c=1, d=&#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; ss = insert_annotations(s, b=int, d=str)</span>
<span class="sd">    &gt;&gt;&gt; ss</span>
<span class="sd">    &lt;Signature (a, b: int, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; insert_annotations(s, b=int, d=str, e=list)  # doctest: +IGNORE_EXCEPTION_DETAIL</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AssertionError: These argument names weren&#39;t found in the signature: {&#39;e&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">s</span><span class="o">.</span><span class="n">parameters</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;These argument names weren&#39;t found in the signature: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>


<div class="viewcode-block" id="common_and_diff_argnames"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.common_and_diff_argnames">[docs]</a><span class="k">def</span> <span class="nf">common_and_diff_argnames</span><span class="p">(</span><span class="n">func1</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">func2</span><span class="p">:</span> <span class="n">callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get list of argument names that are common to two functions, as well as the two lists of names that are different</span>

<span class="sd">    Args:</span>
<span class="sd">        func1: First function</span>
<span class="sd">        func2: Second function</span>

<span class="sd">    Returns: A dict with fields &#39;common&#39;, &#39;func1_not_func2&#39;, and &#39;func2_not_func1&#39;</span>

<span class="sd">    &gt;&gt;&gt; def f(t, h, i, n, k): ...</span>
<span class="sd">    &gt;&gt;&gt; def g(t, w, i, c, e): ...</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(f, g)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;], &#39;func2_not_func1&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; common_and_diff_argnames(g, f)</span>
<span class="sd">    {&#39;common&#39;: [&#39;t&#39;, &#39;i&#39;], &#39;func1_not_func2&#39;: [&#39;w&#39;, &#39;c&#39;, &#39;e&#39;], &#39;func2_not_func1&#39;: [&#39;h&#39;, &#39;n&#39;, &#39;k&#39;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func1</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func2</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;common&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func1_not_func2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p1</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p2</span><span class="p">],</span>
        <span class="s1">&#39;func2_not_func1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">p2</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">p1</span><span class="p">],</span>
    <span class="p">}</span></div>


<span class="n">dflt_name_for_kind</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">arg_order_for_param_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;annotation&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="set_signature_of_func"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.set_signature_of_func">[docs]</a><span class="k">def</span> <span class="nf">set_signature_of_func</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set the signature of a function, with sugar.</span>

<span class="sd">    Args:</span>
<span class="sd">        func: Function whose signature you want to set</span>
<span class="sd">        signature: A list of parameter specifications. This could be an inspect.Parameter object or anything that</span>
<span class="sd">            the mk_param function can resolve into an inspect.Parameter object.</span>
<span class="sd">        return_annotation: Passed on to inspect.Signature.</span>
<span class="sd">        __validate_parameters__: Passed on to inspect.Signature.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None (but sets the signature of the input function)</span>

<span class="sd">    &gt;&gt;&gt; import inspect</span>
<span class="sd">    &gt;&gt;&gt; def foo(*args, **kwargs):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (*args, **kwargs)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, (&#39;b&#39;, None), (&#39;c&#39;, 42, int)])  # specifying defaults and annotations</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b=None, c: int = 42)&gt;</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(foo, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (a, b, c) -&gt; str&gt;</span>
<span class="sd">    &gt;&gt;&gt; # But you can always specify parameters the &quot;long&quot; way</span>
<span class="sd">    &gt;&gt;&gt; set_signature_of_func(</span>
<span class="sd">    ...  foo,</span>
<span class="sd">    ...  [inspect.Parameter(name=&#39;kws&#39;, kind=inspect.Parameter.VAR_KEYWORD)], return_annotation=str)</span>
<span class="sd">    &gt;&gt;&gt; inspect.signature(foo)</span>
<span class="sd">    &lt;Signature (**kws) -&gt; str&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
        <span class="n">parameters</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="n">__validate_parameters__</span><span class="o">=</span><span class="n">__validate_parameters__</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span></div>
    <span class="c1"># Not returning func so it&#39;s clear(er) that the function is transformed in place</span>


<span class="c1">########################################################################################################################</span>
<span class="c1"># Manual construction of missing signatures ############################################################################</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">sigs_for_sigless_builtin_name</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;__build_class__&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># __build_class__(func, name, /, *bases, [metaclass], **kwds) -&gt; class</span>
    <span class="s1">&#39;__import__&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span>
    <span class="s1">&#39;bool&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bool(x) -&gt; bool</span>
    <span class="s1">&#39;breakpoint&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># breakpoint(*args, **kws)</span>
    <span class="s1">&#39;bytearray&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bytearray(iterable_of_ints) -&gt; bytearray</span>
    <span class="c1"># bytearray(string, encoding[, errors]) -&gt; bytearray</span>
    <span class="c1"># bytearray(bytes_or_buffer) -&gt; mutable copy of bytes_or_buffer</span>
    <span class="c1"># bytearray(int) -&gt; bytes array of size given by the parameter initialized with null bytes</span>
    <span class="c1"># bytearray() -&gt; empty bytes array</span>
    <span class="s1">&#39;bytes&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># bytes(iterable_of_ints) -&gt; bytes</span>
    <span class="c1"># bytes(string, encoding[, errors]) -&gt; bytes</span>
    <span class="c1"># bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer</span>
    <span class="c1"># bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes</span>
    <span class="c1"># bytes() -&gt; empty bytes object</span>
    <span class="s1">&#39;classmethod&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># classmethod(function) -&gt; method</span>
    <span class="s1">&#39;dict&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># dict() -&gt; new empty dictionary</span>
    <span class="c1"># dict(mapping) -&gt; new dictionary initialized from a mapping object&#39;s</span>
    <span class="c1"># dict(iterable) -&gt; new dictionary initialized as if via:</span>
    <span class="c1"># dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs</span>
    <span class="s1">&#39;dir&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># dir([object]) -&gt; list of strings</span>
    <span class="s1">&#39;filter&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># filter(function or None, iterable) --&gt; filter object</span>
    <span class="s1">&#39;frozenset&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># frozenset() -&gt; empty frozenset object</span>
    <span class="c1"># frozenset(iterable) -&gt; frozenset object</span>
    <span class="s1">&#39;getattr&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># getattr(object, name[, default]) -&gt; value</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># int([x]) -&gt; integer</span>
    <span class="c1"># int(x, base=10) -&gt; integer</span>
    <span class="s1">&#39;iter&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># iter(iterable) -&gt; iterator</span>
    <span class="c1"># iter(callable, sentinel) -&gt; iterator</span>
    <span class="s1">&#39;map&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># map(func, *iterables) --&gt; map object</span>
    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># max(iterable, *[, default=obj, key=func]) -&gt; value</span>
    <span class="c1"># max(arg1, arg2, *args, *[, key=func]) -&gt; value</span>
    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># min(iterable, *[, default=obj, key=func]) -&gt; value</span>
    <span class="c1"># min(arg1, arg2, *args, *[, key=func]) -&gt; value</span>
    <span class="s1">&#39;next&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># next(iterator[, default])</span>
    <span class="s1">&#39;print&#39;</span><span class="p">:</span> <span class="n">signature</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">False</span><span class="p">:</span> <span class="o">...</span>
    <span class="p">),</span>
    <span class="c1"># print(value, ..., sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</span>
    <span class="s1">&#39;range&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># range(stop) -&gt; range object</span>
    <span class="c1"># range(start, stop[, step]) -&gt; range object</span>
    <span class="s1">&#39;set&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># set() -&gt; new empty set object</span>
    <span class="c1"># set(iterable) -&gt; new set object</span>
    <span class="s1">&#39;slice&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># slice(stop)</span>
    <span class="c1"># slice(start, stop[, step])</span>
    <span class="s1">&#39;staticmethod&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># staticmethod(function) -&gt; method</span>
    <span class="s1">&#39;str&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># str(object=&#39;&#39;) -&gt; str</span>
    <span class="c1"># str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span>
    <span class="s1">&#39;super&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># super() -&gt; same as super(__class__, &lt;first argument&gt;)</span>
    <span class="c1"># super(type) -&gt; unbound super object</span>
    <span class="c1"># super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span>
    <span class="c1"># super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span>
    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># type(object_or_name, bases, dict)</span>
    <span class="c1"># type(object) -&gt; the object&#39;s type</span>
    <span class="c1"># type(name, bases, dict) -&gt; a new type</span>
    <span class="s1">&#39;vars&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># vars([object]) -&gt; dictionary</span>
    <span class="s1">&#39;zip&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># zip(*iterables) --&gt; A zip object yielding tuples until an input is exhausted.</span>
<span class="p">}</span>

<span class="c1">############# Tools for testing ########################################################################################</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>


<div class="viewcode-block" id="param_for_kind"><a class="viewcode-back" href="../../module_docs/dol/signatures.html#dol.signatures.param_for_kind">[docs]</a><span class="k">def</span> <span class="nf">param_for_kind</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;positional_or_keyword&#39;</span><span class="p">,</span>
    <span class="n">with_default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">annotation</span><span class="o">=</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function to easily and flexibly make inspect.Parameter objects for testing.</span>

<span class="sd">    It&#39;s annoying to have to compose parameters from scratch to testing things.</span>
<span class="sd">    This tool should help making it less annoying.</span>

<span class="sd">    &gt;&gt;&gt; list(map(param_for_kind, param_kinds))</span>
<span class="sd">    [&lt;Parameter &quot;POSITIONAL_ONLY&quot;&gt;, &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;, &lt;Parameter &quot;VAR_POSITIONAL&quot;&gt;, &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;, &lt;Parameter &quot;VAR_KEYWORD&quot;&gt;]</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword()</span>
<span class="sd">    &lt;Parameter &quot;POSITIONAL_OR_KEYWORD&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.positional_or_keyword(&#39;foo&#39;)</span>
<span class="sd">    &lt;Parameter &quot;foo&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only()</span>
<span class="sd">    &lt;Parameter &quot;KEYWORD_ONLY&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; param_for_kind.keyword_only(&#39;baz&#39;, with_default=True)</span>
<span class="sd">    &lt;Parameter &quot;baz=&#39;dflt_keyword_only&#39;&quot;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">kind_obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="n">kind</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">kind_obj</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">default</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;dflt_</span><span class="si">{</span><span class="n">kind</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">with_default</span> <span class="ow">and</span> <span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;var_positional&#39;</span><span class="p">,</span> <span class="s1">&#39;var_keyword&#39;</span><span class="p">}</span>
        <span class="k">else</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind_obj</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">)</span></div>


<span class="n">param_kinds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">x</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>

<span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">param_kinds</span><span class="p">:</span>
    <span class="n">lower_kind</span> <span class="o">=</span> <span class="n">kind</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">))</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">,</span> <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">lower_kind</span><span class="p">),</span>
        <span class="s1">&#39;with_default&#39;</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="s1">&#39;with_default&#39;</span><span class="p">),</span>
        <span class="n">lower_kind</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">param_for_kind</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">with_default</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">dol</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/core.html">dol.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../dol.html">dol</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>