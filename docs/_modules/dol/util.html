<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.util &mdash; dol 0.1.143 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/paths.html">dol.tests.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_fanout_stores.html">dol.tests.test_fanout_stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dol.html">dol</a></li>
      <li class="breadcrumb-item active">dol.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;General util objects&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">update_wrapper</span> <span class="k">as</span> <span class="n">_update_wrapper</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span> <span class="k">as</span> <span class="n">_wraps</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partialmethod</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">WRAPPER_ASSIGNMENTS</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>


<span class="c1"># monkey patching WRAPPER_ASSIGNMENTS to get &quot;proper&quot; wrapping (adding defaults and kwdefaults</span>
<span class="n">wrapper_assignments</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span> <span class="s1">&#39;__defaults__&#39;</span><span class="p">,</span> <span class="s1">&#39;__kwdefaults__&#39;</span><span class="p">)</span>

<span class="n">update_wrapper</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_update_wrapper</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>
<span class="n">wraps</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_wraps</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">wrapper_assignments</span><span class="p">)</span>

<span class="n">exhaust</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">deque</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<div class="viewcode-block" id="add_as_attribute_of"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.add_as_attribute_of">[docs]</a><span class="k">def</span> <span class="nf">add_as_attribute_of</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator that adds a function as an attribute of a container object ``obj``.</span>

<span class="sd">    If no ``name`` is given, the ``__name__`` of the function will be used, with a</span>
<span class="sd">    leading underscore removed. This is useful for adding helper functions to main</span>
<span class="sd">    &quot;container&quot; functions without polluting the namespace of the module, at least</span>
<span class="sd">    from the point of view of imports and tab completion.</span>

<span class="sd">    &gt;&gt;&gt; def foo():</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @add_as_attribute_of(foo)</span>
<span class="sd">    ... def _helper():</span>
<span class="sd">    ...    pass</span>
<span class="sd">    &gt;&gt;&gt; hasattr(foo, &#39;helper&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; callable(foo.helper)</span>
<span class="sd">    True</span>

<span class="sd">    In reality, any object that has a ``__name__`` can be added to the attribute of</span>
<span class="sd">    ``obj``, but the intention is to add helper functions to main &quot;container&quot; functions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">attrname</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">attrname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attrname</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># remove leading underscore</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attrname</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">return</span> <span class="n">_decorator</span></div>


<span class="c1"># TODO: Deprecate? More complete version here: dol.pat.path_get</span>
<span class="c1">#  Could argue to keep chain_get because simple and straightforward</span>
<span class="c1">#  https://github.com/i2mint/dol/blob/7fc78634ef5a6a11ab8417e7fa8a007852699851/dol/paths.py#L118</span>
<div class="viewcode-block" id="chain_get"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.chain_get">[docs]</a><span class="k">def</span> <span class="nf">chain_get</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the ``d[key]`` value for the first ``key`` in ``keys`` that is in ``d``, and default if none are found</span>

<span class="sd">    Note: Think of ``collections.ChainMap`` where you can look for a single key in a sequence of maps until we find it.</span>
<span class="sd">    Here we look for a sequence of keys in a single map, stopping as soon as we find a key that the map has.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;here&#39;: &#39;&amp;&#39;, &#39;there&#39;: &#39;and&#39;, &#39;every&#39;: &#39;where&#39;}</span>
<span class="sd">    &gt;&gt;&gt; chain_get(d, [&#39;not there&#39;, &#39;not there either&#39;, &#39;there&#39;, &#39;every&#39;])</span>
<span class="sd">    &#39;and&#39;</span>

<span class="sd">    Notice how ``&#39;not there&#39;`` and ``&#39;not there either&#39;`` are skipped, ``&#39;there&#39;`` is found and used to retrieve</span>
<span class="sd">    the value, and ``&#39;every&#39;`` is not even checked (because ``&#39;there&#39;`` was found).</span>
<span class="sd">    If non of the keys are found, ``None`` is returned by default.</span>

<span class="sd">    &gt;&gt;&gt; assert chain_get(d, (&#39;none&#39;, &#39;of&#39;, &#39;these&#39;)) is None</span>

<span class="sd">    You can change this default though:</span>

<span class="sd">    &gt;&gt;&gt; chain_get(d, (&#39;none&#39;, &#39;of&#39;, &#39;these&#39;), default=&#39;Not Found&#39;)</span>
<span class="sd">    &#39;Not Found&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">default</span></div>


<div class="viewcode-block" id="Literal"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.Literal">[docs]</a><span class="k">class</span> <span class="nc">Literal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An object to indicate that the value should be considered literally.</span>

<span class="sd">    &gt;&gt;&gt; t = Literal(42)</span>
<span class="sd">    &gt;&gt;&gt; t.get_val()</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; t()</span>
<span class="sd">    42</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>

<div class="viewcode-block" id="Literal.get_val"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.Literal.get_val">[docs]</a>    <span class="k">def</span> <span class="nf">get_val</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the value wrapped by Literal instance.</span>

<span class="sd">        One might want to use ``literal.get_val()`` instead ``literal()`` to get the</span>
<span class="sd">        value a ``Literal`` is wrapping because ``.get_val`` is more explicit.</span>

<span class="sd">        That said, with a bit of hesitation, we allow the ``literal()`` form as well</span>
<span class="sd">        since it is useful in situations where we need to use a callback function to</span>
<span class="sd">        get a value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">get_val</span></div>


<span class="k">def</span> <span class="nf">_isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The same as the builtin isinstance, but without the position only restriction,</span>
<span class="sd">    allowing us to use partial to define filter functions for specific types</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">)</span>


<div class="viewcode-block" id="instance_checker"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.instance_checker">[docs]</a><span class="k">def</span> <span class="nf">instance_checker</span><span class="p">(</span><span class="o">*</span><span class="n">types</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a filter function that checks the type of an object.</span>

<span class="sd">    &gt;&gt;&gt; f = instance_checker(int, float)</span>
<span class="sd">    &gt;&gt;&gt; f(1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f(1.0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;1.0&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">_isinstance</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="o">=</span><span class="n">types</span><span class="p">)</span></div>


<div class="viewcode-block" id="not_a_mac_junk_path"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.not_a_mac_junk_path">[docs]</a><span class="k">def</span> <span class="nf">not_a_mac_junk_path</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function that will tell you if the path is not a mac junk path/</span>
<span class="sd">    More precisely, doesn&#39;t end with &#39;.DS_Store&#39; or have a `__MACOSX` folder somewhere</span>
<span class="sd">    on it&#39;s way.</span>

<span class="sd">    This is usually meant to be used with `filter` or `filt_iter` to &quot;filter in&quot; only</span>
<span class="sd">    those actually wanted files (not the junk that mac writes to your filesystem).</span>

<span class="sd">    These files annoyingly show up often in zip files, and are usually unwanted.</span>

<span class="sd">    See https://apple.stackexchange.com/questions/239578/compress-without-ds-store-and-macosx</span>

<span class="sd">    &gt;&gt;&gt; paths = [&#39;A/normal/path&#39;, &#39;A/__MACOSX/path&#39;, &#39;path/ending/in/.DS_Store&#39;, &#39;foo/b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(not_a_mac_junk_path, paths))</span>
<span class="sd">    [&#39;A/normal/path&#39;, &#39;foo/b&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.DS_Store&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;__MACOSX&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">sep</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># This is indeed math junk (so filter out)</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># this is not mac junk (you can keep it)</span></div>


<div class="viewcode-block" id="inject_method"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.inject_method">[docs]</a><span class="k">def</span> <span class="nf">inject_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_function</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    method_function could be:</span>
<span class="sd">        * a function</span>
<span class="sd">        * a {method_name: function, ...} dict (for multiple injections)</span>
<span class="sd">        * a list of functions or (function, method_name) pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_function</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span>
        <span class="n">method_function</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;method_function (the second argument) is supposed to be a callable!&#39;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">method_name</span><span class="p">,</span> <span class="nb">str</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;method_name (the third argument) is supposed to be a string!&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">method_function</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">method_function</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">method_function</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span></div>


<span class="k">def</span> <span class="nf">_disabled_clear_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The clear method is disabled to make dangerous difficult.</span>
<span class="sd">    You don&#39;t want to delete your whole DB</span>
<span class="sd">    If you really want to delete all your data, you can do so by doing something like this:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        for k in self:</span>
<span class="sd">            del self[k]</span>
<span class="sd">        </span>

<span class="sd">    or (in some cases)</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        for k in self:</span>
<span class="sd">            try:</span>
<span class="sd">                del self[k]</span>
<span class="sd">            except KeyError:</span>
<span class="sd">                pass</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Instance of </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="o">.</span><span class="vm">__doc__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="c1"># to be able to check if clear is disabled (see ensure_clear_method function for example):</span>
<span class="n">_disabled_clear_method</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="has_enabled_clear_method"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.has_enabled_clear_method">[docs]</a><span class="k">def</span> <span class="nf">has_enabled_clear_method</span><span class="p">(</span><span class="n">store</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns True iff obj has a clear method that is enabled (i.e. not disabled)&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s1">&#39;clear&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>  <span class="c1"># has a clear method...</span>
        <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="o">.</span><span class="n">clear</span><span class="p">,</span> <span class="s1">&#39;disabled&#39;</span><span class="p">)</span>  <span class="c1"># that doesn&#39;t have a disabled attribute</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="n">store</span><span class="o">.</span><span class="n">clear</span><span class="o">.</span><span class="n">disabled</span>
    <span class="p">)</span>  <span class="c1"># ... or if it does, than it must not be == True</span></div>


<span class="k">def</span> <span class="nf">_delete_keys_one_by_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;clear the entire store (delete all keys)&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_delete_keys_one_by_one_with_keyerror_supressed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;clear the entire store (delete all keys), ignoring KeyErrors&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="n">_delete_keys_one_by_one</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">_delete_keys_one_by_one_with_keyerror_supressed</span><span class="o">.</span><span class="n">disabled</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># Note: Pipe code is completely independent (with inspect imports signature &amp; Signature)</span>
<span class="c1">#  If you only need simple pipelines, use this, or even copy/paste it where needed.</span>
<span class="c1"># TODO: Public interface mis-aligned with i2. funcs list here, in i2 it&#39;s dict. Align?</span>
<span class="c1">#  If we do so, it would be a breaking change since any dependents that expect funcs</span>
<span class="c1">#  to be a list of funcs will iterate over a iterable of names instead.</span>
<div class="viewcode-block" id="Pipe"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.Pipe">[docs]</a><span class="k">class</span> <span class="nc">Pipe</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple function composition. That is, gives you a callable that implements input -&gt; f_1 -&gt; ... -&gt; f_n -&gt; output.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b=2):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; f = Pipe(foo, lambda x: print(f&quot;x: {x}&quot;))</span>
<span class="sd">    &gt;&gt;&gt; f(3)</span>
<span class="sd">    x: 5</span>
<span class="sd">    &gt;&gt;&gt; len(f)</span>
<span class="sd">    2</span>

<span class="sd">    You can name functions, but this would just be for documentation purposes.</span>
<span class="sd">    The names are completely ignored.</span>

<span class="sd">    &gt;&gt;&gt; g = Pipe(</span>
<span class="sd">    ...     add_numbers = lambda x, y: x + y,</span>
<span class="sd">    ...     multiply_by_2 = lambda x: x * 2,</span>
<span class="sd">    ...     stringify = str</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; g(2, 3)</span>
<span class="sd">    &#39;10&#39;</span>
<span class="sd">    &gt;&gt;&gt; len(g)</span>
<span class="sd">    3</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Pipe instances don&#39;t have a __name__ etc. So some expectations of normal functions are not met.</span>
<span class="sd">        - Pipe instance are pickalable (as long as the functions that compose them are)</span>

<span class="sd">    You can specify a single functions:</span>

<span class="sd">    &gt;&gt;&gt; Pipe(lambda x: x + 1)(2)</span>
<span class="sd">    3</span>

<span class="sd">    but</span>

<span class="sd">    &gt;&gt;&gt; Pipe()</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    ValueError: You need to specify at least one function!</span>

<span class="sd">    You can specify an instance name and/or doc with the special (reserved) argument</span>
<span class="sd">    names ``__name__`` and ``__doc__`` (which therefore can&#39;t be used as function names):</span>

<span class="sd">    &gt;&gt;&gt; f = Pipe(map, add_it=sum, __name__=&#39;map_and_sum&#39;, __doc__=&#39;Apply func and add&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f(lambda x: x * 10, [1, 2, 3])</span>
<span class="sd">    60</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;map_and_sum&#39;</span>
<span class="sd">    &gt;&gt;&gt; f.__doc__</span>
<span class="sd">    &#39;Apply func and add&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">funcs</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_funcs</span><span class="p">):</span>
        <span class="n">named_funcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_reserved_names</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">)</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">named_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">funcs</span>
        <span class="n">n_funcs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;You need to specify at least one function!&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">n_funcs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">other_funcs</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">first_func</span> <span class="o">=</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first_func</span><span class="p">,</span> <span class="o">*</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="n">funcs</span>
            <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">last_func</span> <span class="o">=</span> <span class="n">other_funcs</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_signature_from_first_and_last_func</span><span class="p">(</span>
            <span class="n">first_func</span><span class="p">,</span> <span class="n">last_func</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_funcs</span> <span class="o">=</span> <span class="n">first_func</span><span class="p">,</span> <span class="n">other_funcs</span>

    <span class="n">_reserved_names</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_reserved_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_funcs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">:=</span> <span class="n">named_funcs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">named_funcs</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">other_funcs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">)</span>

    <span class="n">_dflt_signature</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_signature_from_first_and_last_func</span><span class="p">(</span><span class="n">first_func</span><span class="p">,</span> <span class="n">last_func</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">input_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">first_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># function doesn&#39;t have a signature, so take default</span>
            <span class="n">input_params</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_dflt_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">last_func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># function doesn&#39;t have a signature, so take default</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">Pipe</span><span class="o">.</span><span class="n">_dflt_signature</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">input_params</span><span class="p">),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">pipe</span><span class="o">.</span><span class="n">funcs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Pipe</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="n">_flatten_pipe</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func</span>


<div class="viewcode-block" id="flatten_pipe"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.flatten_pipe">[docs]</a><span class="k">def</span> <span class="nf">flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unravel nested Pipes to get a flat &#39;sequence of functions&#39; version of input.</span>

<span class="sd">    &gt;&gt;&gt; def f(x): return x + 1</span>
<span class="sd">    &gt;&gt;&gt; def g(x): return x * 2</span>
<span class="sd">    &gt;&gt;&gt; def h(x): return x - 3</span>
<span class="sd">    &gt;&gt;&gt; a = Pipe(f, g, h)</span>
<span class="sd">    &gt;&gt;&gt; b = Pipe(f, Pipe(g, h))</span>
<span class="sd">    &gt;&gt;&gt; len(a)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; len(b)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; c = flatten_pipe(b)</span>
<span class="sd">    &gt;&gt;&gt; len(c)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; assert a(10) == b(10) == c(10) == 19</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="o">*</span><span class="n">_flatten_pipe</span><span class="p">(</span><span class="n">pipe</span><span class="p">))</span></div>


<div class="viewcode-block" id="partialclass"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.partialclass">[docs]</a><span class="k">def</span> <span class="nf">partialclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;What partial(cls, *args, **kwargs) does, but returning a class instead of an object.</span>

<span class="sd">    :param cls: Class to get the partial of</span>
<span class="sd">    :param kwargs: The kwargs to fix</span>

<span class="sd">    The raison d&#39;Ãªtre of partialclass is that it returns a type, so let&#39;s have a look at that with</span>
<span class="sd">    a useless class.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(A, type) == isinstance(partialclass(A), type) == True</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=0, b=1):</span>
<span class="sd">    ...         self.a, self.b = a, b</span>
<span class="sd">    ...     def mysum(self):</span>
<span class="sd">    ...         return self.a + self.b</span>
<span class="sd">    ...     def __repr__(self):</span>
<span class="sd">    ...         return f&quot;{self.__class__.__name__}(a={self.a}, b={self.b})&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(A, type) == isinstance(partialclass(A), type) == True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(A)) == &#39;(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; assert a.mysum() == 1</span>
<span class="sd">    &gt;&gt;&gt; assert str(a) == &#39;A(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert A(a=10).mysum() == 11</span>
<span class="sd">    &gt;&gt;&gt; assert str(A()) == &#39;A(a=0, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, b=2)</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(a=0, *, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; aa = AA()</span>
<span class="sd">    &gt;&gt;&gt; assert aa.mysum() == 2</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &#39;A(a=0, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert AA(a=1, b=3).mysum() == 4</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(3)) == &#39;A(a=3, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, a=7)</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(*, a=7, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert AA().mysum() == 8</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(a=3)) == &#39;A(a=3, b=1)&#39;</span>

<span class="sd">    Note in the last partial that since ``a`` was fixed, you need to specify the keyword ``AA(a=3)``.</span>
<span class="sd">    ``AA(3)`` won&#39;t work:</span>

<span class="sd">    &gt;&gt;&gt; AA(3)  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: __init__() got multiple values for argument &#39;a&#39;</span>

<span class="sd">    On the other hand, you can use *args to specify the fixtures:</span>

<span class="sd">    &gt;&gt;&gt; AA = partialclass(A, 22)</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA()) == &#39;A(a=22, b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(AA)) == &#39;(b=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(AA(3)) == &#39;A(a=22, b=3)&#39;</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;cls should be a type, was a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">class</span> <span class="nc">PartialClass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">copy_attrs</span><span class="p">(</span>
        <span class="n">PartialClass</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">PartialClass</span></div>


<div class="viewcode-block" id="copy_attrs"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.copy_attrs">[docs]</a><span class="k">def</span> <span class="nf">copy_attrs</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">attrs</span><span class="p">,</span> <span class="n">raise_error_if_an_attr_is_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy attributes from one object to another.</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     x = 0</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     x = 1</span>
<span class="sd">    ...     yy = 2</span>
<span class="sd">    ...     zzz = 3</span>
<span class="sd">    &gt;&gt;&gt; dict_of = lambda o: {a: getattr(o, a) for a in dir(A) if not a.startswith(&#39;_&#39;)}</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 0}</span>
<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, &#39;yy&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 0, &#39;yy&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, [&#39;x&#39;, &#39;zzz&#39;])</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;yy&#39;: 2, &#39;zzz&#39;: 3}</span>

<span class="sd">    But if you try to copy something that `B` (the source) doesn&#39;t have, copy_attrs will complain:</span>

<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, &#39;this_is_not_an_attr&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    AttributeError: type object &#39;B&#39; has no attribute &#39;this_is_not_an_attr&#39;</span>

<span class="sd">    If you tell it not to complain, it&#39;ll just ignore attributes that are not in source.</span>

<span class="sd">    &gt;&gt;&gt; copy_attrs(A, B, [&#39;nothing&#39;, &#39;here&#39;, &#39;exists&#39;], raise_error_if_an_attr_is_missing=False)</span>
<span class="sd">    &gt;&gt;&gt; dict_of(A)</span>
<span class="sd">    {&#39;x&#39;: 1, &#39;yy&#39;: 2, &#39;zzz&#39;: 3}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">attrs</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">raise_error_if_an_attr_is_missing</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">copy_attrs_from</span><span class="p">(</span><span class="n">from_obj</span><span class="p">,</span> <span class="n">to_obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Deprecated. Use copy_attrs instead.&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">copy_attrs</span><span class="p">(</span><span class="n">to_obj</span><span class="p">,</span> <span class="n">from_obj</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">to_obj</span>


<div class="viewcode-block" id="norm_kv_filt"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.norm_kv_filt">[docs]</a><span class="k">def</span> <span class="nf">norm_kv_filt</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare a boolean function to be used with `filter` when fed an iterable of (k, v) pairs.</span>

<span class="sd">    So you have a mapping. Say a dict `d`. Now you want to go through d.items(),</span>
<span class="sd">    filtering based on the keys, or the values, or both.</span>

<span class="sd">    It&#39;s not hard to do, really. If you&#39;re using a dict you might use a dict comprehension,</span>
<span class="sd">    or in the general case you might do a `filter(lambda kv: my_filt(kv[0], kv[1]), d.items())`</span>
<span class="sd">    if you have a `my_filt` that works wiith k and v, etc.</span>

<span class="sd">    But thought simple, it can become a bit muddled.</span>
<span class="sd">    `norm_kv_filt` simplifies this by allowing you to bring your own filtering boolean function,</span>
<span class="sd">    whether it&#39;s a key-based, value-based, or key-value-based one, and it will make a</span>
<span class="sd">    ready-to-use with `filter` function for you.</span>

<span class="sd">    Only thing: Your function needs to call a key `k` and a value `v`.</span>
<span class="sd">    But hey, it&#39;s alright, if you have a function that calls things differently, just do</span>
<span class="sd">    something like</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        new_filt_func = lambda k, v: your_filt_func(..., key=k, ..., value=v, ...)</span>
<span class="sd">    </span>
<span class="sd">    and all will be fine.</span>

<span class="sd">    :param kv_filt: callable (starting with signature (k), (v), or (k, v)), and returning  a boolean</span>
<span class="sd">    :return: A normalized callable.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4}</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda k: k in {&#39;b&#39;, &#39;d&#39;}), d.items()))</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda v: v &gt; 2), d.items()))</span>
<span class="sd">    [(&#39;c&#39;, 3), (&#39;d&#39;, 4)]</span>
<span class="sd">    &gt;&gt;&gt; list(filter(norm_kv_filt(lambda k, v: (v &gt; 1) &amp; (k != &#39;c&#39;)), d.items()))</span>
<span class="sd">    [(&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kv_filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># because `filter` works with a callable, or None, so we align</span>

    <span class="n">raise_msg</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;kv_filt should be callable (starting with signature (k), (v), or (k, v)),&#39;</span>
        <span class="s1">&#39;and returning  a boolean. What you gave me was </span><span class="si">{fv_filt}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">),</span> <span class="n">raise_msg</span>

    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">kv_filt</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="n">raise_msg</span>
    <span class="n">_kv_filt</span> <span class="o">=</span> <span class="n">kv_filt</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_kv_filt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;k&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">raise_msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">_kv_filt</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">raise_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__kv_filt</span><span class="p">(</span><span class="n">kv_item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">kv_filt</span><span class="p">(</span><span class="o">*</span><span class="n">kv_item</span><span class="p">)</span>

    <span class="n">__kv_filt</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">kv_filt</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">return</span> <span class="n">__kv_filt</span></div>


<span class="n">var_str_p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\W|^(?=\d)&#39;</span><span class="p">)</span>

<span class="n">Item</span> <span class="o">=</span> <span class="n">Any</span>


<div class="viewcode-block" id="add_attrs"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.add_attrs">[docs]</a><span class="k">def</span> <span class="nf">add_attrs</span><span class="p">(</span><span class="n">remember_added_attrs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">if_attr_exists</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">attrs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a function that will add attributes to an obj.</span>
<span class="sd">    Originally meant to be used as a decorator of a function, to inject</span>

<span class="sd">    &gt;&gt;&gt; from dol.util import add_attrs</span>
<span class="sd">    &gt;&gt;&gt; @add_attrs(bar=&#39;bituate&#39;, hello=&#39;world&#39;)</span>
<span class="sd">    ... def foo():</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; [x for x in dir(foo) if not x.startswith(&#39;_&#39;)]</span>
<span class="sd">    [&#39;bar&#39;, &#39;hello&#39;]</span>
<span class="sd">    &gt;&gt;&gt; foo.bar</span>
<span class="sd">    &#39;bituate&#39;</span>
<span class="sd">    &gt;&gt;&gt; foo.hello</span>
<span class="sd">    &#39;world&#39;</span>
<span class="sd">    &gt;&gt;&gt; foo._added_attrs  # Another attr was added to hold the list of attributes added (in case we need to remove them</span>
<span class="sd">    [&#39;bar&#39;, &#39;hello&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_attrs_to_func</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">attrs_added</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_val</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Attribute </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s1"> already exists in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s1">&#39;warn&#39;</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attribute </span><span class="si">{</span><span class="n">attr_name</span><span class="si">}</span><span class="s1"> already exists in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">if_attr_exists</span> <span class="o">==</span> <span class="s1">&#39;skip&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Unknown value for if_attr_exists: </span><span class="si">{</span><span class="n">if_attr_exists</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr_val</span><span class="p">)</span>
            <span class="n">attrs_added</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attr_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remember_added_attrs</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">_added_attrs</span> <span class="o">=</span> <span class="n">attrs_added</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">add_attrs_to_func</span></div>


<span class="k">def</span> <span class="nf">fullpath</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">attrs_of</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>


<div class="viewcode-block" id="format_invocation"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.format_invocation">[docs]</a><span class="k">def</span> <span class="nf">format_invocation</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a name, positional arguments, and keyword arguments, format</span>
<span class="sd">    a basic Python-style function call.</span>

<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;func&#39;, args=(1, 2), kwargs={&#39;c&#39;: 3}))</span>
<span class="sd">    func(1, 2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;a_func&#39;, args=(1,)))</span>
<span class="sd">    a_func(1)</span>
<span class="sd">    &gt;&gt;&gt; print(format_invocation(&#39;kw_func&#39;, kwargs=[(&#39;a&#39;, 1), (&#39;b&#39;, 2)]))</span>
<span class="sd">    kw_func(a=1, b=2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">a_text</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwarg_items</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="n">kw_text</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwarg_items</span><span class="p">])</span>

    <span class="n">all_args_text</span> <span class="o">=</span> <span class="n">a_text</span>
    <span class="k">if</span> <span class="n">all_args_text</span> <span class="ow">and</span> <span class="n">kw_text</span><span class="p">:</span>
        <span class="n">all_args_text</span> <span class="o">+=</span> <span class="s1">&#39;, &#39;</span>
    <span class="n">all_args_text</span> <span class="o">+=</span> <span class="n">kw_text</span>

    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">all_args_text</span><span class="p">)</span></div>


<div class="viewcode-block" id="groupby"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.groupby">[docs]</a><span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">],</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Hashable</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Groups items according to group keys updated from those items through the given</span>
<span class="sd">    (item_to_)key function.</span>

<span class="sd">    Args:</span>
<span class="sd">        items: iterable of items</span>
<span class="sd">        key: The function that computes a key from an item. Needs to return a hashable.</span>
<span class="sd">        val: An optional function that computes a val from an item. If not given, the item itself will be taken.</span>
<span class="sd">        group_factory: The function to make new (empty) group objects and accumulate group items.</span>
<span class="sd">            group_items = group_factory() will be called to make a new empty group collection</span>
<span class="sd">            group_items.append(x) will be called to add x to that collection</span>
<span class="sd">            The default is `list`</span>

<span class="sd">    Returns: A dict of {group_key: items_in_that_group, ...}</span>

<span class="sd">    See Also: regroupby, itertools.groupby, and dol.source.SequenceKvReader</span>

<span class="sd">    &gt;&gt;&gt; groupby(range(11), key=lambda x: x % 3)</span>
<span class="sd">    {0: [0, 3, 6, 9], 1: [1, 4, 7, 10], 2: [2, 5, 8]}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, len)</span>
<span class="sd">    {3: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;, &#39;in&#39;], 1: [&#39;a&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; key_map = {1: &#39;one&#39;, 2: &#39;two&#39;}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda x: key_map.get(len(x), &#39;more&#39;))</span>
<span class="sd">    {&#39;more&#39;: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], &#39;two&#39;: [&#39;is&#39;, &#39;in&#39;], &#39;one&#39;: [&#39;a&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda w: w in stopwords)</span>
<span class="sd">    {True: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], False: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]}</span>
<span class="sd">    &gt;&gt;&gt; groupby(tokens, lambda w: [&#39;words&#39;, &#39;stopwords&#39;][int(w in stopwords)])</span>
<span class="sd">    {&#39;stopwords&#39;: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">group_factory</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span></div>


<div class="viewcode-block" id="regroupby"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.regroupby">[docs]</a><span class="k">def</span> <span class="nf">regroupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_key_funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursive groupby. Applies the groupby function recursively, using a sequence of key functions.</span>

<span class="sd">    Note: The named_key_funcs argument names don&#39;t have any external effect.</span>
<span class="sd">        They just give a name to the key function, for code reading clarity purposes.</span>

<span class="sd">    See Also: groupby, itertools.groupby, and dol.source.SequenceKvReader</span>

<span class="sd">    &gt;&gt;&gt; # group by how big the number is, then by it&#39;s mod 3 value</span>
<span class="sd">    &gt;&gt;&gt; # note that named_key_funcs argument names doesn&#39;t have any external effect (but give a name to the function)</span>
<span class="sd">    &gt;&gt;&gt; regroupby([1, 2, 3, 4, 5, 6, 7], lambda x: &#39;big&#39; if x &gt; 5 else &#39;small&#39;, mod3=lambda x: x % 3)</span>
<span class="sd">    {&#39;small&#39;: {1: [1, 4], 2: [2, 5], 0: [3]}, &#39;big&#39;: {0: [6], 1: [7]}}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; word_category = lambda x: &#39;stopwords&#39; if x in stopwords else &#39;words&#39;</span>
<span class="sd">    &gt;&gt;&gt; regroupby(tokens, word_category, len)</span>
<span class="sd">    {&#39;stopwords&#39;: {3: [&#39;the&#39;], 2: [&#39;in&#39;], 1: [&#39;a&#39;]}, &#39;words&#39;: {3: [&#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;]}}</span>
<span class="sd">    &gt;&gt;&gt; regroupby(tokens, len, word_category)</span>
<span class="sd">    {3: {&#39;stopwords&#39;: [&#39;the&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;box&#39;]}, 2: {&#39;words&#39;: [&#39;is&#39;], &#39;stopwords&#39;: [&#39;in&#39;]}, 1: {&#39;stopwords&#39;: [&#39;a&#39;]}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_funcs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">named_key_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;You need to have at least one key_func&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_funcs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">groupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_funcs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">key_func</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span> <span class="o">=</span> <span class="n">key_funcs</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key_func</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">group_key</span><span class="p">:</span> <span class="n">regroupby</span><span class="p">(</span><span class="n">group_items</span><span class="p">,</span> <span class="o">*</span><span class="n">key_funcs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span></div>


<span class="n">Groups</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">GroupKey</span> <span class="o">=</span> <span class="n">Hashable</span>
<span class="n">GroupItems</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">]</span>
<span class="n">GroupReleaseCond</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">GroupKey</span><span class="p">,</span> <span class="n">GroupItems</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
    <span class="n">Callable</span><span class="p">[[</span><span class="n">Groups</span><span class="p">,</span> <span class="n">GroupKey</span><span class="p">,</span> <span class="n">GroupItems</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span>
<span class="p">]</span>


<div class="viewcode-block" id="igroupby"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.igroupby">[docs]</a><span class="k">def</span> <span class="nf">igroupby</span><span class="p">(</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Item</span><span class="p">],</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">GroupKey</span><span class="p">],</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_factory</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">GroupItems</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">group_release_cond</span><span class="p">:</span> <span class="n">GroupReleaseCond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">release_remainding</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">append_to_group_items</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">GroupItems</span><span class="p">,</span> <span class="n">Item</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="o">.</span><span class="n">append</span><span class="p">,</span>
    <span class="n">grouper_mapping</span><span class="o">=</span><span class="n">defaultdict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The generator version of dol groupby.</span>
<span class="sd">    Groups items according to group keys updated from those items through the given (item_to_)key function,</span>
<span class="sd">    yielding the groups according to a logic defined by ``group_release_cond``</span>

<span class="sd">    Args:</span>
<span class="sd">        items: iterable of items</span>
<span class="sd">        key: The function that computes a key from an item. Needs to return a hashable.</span>
<span class="sd">        val: An optional function that computes a val from an item. If not given, the item itself will be taken.</span>
<span class="sd">        group_factory: The function to make new (empty) group objects and accumulate group items.</span>
<span class="sd">            group_items = group_collector() will be called to make a new empty group collection</span>
<span class="sd">            group_items.append(x) will be called to add x to that collection</span>
<span class="sd">            The default is `list`</span>
<span class="sd">        group_release_cond: A boolean function that will be applied, at every iteration,</span>
<span class="sd">            to the accumulated items of the group that was just updated,</span>
<span class="sd">            and determines (if True) if the (group_key, group_items) should be yielded.</span>
<span class="sd">            The default is False, which results in</span>
<span class="sd">            ``lambda group_key, group_items: False`` being used.</span>
<span class="sd">        release_remainding: Once the input items have been consumed, there may still be some</span>
<span class="sd">            items in the grouping &quot;cache&quot;. ``release_remainding`` is a boolean that indicates whether</span>
<span class="sd">            the contents of this cache should be released or not.</span>

<span class="sd">    Yields: ``(group_key, items_in_that_group)`` pairs</span>


<span class="sd">    The following will group numbers according to their parity (0 for even, 1 for odd),</span>
<span class="sd">    releasing a list of numbers collected when that list reaches length 3:</span>

<span class="sd">    &gt;&gt;&gt; g = igroupby(items=range(11),</span>
<span class="sd">    ...             key=lambda x: x % 2,</span>
<span class="sd">    ...             group_release_cond=lambda k, v: len(v) == 3)</span>
<span class="sd">    &gt;&gt;&gt; list(g)</span>
<span class="sd">    [(0, [0, 2, 4]), (1, [1, 3, 5]), (0, [6, 8, 10]), (1, [7, 9])]</span>

<span class="sd">    If we specify ``release_remainding=False`` though, we won&#39;t get</span>

<span class="sd">    &gt;&gt;&gt; g = igroupby(items=range(11),</span>
<span class="sd">    ...             key=lambda x: x % 2,</span>
<span class="sd">    ...             group_release_cond=lambda k, v: len(v) == 3,</span>
<span class="sd">    ...             release_remainding=False)</span>
<span class="sd">    &gt;&gt;&gt; list(g)</span>
<span class="sd">    [(0, [0, 2, 4]), (1, [1, 3, 5]), (0, [6, 8, 10])]</span>

<span class="sd">    # &gt;&gt;&gt; grps = partial(igroupby, group_release_cond=False, release_remainding=True)</span>


<span class="sd">    Below we show that, with the default ``group_release_cond = lambda k, v: False``</span>
<span class="sd">    and release_remainding=True`` we have ``dict(igroupby(...)) == groupby(...)``</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from dol import groupby</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; kws = dict(items=range(11), key=lambda x: x % 3)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {0: [0, 3, 6, 9], 1: [1, 4, 7, 10], 2: [2, 5, 8]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; tokens = [&#39;the&#39;, &#39;fox&#39;, &#39;is&#39;, &#39;in&#39;, &#39;a&#39;, &#39;box&#39;]</span>
<span class="sd">    &gt;&gt;&gt; kws = dict(items=tokens, key=len)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {3: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], 2: [&#39;is&#39;, &#39;in&#39;], 1: [&#39;a&#39;]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; key_map = {1: &#39;one&#39;, 2: &#39;two&#39;}</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda x: key_map.get(len(x), &#39;more&#39;))</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {&#39;more&#39;: [&#39;the&#39;, &#39;fox&#39;, &#39;box&#39;], &#39;two&#39;: [&#39;is&#39;, &#39;in&#39;], &#39;one&#39;: [&#39;a&#39;]})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; stopwords = {&#39;the&#39;, &#39;in&#39;, &#39;a&#39;, &#39;on&#39;}</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda w: w in stopwords)</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {True: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], False: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]})</span>
<span class="sd">    &gt;&gt;&gt; kws.update(key=lambda w: [&#39;words&#39;, &#39;stopwords&#39;][int(w in stopwords)])</span>
<span class="sd">    &gt;&gt;&gt; assert (dict(igroupby(**kws)) == groupby(**kws)</span>
<span class="sd">    ...         == {&#39;stopwords&#39;: [&#39;the&#39;, &#39;in&#39;, &#39;a&#39;], &#39;words&#39;: [&#39;fox&#39;, &#39;is&#39;, &#39;box&#39;]})</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="n">grouper_mapping</span><span class="p">(</span><span class="n">group_factory</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">),</span> <span class="p">(</span>
        <span class="s1">&#39;group_release_cond should be callable (filter boolean function) or False. &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;Was </span><span class="si">{</span><span class="n">group_release_cond</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="n">n_group_release_cond_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_group_release_cond_args</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span> <span class="p">(</span>
        <span class="s1">&#39;group_release_cond should take two or three inputs:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="s1">&#39; - (group_key, group_items), or</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="s1">&#39; - (groups, group_key, group_items)&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;The arguments of the function you gave me are: </span><span class="si">{</span><span class="n">signature</span><span class="p">(</span><span class="n">group_release_cond</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_append_to_group_items</span> <span class="o">=</span> <span class="n">append_to_group_items</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_append_to_group_items</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">group_items</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="p">(</span><span class="n">group_items</span><span class="p">,</span> <span class="n">val</span><span class="p">(</span><span class="n">item</span><span class="p">),)</span>

    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="n">group_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">group_items</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>
        <span class="n">_append_to_group_items</span><span class="p">(</span><span class="n">group_items</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">group_release_cond</span><span class="p">(</span><span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span>
            <span class="k">del</span> <span class="n">groups</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">release_remainding</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">group_key</span><span class="p">,</span> <span class="n">group_items</span></div>


<span class="k">def</span> <span class="nf">ntup</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="str_to_var_str"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.str_to_var_str">[docs]</a><span class="k">def</span> <span class="nf">str_to_var_str</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a valid python variable string from the input string.</span>
<span class="sd">    Left untouched if already valid.</span>

<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;this_is_a_valid_var_name&#39;)</span>
<span class="sd">    &#39;this_is_a_valid_var_name&#39;</span>
<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;not valid  #)*(&amp;434&#39;)</span>
<span class="sd">    &#39;not_valid_______434&#39;</span>
<span class="sd">    &gt;&gt;&gt; str_to_var_str(&#39;99_ballons&#39;)</span>
<span class="sd">    &#39;_99_ballons&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">var_str_p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="fill_with_dflts"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.fill_with_dflts">[docs]</a><span class="k">def</span> <span class="nf">fill_with_dflts</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">dflt_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fed up with multiline handling of dict arguments?</span>
<span class="sd">    Fed up of repeating the if d is None: d = {} lines ad nauseam (because defaults can&#39;t be dicts as a default</span>
<span class="sd">    because dicts are mutable blah blah, and the python kings don&#39;t seem to think a mutable dict is useful enough)?</span>
<span class="sd">    Well, my favorite solution would be a built-in handling of the problem of complex/smart defaults,</span>
<span class="sd">    that is visible in the code and in the docs. But for now, here&#39;s one of the tricks I use.</span>

<span class="sd">    Main use is to handle defaults of function arguments. Say you have a function `func(d=None)` and you want</span>
<span class="sd">    `d` to be a dict that has at least the keys `foo` and `bar` with default values 7 and 42 respectively.</span>
<span class="sd">    Then, in the beginning of your function code you&#39;ll say:</span>

<span class="sd">        d = fill_with_dflts(d, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>

<span class="sd">    See examples to know how to use it.</span>

<span class="sd">    ATTENTION: A shallow copy of the dict is made. Know how that affects you (or not).</span>
<span class="sd">    ATTENTION: This is not recursive: It won&#39;t be filling any nested fields with defaults.</span>

<span class="sd">    Args:</span>
<span class="sd">        d: The dict you want to &quot;fill&quot;</span>
<span class="sd">        dflt_dict: What to fill it with (a {k: v, ...} dict where if k is missing in d, you&#39;ll get a new field k, with</span>
<span class="sd">            value v.</span>

<span class="sd">    Returns:</span>
<span class="sd">        a dict with the new key:val entries (if the key was missing in d).</span>

<span class="sd">    &gt;&gt;&gt; fill_with_dflts(None)</span>
<span class="sd">    {}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts(None, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts({}, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 42}</span>
<span class="sd">    &gt;&gt;&gt; fill_with_dflts({&#39;b&#39;: 1000}, {&#39;a&#39;: 7, &#39;b&#39;: 42})</span>
<span class="sd">    {&#39;a&#39;: 7, &#39;b&#39;: 1000}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">dflt_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dflt_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dflt_dict</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<span class="c1"># Note: Had replaced with cached_property (new in 3.8)</span>
<span class="c1"># if not sys.version_info &gt;= (3, 8):</span>
<span class="c1">#     from functools import cached_property</span>
<span class="c1"># # etc...</span>
<span class="c1"># But then I realized that the way cached_property is implemented, pycharm does not see the properties (lint)</span>
<span class="c1"># So I&#39;m reverting to lazyprop</span>
<span class="c1"># TODO: Keep track of the evolution of functools.cached_property and compare performance.</span>
<div class="viewcode-block" id="lazyprop"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.lazyprop">[docs]</a><span class="k">class</span> <span class="nc">lazyprop</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor implementation of lazyprop (cached property).</span>
<span class="sd">    Made based on David Beazley&#39;s &quot;Python Cookbook&quot; book and enhanced with boltons.cacheutils ideas.</span>

<span class="sd">    &gt;&gt;&gt; class Test:</span>
<span class="sd">    ...     def __init__(self, a):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     @lazyprop</span>
<span class="sd">    ...     def len(self):</span>
<span class="sd">    ...         print(&#39;generating &quot;len&quot;&#39;)</span>
<span class="sd">    ...         return len(self.a)</span>
<span class="sd">    &gt;&gt;&gt; t = Test([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4], &#39;len&#39;: 5}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; # But careful when using lazyprop that no one will change the value of a without deleting the property first</span>
<span class="sd">    &gt;&gt;&gt; t.a = [0, 1, 2]  # if we change a...</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... we still get the old cached value of len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; del t.len  # if we delete the len prop</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... then len being recomputed again</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__isabstractmethod__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__isabstractmethod__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1"> func=</span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">import</span> <span class="nn">weakref</span>


<span class="nd">@wraps</span><span class="p">(</span><span class="n">lru_cache</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">memoized_method</span><span class="p">(</span><span class="o">*</span><span class="n">lru_args</span><span class="p">,</span> <span class="o">**</span><span class="n">lru_kwargs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapped_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># Storing the wrapped method inside the instance since a strong reference to self would not allow it to die.</span>
            <span class="n">self_weak</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="nd">@lru_cache</span><span class="p">(</span><span class="o">*</span><span class="n">lru_args</span><span class="p">,</span> <span class="o">**</span><span class="n">lru_kwargs</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">cached_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">self_weak</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">cached_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cached_method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapped_func</span>

    <span class="k">return</span> <span class="n">decorator</span>


<div class="viewcode-block" id="lazyprop_w_sentinel"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.lazyprop_w_sentinel">[docs]</a><span class="k">class</span> <span class="nc">lazyprop_w_sentinel</span><span class="p">(</span><span class="n">lazyprop</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A descriptor implementation of lazyprop (cached property).</span>
<span class="sd">    Inserts a `self.func.__name__ + &#39;__cache_active&#39;` attribute</span>

<span class="sd">    &gt;&gt;&gt; class Test:</span>
<span class="sd">    ...     def __init__(self, a):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     @lazyprop_w_sentinel</span>
<span class="sd">    ...     def len(self):</span>
<span class="sd">    ...         print(&#39;generating &quot;len&quot;&#39;)</span>
<span class="sd">    ...         return len(self.a)</span>
<span class="sd">    &gt;&gt;&gt; t = Test([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; lazyprop_w_sentinel.cache_is_active(t, &#39;len&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__  # let&#39;s look under the hood</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; t.len</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; lazyprop_w_sentinel.cache_is_active(t, &#39;len&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; t.len  # notice there&#39;s no &#39;generating &quot;len&quot;&#39; print this time!</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; t.__dict__  # let&#39;s look under the hood</span>
<span class="sd">    {&#39;a&#39;: [0, 1, 2, 3, 4], &#39;len&#39;: 5, &#39;sentinel_of__len&#39;: True}</span>
<span class="sd">    &gt;&gt;&gt; # But careful when using lazyprop that no one will change the value of a without deleting the property first</span>
<span class="sd">    &gt;&gt;&gt; t.a = [0, 1, 2]  # if we change a...</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... we still get the old cached value of len</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; del t.len  # if we delete the len prop</span>
<span class="sd">    &gt;&gt;&gt; t.len  # ... then len being recomputed again</span>
<span class="sd">    generating &quot;len&quot;</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">sentinel_prefix</span> <span class="o">=</span> <span class="s1">&#39;sentinel_of__&#39;</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span>
                <span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sentinel_prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">True</span>
            <span class="p">)</span>  <span class="c1"># my hack</span>
            <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">cache_is_active</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">sentinel_prefix</span> <span class="o">+</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">Struct</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_val_dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">MutableStruct</span><span class="p">(</span><span class="n">Struct</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">attr_val_dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;The attribute </span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s1"> already exists. Delete it if you want to reuse it!&#39;</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">attr_val_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>


<div class="viewcode-block" id="max_common_prefix"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.max_common_prefix">[docs]</a><span class="k">def</span> <span class="nf">max_common_prefix</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of strings (or other sliceable sequences), returns the longest common prefix</span>
<span class="sd">    </span>
<span class="sd">    :param a: list-like of strings</span>
<span class="sd">    :return: the smallest common prefix of all strings in a</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Note: Try to optimize by using a min_max function to give me both in one pass. The current version is still faster</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">s2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">s1</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">s1</span></div>


<span class="k">class</span> <span class="nc">SimpleProperty</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">d</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">obj</span><span class="o">.</span><span class="n">d</span>


<span class="k">class</span> <span class="nc">DelegatedAttribute</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delegate_name</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span> <span class="o">=</span> <span class="n">attr_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delegate_name</span> <span class="o">=</span> <span class="n">delegate_name</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return instance.delegate.attr</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># instance.delegate.attr = value</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delete__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">delegate</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delegate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">delegate_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># def __call__(self, instance, *args, **kwargs):</span>
    <span class="c1">#     return self.delegate(instance)(*args, **kwargs)</span>


<span class="k">def</span> <span class="nf">delegate_as</span><span class="p">(</span><span class="n">delegate_cls</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s1">&#39;delegate&#39;</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(),</span> <span class="n">exclude</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Didn&#39;t manage to make this work fully&quot;</span><span class="p">)</span>
    <span class="c1"># turn include and ignore into sets, if they aren&#39;t already</span>
    <span class="n">include</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">include</span><span class="p">)</span>
    <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
    <span class="n">delegate_attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">delegate_cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">attributes</span> <span class="o">=</span> <span class="n">include</span> <span class="o">|</span> <span class="n">delegate_attrs</span> <span class="o">-</span> <span class="n">exclude</span>

    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># create property for storing the delegate</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="nb">property</span><span class="p">())</span>
        <span class="c1"># don&#39;t bother adding attributes that the class already has</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">attributes</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="c1"># set all the attributes</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">DelegatedAttribute</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span>

    <span class="k">return</span> <span class="n">inner</span>


<span class="k">class</span> <span class="nc">HashableMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ImmutableMixin</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_immutable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;object is immutable&#39;</span><span class="p">)</span>

    <span class="fm">__setitem__</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="fm">__delitem__</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">clear</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">update</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">setdefault</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">pop</span> <span class="o">=</span> <span class="n">_immutable</span>
    <span class="n">popitem</span> <span class="o">=</span> <span class="n">_immutable</span>


<span class="c1"># TODO: Lint still considers instances of imdict to be mutable.</span>
<span class="c1">#  Probably because it still sees the mutator methods in the class definition.</span>
<span class="c1">#  Maybe I should just remove them from the class definition?</span>
<span class="c1"># TODO: Generalize to a function that makes any class immutable.</span>
<div class="viewcode-block" id="imdict"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.imdict">[docs]</a><span class="k">class</span> <span class="nc">imdict</span><span class="p">(</span><span class="n">ImmutableMixin</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">HashableMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A frozen hashable dict&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">move_files_of_folder_to_trash</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
    <span class="n">trash_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">),</span> <span class="s1">&#39;.Trash&#39;</span>
    <span class="p">)</span>  <span class="c1"># works with mac (perhaps linux too?)</span>
    <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">trash_dir</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">trash_dir</span><span class="si">}</span><span class="s1"> directory not found&#39;</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">trash_dir</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Moving to trash: </span><span class="si">{</span><span class="n">src</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundErrorNiceMessage</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">It seems you don&#39;t have required `</span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">` package for this Store.</span>
<span class="s1">Try installing it by running:</span>

<span class="s1">    pip install </span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span>
<span class="s1">    </span>
<span class="s1">in your terminal.</span>
<span class="s1">For more information: https://pypi.org/project/</span><span class="si">{</span><span class="n">exc_val</span><span class="o">.</span><span class="n">name</span><span class="si">}</span>
<span class="s1">            &#39;&#39;&#39;</span>
                <span class="p">)</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundWarning</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;It seems you don&#39;t have a required package.&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>
            <span class="c1">#             if exc_val is not None and getattr(exc_val, &#39;name&#39;, None) is not None:</span>
            <span class="c1">#                 warn(f&quot;&quot;&quot;</span>
            <span class="c1"># It seems you don&#39;t have required `{exc_val.name}` package for this Store.</span>
            <span class="c1"># This is just a warning: The process goes on...</span>
            <span class="c1"># (But, hey, if you really need that package, try installing it by running:</span>
            <span class="c1">#</span>
            <span class="c1">#     pip install {exc_val.name}</span>
            <span class="c1">#</span>
            <span class="c1"># in your terminal.</span>
            <span class="c1"># For more information: https://pypi.org/project/{exc_val.name}, or google around...</span>
            <span class="c1">#                 &quot;&quot;&quot;)</span>
            <span class="c1">#             else:</span>
            <span class="c1">#                 print(&quot;It seems you don&#39;t have a required package&quot;)</span>
            <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">ModuleNotFoundIgnore</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="num_of_required_args"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.num_of_required_args">[docs]</a><span class="k">def</span> <span class="nf">num_of_required_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number or REQUIRED arguments of a function.</span>

<span class="sd">    Contrast the behavior below with that of ``num_of_args``, which counts all</span>
<span class="sd">    parameters, including the variadics and defaulted ones.</span>

<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, b, c: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, b, c=3: None)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; num_of_required_args(lambda a, *args, b, c=1, d=2, **kwargs: None)</span>
<span class="sd">    2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var_param_kinds</span> <span class="o">=</span> <span class="p">{</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">,</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="mi">1</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="num_of_args"><a class="viewcode-back" href="../../module_docs/dol/util.html#dol.base.num_of_args">[docs]</a><span class="k">def</span> <span class="nf">num_of_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of arguments (parameters) of the function.</span>

<span class="sd">    Contrast the behavior below with that of ``num_of_required_args``.</span>

<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, b, c: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, b, c=3: None)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; num_of_args(lambda a, *args, b, c=1, d=2, **kwargs: None)</span>
<span class="sd">    6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>