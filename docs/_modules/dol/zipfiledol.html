<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dol.zipfiledol &mdash; dol 0.1.136 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            dol
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol.html">dol</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/appendable.html">dol.appendable</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/base.html">dol.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/caching.html">dol.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/dig.html">dol.dig</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/errors.html">dol.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/explicit.html">dol.explicit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/filesys.html">dol.filesys</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/misc.html">dol.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/mixins.html">dol.mixins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/naming.html">dol.naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/paths.html">dol.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/recipes.html">dol.recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap.html">dol.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/scrap/store_factories.html">dol.scrap.store_factories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/signatures.html">dol.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/sources.html">dol.sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/base_test.html">dol.tests.base_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/pickability_test.html">dol.tests.pickability_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/scrap.html">dol.tests.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tests/test_edge_cases.html">dol.tests.test_edge_cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/tools.html">dol.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/trans.html">dol.trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/util.html">dol.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/dol/zipfiledol.html">dol.zipfiledol</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">dol</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../dol.html">dol</a></li>
      <li class="breadcrumb-item active">dol.zipfiledol</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dol.zipfiledol</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Data object layers and other utils to work with zip files.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">zipfile</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ZipFile</span><span class="p">,</span>
    <span class="n">BadZipFile</span><span class="p">,</span>
    <span class="n">ZIP_STORED</span><span class="p">,</span>
    <span class="n">ZIP_DEFLATED</span><span class="p">,</span>
    <span class="n">ZIP_BZIP2</span><span class="p">,</span>
    <span class="n">ZIP_LZMA</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">dol.base</span> <span class="kn">import</span> <span class="n">KvReader</span><span class="p">,</span> <span class="n">KvPersister</span>
<span class="kn">from</span> <span class="nn">dol.filesys</span> <span class="kn">import</span> <span class="n">FileCollection</span><span class="p">,</span> <span class="n">Files</span>
<span class="kn">from</span> <span class="nn">dol.util</span> <span class="kn">import</span> <span class="n">lazyprop</span><span class="p">,</span> <span class="n">fullpath</span>
<span class="kn">from</span> <span class="nn">dol.sources</span> <span class="kn">import</span> <span class="n">FlatReader</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;COMPRESSION&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DFLT_COMPRESSION&#39;</span><span class="p">,</span>
    <span class="s1">&#39;compression_methods&#39;</span><span class="p">,</span>
    <span class="s1">&#39;to_zipped_bytes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;zipped_bytes_to_bytes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;to_zip_file&#39;</span><span class="p">,</span>
    <span class="s1">&#39;file_or_folder_to_zip_file&#39;</span><span class="p">,</span>
    <span class="s1">&#39;if_i_zipped_stats&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipReader&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipInfoReader&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipFilesReader&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipFilesReaderAndBytesWriter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FlatZipFilesReader&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mk_flatzips_store&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FilesOfZip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FileStreamsOfZip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipFileStreamsReader&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OverwriteNotAllowed&#39;</span><span class="p">,</span>
    <span class="s1">&#39;EmptyZipError&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ZipStore&#39;</span><span class="p">,</span>
    <span class="s1">&#39;remove_some_entries_from_zip&#39;</span><span class="p">,</span>
    <span class="s1">&#39;remove_mac_junk_from_zip&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># TODO: Do all systems have this? If not, need to choose dflt carefully</span>
<span class="c1">#  (choose dynamically?)</span>
<span class="n">DFLT_COMPRESSION</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span>
<span class="n">DFLT_ENCODING</span> <span class="o">=</span> <span class="s1">&#39;utf-8&#39;</span>


<span class="k">class</span> <span class="nc">COMPRESSION</span><span class="p">:</span>
    <span class="c1"># The numeric constant for an uncompressed archive member.</span>
    <span class="n">ZIP_STORED</span> <span class="o">=</span> <span class="n">ZIP_STORED</span>
    <span class="c1"># The numeric constant for the usual ZIP compression method. Requires zlib module.</span>
    <span class="n">ZIP_DEFLATED</span> <span class="o">=</span> <span class="n">ZIP_DEFLATED</span>
    <span class="c1"># The numeric constant for the BZIP2 compression method. Requires the bz2 module:</span>
    <span class="n">ZIP_BZIP2</span> <span class="o">=</span> <span class="n">ZIP_BZIP2</span>
    <span class="c1"># The numeric constant for the LZMA compression method. Requires the lzma module:</span>
    <span class="n">ZIP_LZMA</span> <span class="o">=</span> <span class="n">ZIP_LZMA</span>


<span class="n">compression_methods</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;stored&#39;</span><span class="p">:</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_STORED</span><span class="p">,</span>  <span class="c1"># doesn&#39;t even compress</span>
    <span class="s1">&#39;deflated&#39;</span><span class="p">:</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span><span class="p">,</span>  <span class="c1"># usual zip compression method</span>
    <span class="s1">&#39;bzip2&#39;</span><span class="p">:</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_BZIP2</span><span class="p">,</span>  <span class="c1"># BZIP2 compression method.</span>
    <span class="s1">&#39;lzma&#39;</span><span class="p">:</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_LZMA</span><span class="p">,</span>  <span class="c1"># LZMA compression method</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">take_everything</span><span class="p">(</span><span class="n">fileinfo</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="to_zipped_bytes"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.to_zipped_bytes">[docs]</a><span class="k">def</span> <span class="nf">to_zipped_bytes</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;some_bytes&#39;</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compression</span><span class="o">=</span><span class="n">DFLT_COMPRESSION</span><span class="p">,</span>
    <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">strict_timestamps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">encoding</span><span class="o">=</span><span class="n">DFLT_ENCODING</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compress input bytes, returning the compressed bytes</span>

<span class="sd">    &gt;&gt;&gt; b = b&#39;x&#39; * 1000 + b&#39;y&#39; * 1000  # 2000 (quite compressible) bytes</span>
<span class="sd">    &gt;&gt;&gt; len(b)</span>
<span class="sd">    2000</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; zipped_bytes = to_zipped_bytes(b)</span>
<span class="sd">    &gt;&gt;&gt; # Note: Compression details will be system dependent</span>
<span class="sd">    &gt;&gt;&gt; len(zipped_bytes)  # doctest: +SKIP</span>
<span class="sd">    137</span>
<span class="sd">    &gt;&gt;&gt; unzipped_bytes = zipped_bytes_to_bytes(zipped_bytes)</span>
<span class="sd">    &gt;&gt;&gt; unzipped_bytes == b  # verify that unzipped bytes are the same as the original</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; from dol.zipfiledol import compression_methods</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; zipped_bytes = to_zipped_bytes(b, compression=compression_methods[&#39;bzip2&#39;])</span>
<span class="sd">    &gt;&gt;&gt; # Note: Compression details will be system dependent</span>
<span class="sd">    &gt;&gt;&gt; len(zipped_bytes)  # doctest: +SKIP</span>
<span class="sd">    221</span>
<span class="sd">    &gt;&gt;&gt; unzipped_bytes = zipped_bytes_to_bytes(zipped_bytes)</span>
<span class="sd">    &gt;&gt;&gt; unzipped_bytes == b  # verify that unzipped bytes are the same as the original</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
        <span class="n">allowZip64</span><span class="o">=</span><span class="n">allowZip64</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="n">compresslevel</span><span class="p">,</span>
        <span class="n">strict_timestamps</span><span class="o">=</span><span class="n">strict_timestamps</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">bytes_buffer</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># if b is a string, need to convert to bytes</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">bytes_buffer</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
        <span class="n">fp</span><span class="o">.</span><span class="n">writestr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bytes_buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


<div class="viewcode-block" id="zipped_bytes_to_bytes"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.zipped_bytes_to_bytes">[docs]</a><span class="k">def</span> <span class="nf">zipped_bytes_to_bytes</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">strict_timestamps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decompress input bytes of a single file zip, returning the uncompressed bytes</span>

<span class="sd">    See ``to_zipped_bytes`` for usage examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">allowZip64</span><span class="o">=</span><span class="n">allowZip64</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="n">compresslevel</span><span class="p">,</span>
        <span class="n">strict_timestamps</span><span class="o">=</span><span class="n">strict_timestamps</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">bytes_buffer</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">bytes_buffer</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">zip_file</span><span class="p">:</span>
        <span class="n">file_list</span> <span class="o">=</span> <span class="n">zip_file</span><span class="o">.</span><span class="n">namelist</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_list</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;zipped_bytes_to_bytes only works with single file zips&#39;</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">file_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">zip_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">file_bytes</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">file_bytes</span></div>


<span class="k">def</span> <span class="nf">_filename_from_zip_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">path</span>  <span class="c1"># default</span>
    <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.zip&#39;</span><span class="p">):</span>
        <span class="n">filename</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">filename</span>


<span class="c1"># TODO: Look into pwd: Should we use it for setting pwd when pwd doesn&#39;t exist?</span>
<div class="viewcode-block" id="to_zip_file"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.to_zip_file">[docs]</a><span class="k">def</span> <span class="nf">to_zip_file</span><span class="p">(</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">zip_filepath</span><span class="p">,</span>
    <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compression</span><span class="o">=</span><span class="n">DFLT_COMPRESSION</span><span class="p">,</span>
    <span class="n">allow_overwrites</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">encoding</span><span class="o">=</span><span class="n">DFLT_ENCODING</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Zip input bytes and save to a single-file zip file.</span>

<span class="sd">    :param b: Input bytes or string</span>
<span class="sd">    :param zip_filepath: zip filepath to save the zipped input to</span>
<span class="sd">    :param filename: The name/path of the zip entry we want to save to</span>
<span class="sd">    :param encoding: In case the input is str, the encoding to use to convert to bytes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">ZipStore</span><span class="p">(</span>
        <span class="n">zip_filepath</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
        <span class="n">allow_overwrites</span><span class="o">=</span><span class="n">allow_overwrites</span><span class="p">,</span>
        <span class="n">pwd</span><span class="o">=</span><span class="n">pwd</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">_filename_from_zip_path</span><span class="p">(</span><span class="n">zip_filepath</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># if b is a string, need to convert to bytes</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="n">z</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span></div>


<div class="viewcode-block" id="file_or_folder_to_zip_file"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.file_or_folder_to_zip_file">[docs]</a><span class="k">def</span> <span class="nf">file_or_folder_to_zip_file</span><span class="p">(</span>
    <span class="n">src_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">zip_filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">compression</span><span class="o">=</span><span class="n">DFLT_COMPRESSION</span><span class="p">,</span>
    <span class="n">allow_overwrites</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Zip input bytes and save to a single-file zip file.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">zip_filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zip_filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.zip&#39;</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">ZipStore</span><span class="p">(</span>
        <span class="n">zip_filepath</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
        <span class="n">allow_overwrites</span><span class="o">=</span><span class="n">allow_overwrites</span><span class="p">,</span>
        <span class="n">pwd</span><span class="o">=</span><span class="n">pwd</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">src_path</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="n">filename</span><span class="p">]</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span><span class="o">.</span><span class="n">read_bytes</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">src_path</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">Files</span><span class="p">(</span><span class="n">src_path</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">src_path</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="if_i_zipped_stats"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.if_i_zipped_stats">[docs]</a><span class="k">def</span> <span class="nf">if_i_zipped_stats</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compress and decompress bytes with four different methods and return a dictionary</span>
<span class="sd">    of (size and time) stats.</span>

<span class="sd">    &gt;&gt;&gt; b = b&#39;x&#39; * 1000 + b&#39;y&#39; * 1000  # 2000 (quite compressible) bytes</span>
<span class="sd">    &gt;&gt;&gt; if_i_zipped_stats(b)  # doctest: +SKIP</span>
<span class="sd">    {&#39;uncompressed&#39;: {&#39;bytes&#39;: 2000,</span>
<span class="sd">      &#39;comp_time&#39;: 0,</span>
<span class="sd">      &#39;uncomp_time&#39;: 0},</span>
<span class="sd">     &#39;deflated&#39;: {&#39;bytes&#39;: 137,</span>
<span class="sd">      &#39;comp_time&#39;: 0.00015592575073242188,</span>
<span class="sd">      &#39;uncomp_time&#39;: 0.00012612342834472656},</span>
<span class="sd">     &#39;bzip2&#39;: {&#39;bytes&#39;: 221,</span>
<span class="sd">      &#39;comp_time&#39;: 0.0013129711151123047,</span>
<span class="sd">      &#39;uncomp_time&#39;: 0.0011119842529296875},</span>
<span class="sd">     &#39;lzma&#39;: {&#39;bytes&#39;: 206,</span>
<span class="sd">      &#39;comp_time&#39;: 0.0058901309967041016,</span>
<span class="sd">      &#39;uncomp_time&#39;: 0.0005228519439697266}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">time</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;uncompressed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bytes&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s1">&#39;comp_time&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;uncomp_time&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">compression</span> <span class="ow">in</span> <span class="n">compression_methods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;stored&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;uncompressed&#39;</span><span class="p">])</span>
                <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">compressed</span> <span class="o">=</span> <span class="n">to_zipped_bytes</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>
                <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;bytes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;comp_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elapsed</span>
                <span class="n">tic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">uncompressed</span> <span class="o">=</span> <span class="n">zipped_bytes_to_bytes</span><span class="p">(</span><span class="n">compressed</span><span class="p">)</span>
                <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tic</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">uncompressed</span> <span class="o">==</span> <span class="n">b</span>
                <span class="p">),</span> <span class="s1">&#39;the uncompressed bytes were different than the original&#39;</span>
                <span class="n">stats</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;uncomp_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elapsed</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">stats</span></div>


<div class="viewcode-block" id="ZipReader"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.ZipReader">[docs]</a><span class="k">class</span> <span class="nc">ZipReader</span><span class="p">(</span><span class="n">KvReader</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A KvReader to read the contents of a zip file.</span>
<span class="sd">    Provides a KV perspective of https://docs.python.org/3/library/zipfile.html</span>

<span class="sd">    ``ZipReader`` has two value categories: Directories and Files.</span>
<span class="sd">    Both categories are distinguishable by the keys, through the &quot;ends with slash&quot; convention.</span>

<span class="sd">    When a file, the value return is bytes, as usual.</span>

<span class="sd">    When a directory, the value returned is a ``ZipReader`` itself, with all params the same,</span>
<span class="sd">    except for the ``prefix``</span>
<span class="sd">     which serves `to specify the subfolder (that is, ``prefix`` acts as a filter).</span>

<span class="sd">    Note: If you get data zipped by a mac, you might get some junk along with it.</span>
<span class="sd">    Namely `__MACOSX` folders `.DS_Store` files. I won&#39;t rant about it, since others have.</span>
<span class="sd">    But you might find it useful to remove them from view. One choice is to use</span>
<span class="sd">    `dol.trans.filt_iter`</span>
<span class="sd">    to get a filtered view of the zips contents. In most cases, this should do the job:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        # applied to store instance or class:</span>
<span class="sd">        store = filt_iter(filt=lambda x: not x.startswith(&#39;__MACOSX&#39;) and &#39;.DS_Store&#39; not in x)(store)</span>


<span class="sd">    Another option is just to remove these from the zip file once and for all. In unix-like systems:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        zip -d filename.zip __MACOSX/\*</span>
<span class="sd">        zip -d filename.zip \*/.DS_Store</span>


<span class="sd">    Examples:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        # &gt;&gt;&gt; s = ZipReader(&#39;/path/to/some_zip_file.zip&#39;)</span>
<span class="sd">        # &gt;&gt;&gt; len(s)</span>
<span class="sd">        # 53432</span>
<span class="sd">        # &gt;&gt;&gt; list(s)[:3]  # the first 3 elements (well... their keys)</span>
<span class="sd">        # [&#39;odir/&#39;, &#39;odir/app/&#39;, &#39;odir/app/data/&#39;]</span>
<span class="sd">        # &gt;&gt;&gt; list(s)[-3:]  # the last 3 elements (well... their keys)</span>
<span class="sd">        # [&#39;odir/app/data/audio/d/1574287049078391/m/Ctor.json&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/audio/d/1574287049078391/m/intensity.json&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/run/status.json&#39;]</span>
<span class="sd">        # &gt;&gt;&gt; # getting a file (note that by default, you get bytes, so need to decode)</span>
<span class="sd">        # &gt;&gt;&gt; s[&#39;odir/app/data/run/status.json&#39;].decode()</span>
<span class="sd">        # b&#39;{&quot;test_phase_number&quot;: 9, &quot;test_phase&quot;: &quot;TestActions.IGNORE_TEST&quot;, &quot;session_id&quot;: 0}&#39;</span>
<span class="sd">        # &gt;&gt;&gt; # when you ask for the contents for a key that&#39;s a directory,</span>
<span class="sd">        # &gt;&gt;&gt; # you get a ZipReader filtered for that prefix:</span>
<span class="sd">        # &gt;&gt;&gt; s[&#39;odir/app/data/audio/&#39;]</span>
<span class="sd">        # ZipReader(&#39;/path/to/some_zip_file.zip&#39;, &#39;odir/app/data/audio/&#39;, {}, &lt;function</span>
<span class="sd">        take_everything at 0x1538999e0&gt;)</span>
<span class="sd">        # &gt;&gt;&gt; # Often, you only want files (not directories)</span>
<span class="sd">        # &gt;&gt;&gt; # You can filter directories out using the file_info_filt argument</span>
<span class="sd">        # &gt;&gt;&gt; s = ZipReader(&#39;/path/to/some_zip_file.zip&#39;, file_info_filt=ZipReader.FILES_ONLY)</span>
<span class="sd">        # &gt;&gt;&gt; len(s)  # compare to the 53432 above, that contained dirs too</span>
<span class="sd">        # 53280</span>
<span class="sd">        # &gt;&gt;&gt; list(s)[:3]  # first 3 keys are all files now</span>
<span class="sd">        # [&#39;odir/app/data/plc/d/1574304926795633/d/1574305026895702&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/plc/d/1574304926795633/d/1574305276853053&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/plc/d/1574304926795633/d/1574305159343326&#39;]</span>
<span class="sd">        # &gt;&gt;&gt;</span>
<span class="sd">        # &gt;&gt;&gt; # ZipReader.FILES_ONLY and ZipReader.DIRS_ONLY are just convenience filt functions</span>
<span class="sd">        # &gt;&gt;&gt; # Really, you can provide any custom one yourself.</span>
<span class="sd">        # &gt;&gt;&gt; # This filter function should take a ZipInfo object, and return True or False.</span>
<span class="sd">        # &gt;&gt;&gt; # (https://docs.python.org/3/library/zipfile.html#zipfile.ZipInfo)</span>
<span class="sd">        # &gt;&gt;&gt;</span>
<span class="sd">        # &gt;&gt;&gt; import re</span>
<span class="sd">        # &gt;&gt;&gt; p = re.compile(&#39;audio.*\.json$&#39;)</span>
<span class="sd">        # &gt;&gt;&gt; my_filt_func = lambda fileinfo: bool(p.search(fileinfo.filename))</span>
<span class="sd">        # &gt;&gt;&gt; s = ZipReader(&#39;/Users/twhalen/Downloads/2019_11_21.zip&#39;, file_info_filt=my_filt_func)</span>
<span class="sd">        # &gt;&gt;&gt; len(s)</span>
<span class="sd">        # 48</span>
<span class="sd">        # &gt;&gt;&gt; list(s)[:3]</span>
<span class="sd">        # [&#39;odir/app/data/audio/d/1574333557263758/m/Ctor.json&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/audio/d/1574333557263758/m/intensity.json&#39;,</span>
<span class="sd">        #  &#39;odir/app/data/audio/d/1574288084739961/m/Ctor.json&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zip_file</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">open_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_info_filt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Args:</span>
<span class="sd">            zip_file: A path to make ZipFile(zip_file)</span>
<span class="sd">            prefix: A prefix to filter by.</span>
<span class="sd">            open_kws:  To be used when doing a ZipFile(...).open</span>
<span class="sd">            file_info_filt: Filter for the FileInfo objects (see</span>
<span class="sd">            https://docs.python.org/3/library/zipfile.html)</span>
<span class="sd">                of the paths listed in the zip file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span> <span class="o">=</span> <span class="n">open_kws</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_info_filt</span> <span class="o">=</span> <span class="n">file_info_filt</span> <span class="ow">or</span> <span class="n">ZipReader</span><span class="o">.</span><span class="n">EVERYTHING</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="n">ZipFile</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">zip_file</span> <span class="o">=</span> <span class="n">fullpath</span><span class="p">(</span><span class="n">zip_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">zip_file</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="o">**</span><span class="n">zip_file</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">zip_file</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="o">*</span><span class="n">zip_file</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="n">zip_file</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">zip_file</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zip_file</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span> <span class="o">=</span> <span class="n">zip_file</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">for_files_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">zip_file</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">open_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_info_filt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">file_info_filt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">file_info_filt</span> <span class="o">=</span> <span class="n">ZipReader</span><span class="o">.</span><span class="n">FILES_ONLY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_file_info_filt</span> <span class="o">=</span> <span class="n">file_info_filt</span>

            <span class="k">def</span> <span class="nf">file_info_filt</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ZipReader</span><span class="o">.</span><span class="n">FILES_ONLY</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_file_info_filt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">open_kws</span><span class="p">,</span> <span class="n">file_info_filt</span><span class="p">)</span>

    <span class="c1"># TODO: Unaware of trans (filters, key trans, etc.)</span>
    <span class="nd">@lazyprop</span>
    <span class="k">def</span> <span class="nf">info_for_key</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">x</span><span class="o">.</span><span class="n">filename</span><span class="p">:</span> <span class="n">x</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="o">.</span><span class="n">infolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_info_filt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># using zip_file.infolist(), we could also filter for info (like directory/file)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_for_key</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">info_for_key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># is a directory</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_info_filt</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info_for_key</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">FILES_ONLY</span><span class="p">(</span><span class="n">fileinfo</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">fileinfo</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">DIRS_ONLY</span><span class="p">(</span><span class="n">fileinfo</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fileinfo</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">EVERYTHING</span><span class="p">(</span><span class="n">fileinfo</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_info_filt</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">args_str</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="c1"># TODO: Unaware of trans (filters, key trans, etc.)</span>
    <span class="k">def</span> <span class="nf">get_info_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ZipInfoReader</span><span class="p">(</span>
            <span class="n">zip_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">open_kws</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span><span class="p">,</span>
            <span class="n">file_info_filt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">file_info_filt</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ZipInfoReader"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.ZipInfoReader">[docs]</a><span class="k">class</span> <span class="nc">ZipInfoReader</span><span class="p">(</span><span class="n">ZipReader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="o">.</span><span class="n">getinfo</span><span class="p">(</span><span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="FilesOfZip"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.FilesOfZip">[docs]</a><span class="k">class</span> <span class="nc">FilesOfZip</span><span class="p">(</span><span class="n">ZipReader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zip_file</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">open_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">zip_file</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">open_kws</span><span class="o">=</span><span class="n">open_kws</span><span class="p">,</span>
            <span class="n">file_info_filt</span><span class="o">=</span><span class="n">ZipReader</span><span class="o">.</span><span class="n">FILES_ONLY</span><span class="p">,</span>
        <span class="p">)</span></div>


<span class="c1"># TODO: This file object item is more fundemental than file contents.</span>
<span class="c1">#  Should it be at the base?</span>
<div class="viewcode-block" id="FileStreamsOfZip"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.FileStreamsOfZip">[docs]</a><span class="k">class</span> <span class="nc">FileStreamsOfZip</span><span class="p">(</span><span class="n">FilesOfZip</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like FilesOfZip, but object returns are file streams instead.</span>
<span class="sd">    So you use it like this:</span>

<span class="sd">    .. code-block::</span>

<span class="sd">        z = FileStreamsOfZip(rootdir)</span>
<span class="sd">        with z[relpath] as fp:</span>
<span class="sd">            ...  # do stuff with fp, like fp.readlines() or such...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">open_kws</span><span class="p">)</span></div>


<div class="viewcode-block" id="ZipFilesReader"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.ZipFilesReader">[docs]</a><span class="k">class</span> <span class="nc">ZipFilesReader</span><span class="p">(</span><span class="n">FileCollection</span><span class="p">,</span> <span class="n">KvReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A local file reader whose keys are the zip filepaths of the rootdir and values are</span>
<span class="sd">    corresponding ZipReaders.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rootdir</span><span class="p">,</span>
        <span class="n">subpath</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;.+\.zip&#39;</span><span class="p">,</span>
        <span class="n">pattern_for_field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_levels</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">zip_reader</span><span class="o">=</span><span class="n">ZipReader</span><span class="p">,</span>
        <span class="o">**</span><span class="n">zip_reader_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rootdir</span><span class="p">,</span> <span class="n">subpath</span><span class="p">,</span> <span class="n">pattern_for_field</span><span class="p">,</span> <span class="n">max_levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span> <span class="o">=</span> <span class="n">zip_reader</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader_kwargs</span> <span class="o">=</span> <span class="n">zip_reader_kwargs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span> <span class="ow">is</span> <span class="n">ZipReader</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">open_kws</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file_info_filt</span><span class="o">=</span><span class="n">ZipReader</span><span class="o">.</span><span class="n">FILES_ONLY</span><span class="p">,),</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_reader_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_reader_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;FileNotFoundError: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="ZipFilesReaderAndBytesWriter"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.ZipFilesReaderAndBytesWriter">[docs]</a><span class="k">class</span> <span class="nc">ZipFilesReaderAndBytesWriter</span><span class="p">(</span><span class="n">ZipFilesReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like ZipFilesReader, but the ability to write bytes (assumed to be valid bytes of</span>
<span class="sd">    the zip format) to a key</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>


<span class="n">ZipFileReader</span> <span class="o">=</span> <span class="n">ZipFilesReader</span>  <span class="c1"># back-compatibility alias</span>


<span class="c1"># TODO: Add easy connection to ExplicitKeymapReader and other path trans and cache useful</span>
<span class="c1">#  for the folder of zips context</span>
<span class="c1"># TODO: The &quot;injection&quot; of _readers to be able to use FlatReader stinks.</span>
<div class="viewcode-block" id="FlatZipFilesReader"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.FlatZipFilesReader">[docs]</a><span class="k">class</span> <span class="nc">FlatZipFilesReader</span><span class="p">(</span><span class="n">FlatReader</span><span class="p">,</span> <span class="n">ZipFilesReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read the union of the contents of multiple zip files.</span>
<span class="sd">    A local file reader whose keys are the zip filepaths of the rootdir and values are</span>
<span class="sd">    corresponding ZipReaders.</span>

<span class="sd">    Example use case:</span>

<span class="sd">    A remote data provider creates snapshots of whatever changed (modified files and new</span>
<span class="sd">    ones...) since the last snapshot, dumping snapshot zip files in a specic</span>
<span class="sd">    accessible location.</span>

<span class="sd">    You make `remote` and `local` stores and can update your local. Then you can perform</span>
<span class="sd">    syncing actions such as:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        missing_keys = remote.keys() - local.keys()</span>
<span class="sd">        local.update({k: remote[k] for k in missing_keys})  # downloads missing snapshots</span>


<span class="sd">    The data will look something like this:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        dump_folder/</span>
<span class="sd">           2021_09_11.zip</span>
<span class="sd">           2021_09_12.zip</span>
<span class="sd">           2021_09_13.zip</span>
<span class="sd">           etc.</span>

<span class="sd">    both on remote and local.</span>

<span class="sd">    What should then local do to use this data?</span>
<span class="sd">    Unzip and merge?</span>

<span class="sd">    Well, one solution, provided through FlatZipFilesReader, is to not unzip at all,</span>
<span class="sd">    but instead, give you a store that provides you a view &quot;as if you unzipped and</span>
<span class="sd">    merged&quot;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="fm">__init__</span> <span class="o">=</span> <span class="n">ZipFilesReader</span><span class="o">.</span><span class="fm">__init__</span>

    <span class="nd">@lazyprop</span>
    <span class="k">def</span> <span class="nf">_readers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rootdir_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rootdir</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">[</span><span class="n">rootdir_len</span><span class="p">:]:</span> <span class="n">ZipFilesReader</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">ZipFilesReader</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="n">_zip_readers</span> <span class="o">=</span> <span class="n">_readers</span>  <span class="c1"># back-compatibility alias</span></div>


<span class="c1"># TODO: Refactor zipfiledol to make it possible to design FlatZipFilesReaderFromBytes</span>
<span class="c1">#  better than the following.</span>
<span class="c1">#  * init doesn&#39;t use super, but super is locked to rootdir specification</span>
<span class="c1">#  * perhaps better making _readers a lazy mapping (not precompute all FilesOfZip(v))?</span>
<span class="c1">#  * Should ZipFilesReader be generalized to take bytes instead of rootdir?</span>
<span class="c1">#  * Using .zips to delegate the what in is</span>
<span class="k">class</span> <span class="nc">FlatZipFilesReaderFromBytes</span><span class="p">(</span><span class="n">FlatReader</span><span class="p">,</span> <span class="n">FilesOfZip</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like FlatZipFilesReader but instead of sourcing with folder of zips, we source</span>
<span class="sd">    with the bytes of a zipped folder of zips&quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">FilesOfZip</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zips</span> <span class="o">=</span> <span class="n">FilesOfZip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@lazyprop</span>
    <span class="k">def</span> <span class="nf">_readers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">FilesOfZip</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zips</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<div class="viewcode-block" id="mk_flatzips_store"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.mk_flatzips_store">[docs]</a><span class="k">def</span> <span class="nf">mk_flatzips_store</span><span class="p">(</span>
    <span class="n">dir_of_zips</span><span class="p">,</span>
    <span class="n">zip_pair_path_preproc</span><span class="o">=</span><span class="nb">sorted</span><span class="p">,</span>
    <span class="n">mk_store</span><span class="o">=</span><span class="n">FlatZipFilesReader</span><span class="p">,</span>
    <span class="o">**</span><span class="n">extra_mk_store_kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A store so that you can work with a folder that has a bunch of zip files,</span>
<span class="sd">    as if they&#39;ve all been extracted in the same folder.</span>
<span class="sd">    Note that `zip_pair_path_preproc` can be used to control how to resolve key conflicts</span>
<span class="sd">    (i.e. when you get two different zip files that have a same path in their contents).</span>
<span class="sd">    The last path encountered by `zip_pair_path_preproc(zip_path_pairs)` is the one that</span>
<span class="sd">    will be used, so one should make `zip_pair_path_preproc` act accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">dol.explicit</span> <span class="kn">import</span> <span class="n">ExplicitKeymapReader</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">mk_store</span><span class="p">(</span><span class="n">dir_of_zips</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_mk_store_kwargs</span><span class="p">)</span>
    <span class="n">path_to_pair</span> <span class="o">=</span> <span class="p">{</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">zip_pair_path_preproc</span><span class="p">(</span><span class="n">z</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">ExplicitKeymapReader</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">id_of_key</span><span class="o">=</span><span class="n">path_to_pair</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">dol.paths</span> <span class="kn">import</span> <span class="n">mk_relative_path_store</span>
<span class="kn">from</span> <span class="nn">dol.util</span> <span class="kn">import</span> <span class="n">partialclass</span>

<span class="n">ZipFileStreamsReader</span> <span class="o">=</span> <span class="n">mk_relative_path_store</span><span class="p">(</span>
    <span class="n">partialclass</span><span class="p">(</span><span class="n">ZipFilesReader</span><span class="p">,</span> <span class="n">zip_reader</span><span class="o">=</span><span class="n">FileStreamsOfZip</span><span class="p">),</span> <span class="n">prefix_attr</span><span class="o">=</span><span class="s1">&#39;rootdir&#39;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ZipFileStreamsReader</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s1">&#39;ZipFileStreamsReader&#39;</span>
<span class="n">ZipFileStreamsReader</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="s1">&#39;ZipFileStreamsReader&#39;</span>
<span class="n">ZipFileStreamsReader</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="p">(</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Like ZipFilesReader, but objects returned are file streams instead.&#39;&#39;&#39;</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">dol.errors</span> <span class="kn">import</span> <span class="n">OverWritesNotAllowedError</span>


<div class="viewcode-block" id="OverwriteNotAllowed"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.OverwriteNotAllowed">[docs]</a><span class="k">class</span> <span class="nc">OverwriteNotAllowed</span><span class="p">(</span><span class="ne">FileExistsError</span><span class="p">,</span> <span class="n">OverWritesNotAllowedError</span><span class="p">):</span>
    <span class="o">...</span></div>


<div class="viewcode-block" id="EmptyZipError"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.EmptyZipError">[docs]</a><span class="k">class</span> <span class="nc">EmptyZipError</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">FileNotFoundError</span><span class="p">):</span>
    <span class="o">...</span></div>


<span class="k">class</span> <span class="nc">_EmptyZipReader</span><span class="p">(</span><span class="n">KvReader</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zip_filepath</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span> <span class="o">=</span> <span class="n">zip_filepath</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="p">()</span>

    <span class="k">def</span> <span class="nf">infolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EmptyZipError</span><span class="p">(</span>
            <span class="s1">&#39;The store is empty: ZipStore(zip_filepath=</span><span class="si">{self.zip_filepath}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">EmptyZipError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The zip file doesn&#39;t exist yet! Nothing was written in it: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># class OpenedNotExistingFile:</span>
        <span class="c1">#     zip_filepath = self.zip_filepath</span>
        <span class="c1">#</span>
        <span class="c1">#     def read(self):</span>
        <span class="c1">#         raise EmptyZipError(</span>
        <span class="c1">#             f&quot;The zip file doesn&#39;t exist yet! Nothing was written in it: {</span>
        <span class="c1">#             self.zip_filepath}&quot;)</span>
        <span class="c1">#</span>
        <span class="c1">#     def __enter__(self, ):</span>
        <span class="c1">#         return self</span>
        <span class="c1">#</span>
        <span class="c1">#     def __exit__(self, *exc):</span>
        <span class="c1">#         return False</span>
        <span class="c1">#</span>
        <span class="c1"># return OpenedNotExistingFile()</span>


<span class="c1"># TODO: Revise ZipReader and ZipFilesReader architecture and make ZipStore be a subclass of</span>
<span class="c1">#  Reader if poss</span>
<span class="c1"># TODO: What if I just want to zip a (single) file. What does dol offer for that?</span>
<span class="c1"># TODO: How about set_obj (in misc.py)? Make it recognize the .zip extension and subextension (</span>
<span class="c1">#  e.g. .txt.zip) serialize</span>
<div class="viewcode-block" id="ZipStore"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.ZipStore">[docs]</a><span class="k">class</span> <span class="nc">ZipStore</span><span class="p">(</span><span class="n">KvPersister</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Zip read and writing.</span>
<span class="sd">    When you want to read zips, there&#39;s the `FilesOfZip`, `ZipReader`, or `ZipFilesReader` we</span>
<span class="sd">    know and love.</span>

<span class="sd">    Sometimes though, you want to write to zips too. For this, we have `ZipStore`.</span>

<span class="sd">    Since ZipStore can write to a zip, it&#39;s read functionality is not going to assume static data,</span>
<span class="sd">    and cache things, as your favorite zip readers did.</span>
<span class="sd">    This, and the acrobatics need to disguise the weird zipfile into something more... key-value</span>
<span class="sd">    natural,</span>
<span class="sd">    makes for a not so efficient store, out of the box.</span>

<span class="sd">    I advise using one of the zip readers if all you need to do is read, or subclassing or</span>
<span class="sd">     wrapping ZipStore with caching layers if it is appropriate to you.</span>

<span class="sd">    Let&#39;s verify that a ZipStore can indeed write data. First, we&#39;ll set things up!</span>

<span class="sd">    &gt;&gt;&gt; from tempfile import gettempdir</span>
<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; rootdir = gettempdir()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # preparation</span>
<span class="sd">    &gt;&gt;&gt; test_zipfile = os.path.join(rootdir, &#39;zipstore_test_file.zip&#39;)</span>
<span class="sd">    &gt;&gt;&gt; if os.path.isfile(test_zipfile):</span>
<span class="sd">    ...     os.remove(test_zipfile)</span>
<span class="sd">    &gt;&gt;&gt; assert not os.path.isfile(test_zipfile)</span>

<span class="sd">    Okay, test_zipfile doesn&#39;t exist (but will soon...)</span>

<span class="sd">    &gt;&gt;&gt; z = ZipStore(test_zipfile)</span>

<span class="sd">    See that the file still doesn&#39;t exist (it will only be created when we start writing)</span>

<span class="sd">    &gt;&gt;&gt; assert not os.path.isfile(test_zipfile)</span>
<span class="sd">    &gt;&gt;&gt; list(z)  # z &quot;is&quot; empty (which makes sense?)</span>
<span class="sd">    []</span>

<span class="sd">    Now let&#39;s write something interesting (notice, it has to be in bytes):</span>

<span class="sd">    &gt;&gt;&gt; z[&#39;foo&#39;] = b&#39;bar&#39;</span>
<span class="sd">    &gt;&gt;&gt; list(z)  # now we have something in z</span>
<span class="sd">    [&#39;foo&#39;]</span>
<span class="sd">    &gt;&gt;&gt; z[&#39;foo&#39;]  # and that thing is what we put there</span>
<span class="sd">    b&#39;bar&#39;</span>

<span class="sd">    And indeed we have a zip file now:</span>

<span class="sd">    &gt;&gt;&gt; assert os.path.isfile(test_zipfile)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_zipfile_init_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">DFLT_COMPRESSION</span><span class="p">,</span>
        <span class="n">allowZip64</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">strict_timestamps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_open_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_zip64</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_writestr_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">compress_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compresslevel</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">zip_writer</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># @wraps(ZipReader.__init__)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">zip_filepath</span><span class="p">,</span>
        <span class="n">compression</span><span class="o">=</span><span class="n">DFLT_COMPRESSION</span><span class="p">,</span>
        <span class="n">allow_overwrites</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pwd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span> <span class="o">=</span> <span class="n">fullpath</span><span class="p">(</span><span class="n">zip_filepath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span> <span class="o">=</span> <span class="n">zip_filepath</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_overwrites</span> <span class="o">=</span> <span class="n">allow_overwrites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zipfile_init_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile_init_kw</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span><span class="p">,</span> <span class="n">pwd</span><span class="o">=</span><span class="n">pwd</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">files_only_filt</span><span class="p">(</span><span class="n">fileinfo</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">fileinfo</span><span class="o">.</span><span class="n">is_dir</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">zip_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ZipFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile_init_kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_EmptyZipReader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># using zip_file.infolist(), we could also filter for info (like directory/file)</span>
        <span class="k">yield from</span> <span class="p">(</span>
            <span class="n">fi</span><span class="o">.</span><span class="n">filename</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span><span class="o">.</span><span class="n">infolist</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">files_only_filt</span><span class="p">(</span><span class="n">fi</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;allow_overwrites=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_overwrites</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">args_str</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_reader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="p">(</span>
            <span class="ne">KeyError</span><span class="p">,</span>
            <span class="n">BadZipFile</span><span class="p">,</span>
        <span class="p">):</span>  <span class="c1"># BadZipFile is to catch when zip file exists, but is empty.</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># # TODO: Find better way to avoid duplicate keys!</span>
    <span class="c1"># # TODO: What&#39;s the right Error to raise</span>
    <span class="c1"># def _assert_non_existing_key(self, k):</span>
    <span class="c1">#     # if self.zip_writer is not None:</span>
    <span class="c1">#     if not self.zip_writer_opened:</span>
    <span class="c1">#         try:</span>
    <span class="c1">#             self.zip_reader.open(k)</span>
    <span class="c1">#             raise OverwriteNotAllowed(f&quot;You&#39;re not allowed to overwrite an existing key: {k}&quot;)</span>
    <span class="c1">#         except KeyError as e:</span>
    <span class="c1">#             if isinstance(e, EmptyZipError) or e.args[-1].endswith(&#39;archive&#39;):</span>
    <span class="c1">#                 pass  #</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 raise OverwriteNotAllowed(f&quot;You&#39;re not allowed to overwrite an existing</span>
    <span class="c1">#                 key: {k}&quot;)</span>

    <span class="c1"># TODO: Repeated with zip_writer logic. Consider DRY possibilities.</span>
    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_overwrites</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>  <span class="c1"># remove key so it can be overwritten</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">OverwriteNotAllowed</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;When using the context mode, you&#39;re not allowed to overwrite an &quot;</span>
                        <span class="sa">f</span><span class="s1">&#39;existing key: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">OverwriteNotAllowed</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;You&#39;re not allowed to overwrite an existing key: </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ZipFile</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile_init_kw</span>
            <span class="p">)</span> <span class="k">as</span> <span class="n">zip_writer</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">zip_writer</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_open_kw</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;zip -d </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># raise NotImplementedError(&quot;zipfile, the backend of ZipStore, doesn&#39;t support deletion,</span>
        <span class="c1"># so neither will we.&quot;)</span>

    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer</span> <span class="o">=</span> <span class="n">ZipFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zip_filepath</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_zipfile_init_kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip_writer_opened</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="nb">open</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<span class="n">PathString</span> <span class="o">=</span> <span class="nb">str</span>
<span class="n">PathFilterFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">PathString</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>


<div class="viewcode-block" id="remove_some_entries_from_zip"><a class="viewcode-back" href="../../module_docs/dol/zipfiledol.html#dol.zipfiledol.remove_some_entries_from_zip">[docs]</a><span class="k">def</span> <span class="nf">remove_some_entries_from_zip</span><span class="p">(</span>
    <span class="n">zip_source</span><span class="p">,</span>
    <span class="n">keys_to_be_removed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">PathFilterFunc</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">PathString</span><span class="p">]],</span>
    <span class="n">ask_before_before_deleting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes specific keys from a zip file.</span>

<span class="sd">    :param zip_source: zip filepath, bytes, or whatever a ``ZipStore`` can take</span>
<span class="sd">    :param keys_to_be_removed: An iterable of keys or a boolean filter function</span>
<span class="sd">    :param ask_before_before_deleting: True (default) if the user should be</span>
<span class="sd">        presented with the keys first, and asked permission to delete.</span>
<span class="sd">    :return: The ZipStore (in case you want to do further work with it)</span>

<span class="sd">    Tip: If you want to delete with no questions asked, use currying:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; rm_keys_without_asking = partial(</span>
<span class="sd">    ...     remove_some_entries_from_zip,</span>
<span class="sd">    ...     ask_before_before_deleting=False</span>
<span class="sd">    ... )</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">ZipStore</span><span class="p">(</span><span class="n">zip_source</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys_to_be_removed</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys_to_be_removed</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">keys_to_be_removed</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys_to_be_removed</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys_to_be_removed</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
        <span class="n">keys_to_be_removed</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys_to_be_removed</span><span class="p">)</span>
    <span class="n">keys_that_will_be_deleted</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">keys_to_be_removed</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">keys_that_will_be_deleted</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ask_before_before_deleting</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;These keys will be removed:</span><span class="se">\n\r</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">keys_that_will_be_deleted</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_that_will_be_deleted</span><span class="p">)</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Should I go ahead and delete these </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1"> keys? (y/N)&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">answer</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Okay, I will NOT delete these.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys_that_will_be_deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">z</span></div>


<span class="kn">from</span> <span class="nn">dol.util</span> <span class="kn">import</span> <span class="n">not_a_mac_junk_path</span>


<span class="k">def</span> <span class="nf">is_a_mac_junk_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">not_a_mac_junk_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>


<span class="n">remove_mac_junk_from_zip</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">remove_some_entries_from_zip</span><span class="p">,</span>
    <span class="n">keys_to_be_removed</span><span class="o">=</span><span class="n">is_a_mac_junk_path</span><span class="p">,</span>
    <span class="n">ask_before_before_deleting</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">remove_mac_junk_from_zip</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;Removes mac junk keys from zip&#39;</span>

<span class="c1"># TODO: The way prefix and file_info_filt is handled is not efficient</span>
<span class="c1"># TODO: prefix is silly: less general than filename_filt would be, and not even producing</span>
<span class="c1">#  relative paths</span>
<span class="c1">#  (especially when getitem returns subdirs)</span>


<span class="c1"># trans alternative:</span>
<span class="c1"># from dol.trans import mk_kv_reader_from_kv_collection, wrap_kvs</span>
<span class="c1">#</span>
<span class="c1"># ZipFileReader = wrap_kvs(mk_kv_reader_from_kv_collection(FileCollection, name=&#39;_ZipFileReader&#39;),</span>
<span class="c1">#                          name=&#39;ZipFileReader&#39;,</span>
<span class="c1">#                          obj_of_data=ZipReader)</span>

<span class="c1">#</span>
<span class="c1"># if __name__ == &#39;__main__&#39;:</span>
<span class="c1">#     from dol.test.simple import test_local_file_ops</span>
<span class="c1">#</span>
<span class="c1">#     test_local_file_ops()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>